<!DOCTYPE html>
<html lang="en">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FlowGen - Display Flowchart</title>
<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<!-- App styles -->
<link rel="stylesheet" href="/static/styles/app.css" />
<style>
    /* Minimal, unobtrusive autosave status styles */
    .nav-status {
        margin-left: 12px;
        font-size: 12px;
        color: #6b7280;
        /* gray-500 */
        white-space: nowrap;
        user-select: none;
    }

    .nav-status.hidden {
        display: none;
    }

    .nav-status.dirty {
        color: #d97706;
    }

    /* amber-600 */
    .nav-status.saving {
        color: #2563eb;
    }

    /* blue-600 */
    .nav-status.saved {
        color: #059669;
    }

    /* emerald-600 */
    .nav-status.error {
        color: #dc2626;
    }

    /* red-600 */
</style>
</head>

<body>
    <!-- Modern flat Navbar -->
    <nav class="navbar" id="appNavbar">
        <a href="#" class="nav-brand" onclick="return false;">
            <span class="nav-logo" aria-label="FlowGen logo"></span>
            FlowGen
        </a>
        <div class="nav-section">
            <div class="nav-dropdown" id="navFileDd">
                <button class="nav-btn" onclick="toggleNavDropdown(event, 'navFileDd')">File ▾</button>
                <div class="nav-dropdown-menu">
                    <div class="nav-menu-item" onclick="openNewDiagramModal()">New…</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="openOpenDiagramModal()">Open…</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="saveDiagram(false, true)">Save</div>
                    <div class="nav-menu-item" onclick="openSaveAsModal()">Save As…</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="closeDiagram()">Close</div>
                </div>
            </div>
            <div class="nav-dropdown" id="navViewDd">
                <button class="nav-btn" onclick="toggleNavDropdown(event, 'navViewDd')">View ▾</button>
                <div class="nav-dropdown-menu">
                    <div class="nav-menu-item" id="navViewDiagram" onclick="switchView('diagram')">Diagram</div>
                    <div class="nav-menu-item" id="navViewRender" onclick="switchView('render')">Render</div>
                    <div class="nav-menu-item" id="navViewRaw" onclick="switchView('raw')">Raw Data</div>
                </div>
            </div>

            <div class="nav-dropdown" id="navLayoutDd">
                <button class="nav-btn" onclick="toggleNavDropdown(event, 'navLayoutDd')">Layout ▾</button>
                <div class="nav-dropdown-menu">
                    <div class="nav-menu-item" style="cursor:default;">
                        <label style="font-size:12px;color:#6b7280;display:block;margin-bottom:6px;">Connector
                            Routing</label>
                        <label style="display:flex;align-items:center;gap:8px;padding:4px 0;cursor:pointer;">
                            <input type="radio" name="navConnectorRouting" id="navRoutingStraight" value="straight"
                                onchange="onNavbarConnectorRoutingChange(event)" />
                            <span>Straight lines</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;padding:4px 0;cursor:pointer;">
                            <input type="radio" name="navConnectorRouting" id="navRoutingOrthogonal" value="orthogonal"
                                onchange="onNavbarConnectorRoutingChange(event)" />
                            <span>90° turns</span>
                        </label>
                    </div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item"
                        onclick="(function(){ bulkOpenIntent = true; openBulkEdgeEditorModal(); })()">Format all
                        connectors…</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="openDefaultsPanel(event)">Defaults</div>

                </div>
            </div>
        </div>
        <div class="nav-spacer"></div>
        <div class="nav-section">
            <button class="nav-btn primary" id="navbarSaveBtn" onclick="saveDiagram(false, true)">Save</button>
            <span id="autosaveStatus" class="nav-status" aria-live="polite" title="Autosave status"></span>
        </div>
    </nav>
    <div class="container-fluid p-3">
        <!-- Diagram Tab Content -->
        <div id="diagramTab" class="main-tab-content active">
            <div class="diagram-layout">
                <div class="diagram-main">
                    <div class="card">
                        <div class="card-body flowchart-body" id="flowchartCardBody">
                            <div id="flowchartDisplay">
                                <div class="loading">Click "Load Diagram" to display the flowchart</div>
                            </div>
                            <!-- Compact Zoom overlay -->
                            <div class="zoom-overlay" id="zoomOverlay">
                                <button class="btn btn-sm btn-outline-secondary" onclick="zoomOut()"
                                    title="Zoom out">-</button>
                                <div class="zoom-level"><span id="zoomLevelLabel">100%</span></div>
                                <button class="btn btn-sm btn-outline-secondary" onclick="zoomIn()"
                                    title="Zoom in">+</button>
                                <button class="btn btn-sm btn-outline-secondary" onclick="zoomReset()"
                                    title="Reset zoom to 100%">100%</button>
                            </div>
                        </div>
                    </div>
                </div>
                <aside id="infoPanel" class="card flex-shrink-0" aria-live="polite" style="width:360px;">
                    <div id="infoPanelHeader" class="card-header d-none"></div>
                    <div id="infoPanelBody" class="card-body"></div>
                    <div id="infoPanelFooter" class="card-footer d-none"></div>
                </aside>
            </div>
        </div>

        <!-- Configuration Tab Content -->
        <div id="configurationTab" class="main-tab-content">
            <div class="yaml-controls">
                <button class="btn btn-sm btn-outline-secondary" onclick="loadYamlConfig()">📥 Load YAML</button>
                <button class="btn btn-sm btn-outline-secondary" onclick="saveYamlConfig()">💾 Save YAML</button>
                <button class="btn btn-sm btn-outline-secondary" onclick="validateYaml()">✅ Validate</button>
                <button class="btn btn-sm btn-outline-primary" onclick="applyYamlChanges()">🔄 Apply Changes</button>
            </div>

            <div class="yaml-container">
                <h3>YAML Configuration</h3>
                <textarea id="yamlEditor" class="yaml-editor" placeholder="Loading YAML configuration..."></textarea>
                <div id="yamlStatus" class="yaml-status" style="display: none;"></div>
            </div>
        </div>



        <!-- Node Editor (docked content only; no grouping titles) -->
        <div id="nodeEditor" class="node-editor">
            <div class="editor-content">
                <div class="editor-section" style="margin-bottom:12px;">
                    <div class="editor-group">
                        <label for="nodeType">Type & Shape:</label>
                        <select id="nodeType" onchange="updateShapePreview()">
                            <option value="process">📦 Process (Rectangle)</option>
                            <option value="start">🟢 Start (Circle)</option>
                            <option value="end">🔴 End (Circle)</option>
                            <option value="decision">💎 Decision (Diamond)</option>
                            <option value="data">📊 Data (Hexagon)</option>
                            <option value="io">📥 Input/Output (Parallelogram)</option>
                            <option value="manualInput">⌨️ Manual Input (Trapezoid)</option>
                            <option value="subroutine">🧩 Subroutine (Double-Sided)</option>
                            <option value="database">🛢️ Database (Cylinder)</option>
                            <option value="delay">⏱️ Delay (D-shape)</option>
                            <option value="offPage">📄 Off Page</option>
                            <option value="connector">🔗 Connector (Circle)</option>
                        </select>
                    </div>
                </div>

                <div class="editor-section" style="margin-bottom:12px;">
                    <div class="editor-group">
                        <label>Fill Color:</label>
                        <div class="color-grid" id="fillColorGrid">
                            <div class="color-option" style="background: #2ecc71" data-color="#2ecc71"></div>
                            <div class="color-option" style="background: #3498db" data-color="#3498db"></div>
                            <div class="color-option" style="background: #9b59b6" data-color="#9b59b6"></div>
                            <div class="color-option" style="background: #f39c12" data-color="#f39c12"></div>
                            <div class="color-option" style="background: #e74c3c" data-color="#e74c3c"></div>
                            <div class="color-option" style="background: #1abc9c" data-color="#1abc9c"></div>
                            <div class="color-option" style="background: #34495e" data-color="#34495e"></div>
                            <div class="color-option" style="background: #95a5a6" data-color="#95a5a6"></div>
                            <div class="color-option" style="background: #16a085" data-color="#16a085"></div>
                            <div class="color-option" style="background: #8e44ad" data-color="#8e44ad"></div>
                            <div class="color-option" style="background: #d35400" data-color="#d35400"></div>
                            <div class="color-option" style="background: #c0392b" data-color="#c0392b"></div>
                            <div class="color-option" style="background: #27ae60" data-color="#27ae60"></div>
                            <div class="color-option" style="background: #2980b9" data-color="#2980b9"></div>
                            <div class="color-option" style="background: #8e44ad" data-color="#8e44ad"></div>
                            <div class="color-option" style="background: #f1c40f" data-color="#f1c40f"></div>
                        </div>
                    </div>
                    <div class="editor-group">
                        <label>Custom Color:</label>
                        <div style="display:flex; align-items:center; gap:10px; flex-wrap: wrap;">
                            <input type="color" id="customColorInput"
                                style="width:40px; height:32px; padding:0; border:none; background:transparent;" />
                            <input type="text" id="customHexInput" placeholder="#RRGGBB"
                                style="width:110px; padding:6px 8px;" />
                            <button class="btn btn-sm btn-outline-secondary" id="addFavoriteColorBtn" type="button">⭐
                                Add to Favorites</button>
                            <input type="hidden" id="selectedColorValue" />
                        </div>
                    </div>
                    <div class="editor-group">
                        <label>Favorites:</label>
                        <div id="favoriteColors" class="color-grid"></div>
                    </div>
                    <div class="editor-group">
                        <label for="nodeBorderColor">Border Color:</label>
                        <input type="color" id="nodeBorderColor" value="#1f2937" />
                    </div>
                    <div class="editor-group">
                        <label for="nodeBorderWidth">Border Width (px):</label>
                        <input type="number" id="nodeBorderWidth" min="0" max="10" step="1" value="2" />
                    </div>
                </div>

            </div>
            <div class="editor-buttons">
                <button class="btn btn-danger" onclick="confirmDeleteCurrentNode()">Delete</button>
            </div>
        </div>

        <!-- Edge Editor (docked content only; no grouping title) -->
        <div id="edgeEditor" class="node-editor" style="display:none;">
            <div class="editor-content">
                <div class="editor-group">
                    <label for="edgeName">Label:</label>
                    <input type="text" id="edgeName" placeholder="e.g. calls, publishes" />
                </div>
                <div class="compact-row">
                    <div class="editor-group">
                        <label for="edgeTechnology">Technology:</label>
                        <select id="edgeTechnology">
                            <option value="">— None —</option>
                            <option value="rest">REST</option>
                            <option value="ws">WebSocket</option>
                            <option value="grpc">gRPC</option>
                        </select>
                    </div>

                    <div class="editor-group">
                        <label for="edgeWidth">Width (px):</label>
                        <input type="number" id="edgeWidth" min="1" max="10" step="1" value="2" />
                    </div>
                </div>
                <div class="compact-row">
                    <div class="editor-group">
                        <label for="edgeStroke">Stroke Color:</label>
                        <input type="color" id="edgeStroke" value="#34495e" />
                    </div>
                    <div class="editor-group">
                        <label for="edgeDash">Line Style:</label>
                        <select id="edgeDash">
                            <option value="solid">Solid</option>
                            <option value="dotted">Dotted</option>
                            <option value="dashed">Dashed</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="editor-buttons">
                <button class="btn btn-danger" onclick="deleteEdgeFromEditor()">Delete</button>
            </div>
        </div>

    </div>

    <!-- Bootstrap JS bundle (for any future Bootstrap components we might use) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>

    <!-- New Diagram Modal -->
    <div id="newDiagramModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">🆕 New Diagram</div>
            <div class="modal-body">
                <div class="editor-group">
                    <label for="newDiagramId">ID (file name):</label>
                    <input type="text" id="newDiagramId" placeholder="e.g. my_new_diagram" />
                </div>
                <div class="editor-group">
                    <label for="newDiagramName">Name:</label>
                    <input type="text" id="newDiagramName" placeholder="Diagram name" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeNewDiagramModal()">Cancel</button>
                <button class="btn-save" onclick="createNewDiagram()">Create</button>
            </div>
        </div>
    </div>

    <!-- Open Diagram Modal -->
    <div id="openDiagramModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">📂 Open Diagram</div>
            <div class="modal-body">
                <div id="openDiagramList">Loading…</div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeOpenDiagramModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Save As Modal -->
    <div id="saveAsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">💾 Save As</div>
            <div class="modal-body">
                <div class="editor-group">
                    <label for="saveAsId">New ID (file name):</label>
                    <input type="text" id="saveAsId" placeholder="e.g. my_new_copy" />
                </div>
                <div class="editor-group">
                    <label for="saveAsName">Name:</label>
                    <input type="text" id="saveAsName" placeholder="Diagram name" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeSaveAsModal()">Cancel</button>
                <button class="btn-save" onclick="performSaveAs()">Save</button>
            </div>
        </div>
    </div>

    <!-- Bulk Edge Formatter Modal -->
    <div id="bulkEdgeEditorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">🎨 Format All Connectors</div>
            <div class="modal-body">
                <div class="compact-row">
                    <div class="editor-group">
                        <label for="bulkEdgeStroke">Stroke Color:</label>
                        <input type="color" id="bulkEdgeStroke" value="#34495e" />
                    </div>
                    <div class="editor-group">
                        <label for="bulkEdgeWidth">Width (px):</label>
                        <input type="number" id="bulkEdgeWidth" min="1" max="10" step="1" value="2" />
                    </div>
                </div>
                <div class="editor-group">
                    <label for="bulkEdgeDash">Line Style:</label>
                    <select id="bulkEdgeDash">
                        <option value="solid">Solid</option>
                        <option value="dotted">Dotted</option>
                        <option value="dashed">Dashed</option>
                    </select>
                </div>
                <div style="font-size: 12px; color:#6b7280;">
                    This will overwrite stroke color, width, and dash pattern on all connectors in the diagram.
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeBulkEdgeEditorModal()">Cancel</button>
                <button class="btn-save" onclick="applyBulkEdgeFormatting()">Apply to All</button>
            </div>
        </div>
    </div>

    <!-- In-canvas Empty State -->
    <template id="emptyStateTemplate">
        <div class="empty-state">
            <div class="empty-state-card">
                <div class="empty-state-icon">📊</div>
                <div class="empty-state-title">Welcome to FlowGen</div>
                <div class="empty-state-desc">Open an existing diagram or create a new one to get started.</div>
                <div class="empty-state-actions">
                    <button class="btn-outline" onclick="openOpenDiagramModal()">📂 Open</button>
                    <button class="btn-solid" onclick="openNewDiagramModal()">🆕 New Diagram</button>
                </div>
            </div>
        </div>
    </template>

    <script>
        let currentDiagram = null;
        let editMode = true;
        // Track whether we are showing a static SVG render (true) or interactive editor (false)
        let isRenderMode = false;
        // Zoom state
        let zoomScale = 1.0; // 100%
        const ZOOM_MIN = 0.25, ZOOM_MAX = 2.5, ZOOM_STEP = 0.1;
        // Restore persisted zoom if available
        try {
            const savedZoom = parseFloat(localStorage.getItem('flowgen.zoomScale'));
            if (!Number.isNaN(savedZoom)) {
                zoomScale = Math.min(Math.max(savedZoom, ZOOM_MIN), ZOOM_MAX);
            }
        } catch (_) { }
        let draggedNode = null;
        let nodeOffset = { x: 0, y: 0 };
        let dragUpdateTimer = null;
        let isUpdatingConnections = false;
        let hasUnsavedChanges = false;
        let editingNode = null;
        let editingNodeElement = null;
        // Node editor docking state
        let editorDocked = false;
        // Last successful save timestamp
        let lastSavedAt = null;

        // Grid and Layout Settings
        let gridEnabled = false;
        // Runtime-only flag to remember if we forced the grid on due to Edit Mode
        let gridForcedByEdit = false;
        let snapToGrid = false;
        let gridSize = 25;
        let gridSvg = null;
        // Grid visual customization
        let gridColor = '#bdc3c7';
        let gridOpacity = 0.3;
        let selectedNodeElement = null;
        let selectedEdgeId = null;
        // Guard so bulk connector editor only opens from explicit nav click
        let bulkOpenIntent = false;
        // Remember last-used connector sides per edge to reduce jitter while dragging
        const edgeRoutingState = new Map(); // edgeId -> { fromSide, toSide }
        // Edge creation state: { sourceNodeId, sourceSide, startX, startY, previewLine }
        let edgeCreation = null;

        // Last opened diagram persistence
        const LAST_DIAGRAM_KEY = 'flowgen.lastDiagramId';
        function setLastOpenedDiagramId(id) {
            try { localStorage.setItem(LAST_DIAGRAM_KEY, id || ''); } catch (_) { }
        }

        // ======= Navbar handlers =======
        function toggleNavDropdown(event, id) {
            event.stopPropagation();
            const dd = document.getElementById(id);
            if (!dd) return;
            const isOpen = dd.classList.contains('open');
            document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
            if (!isOpen) dd.classList.add('open');
        }
        function openDefaultsPanel(event) {
            if (event) event.stopPropagation();
            // Open the sliding panel and dock the Defaults UI inside it
            try { dockDefaultsPanel(); } catch (_) { renderDefaultsPanel(); }
            // Close any open dropdowns
            document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
        }
        document.addEventListener('click', () => {
            document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
            }
        });

        // Keep navbar grid controls in sync with app settings
        function populateNavbarGridControls() {
            const snapEl = document.getElementById('navGridSnap');
            const sizeEl = document.getElementById('navGridSize');
            const colorEl = document.getElementById('navGridColor');
            const opacityEl = document.getElementById('navGridOpacity');
            if (snapEl) snapEl.checked = !!appSettings.snapToGrid;
            if (sizeEl) sizeEl.value = appSettings.gridSize;
            if (colorEl) colorEl.value = appSettings.gridColor || '#bdc3c7';
            if (opacityEl) opacityEl.value = appSettings.gridOpacity ?? 0.3;
        }
        function applyNavbarGridChange() {
            const snapEl = document.getElementById('navGridSnap');
            const sizeEl = document.getElementById('navGridSize');
            const colorEl = document.getElementById('navGridColor');
            const opacityEl = document.getElementById('navGridOpacity');
            if (snapEl) appSettings.snapToGrid = !!snapEl.checked;
            if (sizeEl) appSettings.gridSize = Math.max(5, Math.min(200, parseInt(sizeEl.value || '25', 10)));
            if (colorEl) appSettings.gridColor = colorEl.value || '#bdc3c7';
            if (opacityEl) appSettings.gridOpacity = Math.max(0, Math.min(1, parseFloat(opacityEl.value || '0.3')));
            saveAppSettingsSilent();
            applySettings(true);
            populateRibbonGridControls();
        }

        // Quick add from navbar using its dropdown selection
        function quickAddFromNavbar() {
            const navSel = document.getElementById('navInsertType');
            const insertSel = document.getElementById('insertNodeType');
            if (insertSel && navSel) insertSel.value = navSel.value;
            quickAddNode();
            // close dropdown after action
            const dd = document.getElementById('navInsertDd');
            if (dd) dd.classList.remove('open');
        }

        function openSaveAsModal() {
            const idEl = document.getElementById('saveAsId');
            const nameEl = document.getElementById('saveAsName');
            if (currentDiagram) {
                idEl.value = `${currentDiagram.id || 'diagram'}_copy`;
                nameEl.value = `${currentDiagram.name || 'Diagram'} (copy)`;
            } else {
                idEl.value = '';
                nameEl.value = '';
            }
            document.getElementById('saveAsModal').style.display = 'flex';
        }
        function closeSaveAsModal() { document.getElementById('saveAsModal').style.display = 'none'; }

        async function performSaveAs() {
            const newId = (document.getElementById('saveAsId').value || '').trim();
            const newName = (document.getElementById('saveAsName').value || '').trim();
            if (!newId) { showMessage('Please enter a new ID', 'error'); return; }
            if (!currentDiagram) { showMessage('No diagram to save', 'error'); return; }
            const copy = JSON.parse(JSON.stringify(getDiagramForSave(currentDiagram)));
            copy.id = newId;
            copy.name = newName || copy.name || newId;
            try {
                const res = await fetch('http://localhost:3001/api/v1/diagrams', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(copy)
                });
                if (!res.ok) { const err = await res.text(); throw new Error(err || 'Save As failed'); }
                closeSaveAsModal();
                const created = await res.json();
                currentDiagram = normalizeDiagramNumbers(created);
                setLastOpenedDiagramId(created.id);
                renderFlowchart(currentDiagram);
                updateConnections();
                updateDiagramInfoBox();
                hasUnsavedChanges = false; const sb = document.getElementById('saveButton'); if (sb) sb.classList.remove('show');
                showMessage('Saved a copy', 'success');
            } catch (e) {
                showMessage(`Save As failed: ${e.message}`, 'error');
            }
        }

        function closeDiagram() {
            currentDiagram = null;
            try { localStorage.removeItem(LAST_DIAGRAM_KEY); } catch (_) { }
            const display = document.getElementById('flowchartDisplay');
            const tpl = document.getElementById('emptyStateTemplate');
            if (display && tpl) {
                display.innerHTML = '';
                display.appendChild(tpl.content.cloneNode(true));
            }
            updateDiagramInfoBox();
            clearInfoPanelBody();
            // Ensure node editor is closed if docked
            if (editorDocked) closeNodeEditor();
            const sb = document.getElementById('saveButton'); if (sb) sb.classList.remove('show');
        }
        function getLastOpenedDiagramId() {
            try { return localStorage.getItem(LAST_DIAGRAM_KEY) || ''; } catch (_) { return ''; }
        }

        // Always-on Edit Mode flag
        const ALWAYS_EDIT_MODE = true;
        function activateRibbonTab(name) {
            document.querySelectorAll('.ribbon-tab-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.querySelector(`.ribbon-tab-btn[data-tab="${name}"]`);
            if (activeBtn) activeBtn.classList.add('active');
            document.querySelectorAll('.ribbon-tab-pane').forEach(p => p.style.display = 'none');
            const pane = document.getElementById(`ribbon-tab-${name}`);
            if (pane) pane.style.display = 'block';
        }

        // New: switch main app sections via ribbon tabs
        function switchMainSection(section) {
            // Show section content (diagram and configuration are content areas)
            ['diagram', 'configuration'].forEach(name => {
                const el = document.getElementById(name + 'Tab');
                if (el) el.style.display = (name === section ? 'block' : 'none');
            });
            // Show/hide main action groups; View group stays visible for toggling
            const fileGroup = document.getElementById('fileRibbonGroup');
            const layoutGroup = document.getElementById('layoutRibbonGroup');
            const viewGroup = document.getElementById('viewRibbonGroup');
            // Keep File group (with Save) visible for both Diagram and Raw Data views
            if (fileGroup) fileGroup.style.display = 'block';
            // Layout actions are only relevant in the Diagram view
            if (layoutGroup) layoutGroup.style.display = (section === 'diagram' ? 'block' : 'none');
            if (viewGroup) viewGroup.style.display = 'block';

            // Sync View button active states
            updateViewButtons(section);
            // Lazy-load YAML when switching to raw view
            if (section === 'configuration') {
                loadYamlConfig();
            }
        }

        // View switcher maps to top-level sections and updates button state
        function switchView(view) {
            if (view === 'diagram') {
                // Ensure we're in the diagram section with interactive editor
                switchMainSection('diagram');
                if (isRenderMode) {
                    renderEditable();
                } else {
                    // If nothing is rendered yet, ensure editor is visible
                    if (currentDiagram) {
                        renderFlowchart(currentDiagram);
                        updateConnections();
                        updateGridSettings();
                    }
                }
                updateViewButtons('diagram');
            } else if (view === 'render') {
                // Render static SVG in the diagram area
                switchMainSection('diagram');
                renderSVG();
                updateViewButtons('diagram');
            } else if (view === 'raw') {
                // Switch to YAML editor
                switchMainSection('configuration');
                updateViewButtons('configuration');
            }
        }

        function updateViewButtons(section) {
            const diagBtn = document.getElementById('viewDiagramBtn');
            const renderBtn = document.getElementById('viewRenderBtn');
            const rawBtn = document.getElementById('viewRawBtn');
            const navDiag = document.getElementById('navViewDiagram');
            const navRender = document.getElementById('navViewRender');
            const navRaw = document.getElementById('navViewRaw');
            if (diagBtn && renderBtn && rawBtn) {
                const inDiagramSection = section === 'diagram';
                const inRaw = section === 'configuration';
                diagBtn.classList.toggle('active', inDiagramSection && !isRenderMode);
                renderBtn.classList.toggle('active', inDiagramSection && isRenderMode);
                rawBtn.classList.toggle('active', inRaw);
            }
            // Sync navbar links
            if (navDiag && navRender && navRaw) {
                const inDiagramSection = section === 'diagram';
                const inRaw = section === 'configuration';
                navDiag.classList.toggle('active', inDiagramSection && !isRenderMode);
                navRender.classList.toggle('active', inDiagramSection && isRenderMode);
                navRaw.classList.toggle('active', inRaw);
            }
        }

        // ======= Slide-out Info Panel controls =======
        let infoPanelHover = false;
        let infoPanelCloseTimer = null;
        function applyInfoPanelState() {
            const panel = document.getElementById('infoPanel');
            const layout = document.querySelector('.diagram-layout');
            if (!panel) return;
            const body = document.getElementById('infoPanelBody');
            const footer = document.getElementById('infoPanelFooter');
            const hasBody = !!(body && body.childElementCount > 0);
            const hasFooter = !!(footer && footer.childElementCount > 0);
            const isOpen = !!editorDocked && (hasBody || hasFooter);
            // Show panel only when content exists
            panel.style.display = isOpen ? '' : 'none';
            panel.setAttribute('aria-hidden', String(!isOpen));
            // Always keep a consistent gap between columns
            if (layout) layout.classList.remove('no-info-gap');
        }
        function openInfoPanelTemp() { /* disabled hover-open */ }
        function maybeCloseInfoPanelTemp() { /* disabled hover-close */ }
        // toggleInfoPanel() removed with toggle handle
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize info panel state on load
            applyInfoPanelState();
            // Hover tracking disabled to avoid unintended opens/closes

            // Keep connectors aligned on viewport changes and container scroll
            const display = document.getElementById('flowchartDisplay');
            if (display) {
                display.addEventListener('scroll', () => {
                    // Debounce minimal — connectors are quick to redraw
                    try { updateConnections(); } catch (_) { }
                });
            }
            window.addEventListener('resize', () => {
                try { updateConnections(); } catch (_) { }
            });
        });
        function setSelectedNode(nodeEl) {
            if (selectedNodeElement === nodeEl) return;
            selectedNodeElement = nodeEl;
        }


        // Old switchMainTab removed; ribbon now controls sections via switchMainSection

        // YAML Configuration functions
        function getActiveDiagramId() {
            return (currentDiagram && currentDiagram.id) ? currentDiagram.id : 'my_process_flow';
        }
        async function loadYamlConfig() {
            const yamlEditor = document.getElementById('yamlEditor');
            const yamlStatus = document.getElementById('yamlStatus');

            try {
                yamlEditor.value = 'Loading YAML configuration...';
                yamlStatus.style.display = 'none';

                const response = await fetch(`http://localhost:3001/api/v1/diagrams/${getActiveDiagramId()}/yaml`);
                if (response.ok) {
                    const yamlText = await response.text();
                    yamlEditor.value = yamlText;
                    showYamlStatus('YAML configuration loaded successfully', 'success');
                } else {
                    throw new Error(`Failed to load YAML: ${response.status}`);
                }
            } catch (error) {
                console.error('Error loading YAML:', error);
                yamlEditor.value = '# Error loading YAML configuration\n# Please check if the backend server is running';
                showYamlStatus(`Error loading YAML: ${error.message}`, 'error');
            }
        }

        async function saveYamlConfig() {
            const yamlEditor = document.getElementById('yamlEditor');
            const yamlContent = yamlEditor.value;

            try {
                const response = await fetch(`http://localhost:3001/api/v1/diagrams/${getActiveDiagramId()}/yaml`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: yamlContent
                });

                if (response.ok) {
                    showYamlStatus('YAML configuration saved successfully', 'success');
                } else {
                    throw new Error(`Failed to save YAML: ${response.status}`);
                }
            } catch (error) {
                console.error('Error saving YAML:', error);
                showYamlStatus(`Error saving YAML: ${error.message}`, 'error');
            }
        }

        function validateYaml() {
            const yamlEditor = document.getElementById('yamlEditor');
            const yamlContent = yamlEditor.value;

            try {
                // Basic YAML validation - check for common syntax issues
                const lines = yamlContent.split('\n');
                let hasErrors = false;
                let errorMessage = '';

                lines.forEach((line, index) => {
                    // Check for tabs (YAML should use spaces)
                    if (line.includes('\t')) {
                        hasErrors = true;
                        errorMessage = `Line ${index + 1}: YAML should use spaces, not tabs`;
                        return;
                    }

                    // Check for basic syntax issues
                    if (line.trim().length > 0 && !line.trim().startsWith('#')) {
                        const colonIndex = line.indexOf(':');
                        if (colonIndex > 0) {
                            const afterColon = line.substring(colonIndex + 1);
                            if (afterColon.length > 0 && !afterColon.startsWith(' ')) {
                                hasErrors = true;
                                errorMessage = `Line ${index + 1}: Space required after colon`;
                                return;
                            }
                        }
                    }
                });

                if (hasErrors) {
                    showYamlStatus(`YAML validation failed: ${errorMessage}`, 'error');
                } else {
                    showYamlStatus('YAML validation passed - syntax looks good', 'success');
                }
            } catch (error) {
                showYamlStatus(`YAML validation error: ${error.message}`, 'error');
            }
        }

        async function applyYamlChanges() {
            // First save the YAML
            await saveYamlConfig();

            // Then reload the diagram to reflect changes
            await loadDiagram();
            updateDiagramInfoBox();

            // Switch back to diagram tab to see changes
            switchMainSection('diagram');

            showMessage('YAML changes applied and diagram reloaded', 'success');
        }

        function showYamlStatus(message, type) {
            const yamlStatus = document.getElementById('yamlStatus');
            yamlStatus.textContent = message;
            yamlStatus.className = `yaml-status ${type}`;
            yamlStatus.style.display = 'block';

            // Auto-hide after 5 seconds
            setTimeout(() => {
                yamlStatus.style.display = 'none';
            }, 5000);
        }

        async function loadDiagram() {
            const display = document.getElementById('flowchartDisplay');
            display.innerHTML = '<div class="loading">Loading diagram...</div>';

            try {

                const response = await fetch('http://localhost:3001/api/v1/diagrams');
                const data = await response.json();


                if (data.diagrams && data.diagrams.length > 0) {
                    currentDiagram = normalizeDiagramNumbers(data.diagrams[0]); // Use first diagram and normalize
                    // Remember which diagram we loaded so refresh restores the same one
                    try { setLastOpenedDiagramId(data.diagrams[0].id || ''); } catch (_) { }

                    renderFlowchart(currentDiagram);
                    updateDiagramInfoBox();
                } else {
                    display.innerHTML = '<div class="loading">No diagrams found</div>';
                    currentDiagram = null;
                    updateDiagramInfoBox();
                }
            } catch (error) {
                console.error('Error loading diagram:', error);
                display.innerHTML = `<div style="color: red;">Error loading diagram: ${error.message}</div>`;
                currentDiagram = null;
                updateDiagramInfoBox();
            }
        }

        // ======= New/Open Diagram =======
        function openNewDiagramModal() {
            document.getElementById('newDiagramId').value = '';
            document.getElementById('newDiagramName').value = '';
            document.getElementById('newDiagramModal').style.display = 'flex';
        }
        function closeNewDiagramModal() { document.getElementById('newDiagramModal').style.display = 'none'; }

        async function createNewDiagram() {
            const id = (document.getElementById('newDiagramId').value || '').trim();
            const name = (document.getElementById('newDiagramName').value || '').trim();
            if (!id) { showMessage('Please enter an ID for the diagram', 'error'); return; }
            const payload = {
                id, name: name || id,
                version: '1.0.0',
                nodes: [], edges: [],
                layout: { direction: 'top-bottom', spacing: { node: 50, rank: 100 } }
            };
            try {
                const res = await fetch('http://localhost:3001/api/v1/diagrams', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!res.ok) { const err = await res.text(); throw new Error(err || 'Failed to create'); }
                closeNewDiagramModal();
                // Load newly created diagram explicitly
                const created = await res.json();
                currentDiagram = created;
                setLastOpenedDiagramId(created.id);
                renderFlowchart(currentDiagram);
                updateConnections();
                updateDiagramInfoBox();
                showMessage('New diagram created', 'success');
            } catch (e) {
                showMessage(`Create failed: ${e.message}`, 'error');
            }
        }

        function openOpenDiagramModal() {
            const modal = document.getElementById('openDiagramModal');
            const list = document.getElementById('openDiagramList');
            list.innerHTML = 'Loading…';
            modal.style.display = 'flex';
            fetch('http://localhost:3001/api/v1/diagrams')
                .then(r => r.json())
                .then(data => {
                    const diagrams = data.diagrams || [];
                    if (!diagrams.length) { list.innerHTML = '<div>No diagrams found</div>'; return; }
                    const ul = document.createElement('ul'); ul.style.listStyle = 'none'; ul.style.padding = '0';
                    diagrams.forEach(d => {
                        const li = document.createElement('li'); li.style.padding = '6px 0';
                        const a = document.createElement('a'); a.href = '#'; a.textContent = `${d.name} (${d.id})`;
                        a.onclick = (ev) => { ev.preventDefault(); selectDiagram(d.id); };
                        li.appendChild(a); ul.appendChild(li);
                    });
                    list.replaceChildren(ul);
                })
                .catch(err => { list.innerHTML = `<div style="color:red;">Error: ${err.message}</div>`; });
        }
        function closeOpenDiagramModal() { document.getElementById('openDiagramModal').style.display = 'none'; }

        async function selectDiagram(id) {
            try {
                const res = await fetch(`http://localhost:3001/api/v1/diagrams/${id}`);
                if (!res.ok) throw new Error('Failed to load diagram');
                const diag = await res.json();
                currentDiagram = normalizeDiagramNumbers(diag);
                setLastOpenedDiagramId(diag.id || id);
                renderFlowchart(currentDiagram);
                updateConnections();
                closeOpenDiagramModal();
                showMessage(`Opened diagram: ${diag.name}`, 'success');
                updateDiagramInfoBox();
            } catch (e) {
                showMessage(`Open failed: ${e.message}`, 'error');
            }
        }

        function toggleEditMode() {
            if (ALWAYS_EDIT_MODE) {
                showMessage('Edit Mode is always on', 'info');
                return;
            }
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const nodes = document.querySelectorAll('.node');

            if (editMode) {
                if (btn) { btn.textContent = '🔒 View Mode'; btn.style.background = '#e74c3c'; }
                nodes.forEach(node => {
                    node.style.cursor = 'move';
                    enableDragging(node);
                });
                // Do not force grid visible while in edit mode anymore
                showMessage('Edit Mode: Drag to move, Double-click to edit, Right-click for options. Delete nodes via the editor.', 'info');
            } else {
                if (btn) { btn.textContent = '✏️ Edit Mode'; btn.style.background = '#3498db'; }
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    disableDragging(node);
                });
                // No special grid forcing while leaving edit mode
                closeNodeEditor(); // Close editor when exiting edit mode
                showMessage('View Mode: Click nodes for info', 'info');
            }
        }

        function enableDragging(nodeEl) {
            nodeEl.addEventListener('mousedown', handleMouseDown);
            nodeEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        }

        function disableDragging(nodeEl) {
            nodeEl.removeEventListener('mousedown', handleMouseDown);
            nodeEl.removeEventListener('touchstart', handleTouchStart);
        }

        function handleMouseDown(e) {
            if (!editMode) return;
            e.preventDefault();
            e.stopPropagation(); // Prevent conflicts with other handlers
            startDrag(e.target.closest('.node'), e.clientX, e.clientY);
        }

        function handleTouchStart(e) {
            if (!editMode) return;
            e.preventDefault();
            const touch = e.touches[0];
            startDrag(e.target.closest('.node'), touch.clientX, touch.clientY);
        }

        function startDrag(element, clientX, clientY) {
            if (!element || !element.classList.contains('node')) return;

            draggedNode = element;
            draggedNode.classList.add('dragging');

            // Remember original position to detect actual movement
            draggedNode.dataset.origLeft = String(parseInt(draggedNode.style.left) || 0);
            draggedNode.dataset.origTop = String(parseInt(draggedNode.style.top) || 0);

            const rect = draggedNode.getBoundingClientRect();

            nodeOffset.x = clientX - rect.left;
            nodeOffset.y = clientY - rect.top;

            // Add global event listeners
            document.addEventListener('mousemove', handleMouseMove, { passive: false });
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            // Disable text selection during drag
            document.body.style.userSelect = 'none';
        }

        function handleMouseMove(e) {
            if (!draggedNode && !edgeCreation) return;
            e.preventDefault();
            e.stopPropagation();
            if (draggedNode) updateNodePosition(e.clientX, e.clientY);
            if (edgeCreation) updateEdgeCreationPreview(e.clientX, e.clientY);
        }

        function handleTouchMove(e) {
            if (!draggedNode && !edgeCreation) return;
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            if (draggedNode) updateNodePosition(touch.clientX, touch.clientY);
            if (edgeCreation) updateEdgeCreationPreview(touch.clientX, touch.clientY);
        }

        function updateNodePosition(clientX, clientY) {
            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();

            // Account for container scroll when converting to stage/content coordinates
            let newX = ((clientX - displayRect.left) + displayEl.scrollLeft - nodeOffset.x) / zoomScale;
            let newY = ((clientY - displayRect.top) + displayEl.scrollTop - nodeOffset.y) / zoomScale;

            // Apply snap-to-grid (diamonds by center) with tolerance for smoother dragging
            if (snapToGrid && draggedNode) {
                const snapped = snapNodePosition(draggedNode, newX, newY, true);
                newX = snapped.x;
                newY = snapped.y;
            }

            // Constrain within container
            const maxX = ((displayRect.width + displayEl.scrollWidth - displayEl.clientWidth) / zoomScale) - draggedNode.offsetWidth;
            const maxY = ((displayRect.height + displayEl.scrollHeight - displayEl.clientHeight) / zoomScale) - draggedNode.offsetHeight;

            const constrainedX = Math.max(0, Math.min(newX, maxX));
            const constrainedY = Math.max(0, Math.min(newY, maxY));

            draggedNode.style.left = constrainedX + 'px';
            draggedNode.style.top = constrainedY + 'px';

            // Update connection point labels in real-time during drag
            // Labels removed; info panel updates elsewhere

            // Update connections in real-time during drag for better visual feedback
            // Cancel any pending update
            if (dragUpdateTimer) {
                clearTimeout(dragUpdateTimer);
                dragUpdateTimer = null;
            }

            // Update immediately if not already updating
            if (!isUpdatingConnections) {
                updateConnections();
            }
        }

        function handleMouseUp(e) {
            finishDrag();
            if (edgeCreation) finishEdgeCreation(e);
        }

        function handleTouchEnd(e) {
            finishDrag();
            if (edgeCreation) finishEdgeCreation(e.changedTouches && e.changedTouches[0]);
        }

        function finishDrag() {
            if (!draggedNode) return;

            draggedNode.classList.remove('dragging');

            // Apply final snap-to-grid if enabled (diamonds by center)
            if (snapToGrid) {
                // Use style-based coordinates (unaffected by rotation) to avoid jumpy behavior
                const currentX = parseInt(draggedNode.style.left) || 0;
                const currentY = parseInt(draggedNode.style.top) || 0;
                const snapped = snapNodePosition(draggedNode, currentX, currentY, false);
                draggedNode.style.left = snapped.x + 'px';
                draggedNode.style.top = snapped.y + 'px';
            }

            // Update the diagram data
            updateDiagramData();

            // On-canvas labels removed; info panel will update via hover/zoom hooks

            // Update connections one final time
            updateConnections();

            // If position actually changed, mark dirty and autosave
            const origLeft = parseInt(draggedNode.dataset.origLeft || '0');
            const origTop = parseInt(draggedNode.dataset.origTop || '0');
            const newLeft = parseInt(draggedNode.style.left) || 0;
            const newTop = parseInt(draggedNode.style.top) || 0;
            // Cleanup stored originals
            delete draggedNode.dataset.origLeft;
            delete draggedNode.dataset.origTop;

            if (origLeft !== newLeft || origTop !== newTop) {
                hasUnsavedChanges = true;
                const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                scheduleAutoSave();
                // Immediate silent autosave for position changes
                saveDiagram(true);
            }

            // Clean up
            if (dragUpdateTimer) {
                clearTimeout(dragUpdateTimer);
                dragUpdateTimer = null;
            }

            // Remove global event listeners
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);

            // Re-enable text selection
            document.body.style.userSelect = '';

            // Finally, clear draggedNode reference
            draggedNode = null;
        }

        function updateDiagramData() {
            if (!currentDiagram) return;

            const nodes = document.querySelectorAll('.node');
            const display = document.getElementById('flowchartDisplay');

            nodes.forEach((nodeEl, index) => {
                const nodeId = nodeEl.dataset.nodeId;
                const node = currentDiagram.nodes.find(n => n.id === nodeId);

                if (node) {
                    // Convert back to original coordinate system
                    const rect = nodeEl.getBoundingClientRect();
                    const displayRect = display.getBoundingClientRect();

                    node.position.x = parseInt(nodeEl.style.left) + 50; // Add back padding offset
                    node.position.y = parseInt(nodeEl.style.top) + 50;
                }
            });
        }

        function updateConnections() {
            if (!currentDiagram || !currentDiagram.edges) return;

            // Prevent concurrent updates that could cause multiple lines
            if (isUpdatingConnections) {
                return;
            }
            isUpdatingConnections = true;

            // Preserve current selection to restore after redraw
            const currentSelection = selectedEdgeId;
            const display = document.getElementById('flowchartDisplay');
            if (!display) {
                isUpdatingConnections = false;
                return;
            }
            const stage = document.getElementById('diagramStage') || display;

            try {
                // Diagnostics: counts before cleanup
                const preAllSvgs = display.querySelectorAll('svg');
                const preGridSvgs = display.querySelectorAll('svg.grid-overlay');
                const preConnSvgs = display.querySelectorAll('svg.connections-layer');
                const preHtmlEdges = display.querySelectorAll('.edge, .edge-label');


                // Safety cleanup: remove any legacy HTML-based edges
                preHtmlEdges.forEach(el => el.remove());

                // Extra safety: remove any stale connection elements anywhere in the document
                document.querySelectorAll('line.connection-line, polygon.connection-arrowhead, text.connection-label, rect.connection-label-bg, .tech-marker, .tech-marker-label').forEach(el => el.remove());

                // Extra safety: remove any connections-layer SVGs that are not within our display container
                document.querySelectorAll('svg.connections-layer').forEach(el => {
                    if (!display.contains(el)) el.remove();
                });

                // Safety cleanup: remove any existing connections-layer SVGs (preserve the grid overlay)
                const oldConnSvgs = display.querySelectorAll('svg.connections-layer');
                oldConnSvgs.forEach(el => el.remove());

                // Create a fresh connections SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.className = 'connections-layer';
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.zIndex = '1';
                svg.style.pointerEvents = 'auto';
                // Append to stage so it scales with zoom
                stage.appendChild(svg);

                // Create a fresh edges group inside the SVG
                const edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                edgesGroup.setAttribute('class', 'edges-layer');
                svg.appendChild(edgesGroup);

                // Rebuild connections with new positions
                const nodePositions = {};
                const nodes = document.querySelectorAll('.node');



                nodes.forEach(nodeEl => {
                    const nodeId = nodeEl.dataset.nodeId;
                    if (!nodeId) return; // Skip nodes without IDs

                    // Get position from element's style (more reliable than getBoundingClientRect)
                    const x = parseInt(nodeEl.style.left) || 0;
                    const y = parseInt(nodeEl.style.top) || 0;
                    const width = nodeEl.offsetWidth;
                    const height = nodeEl.offsetHeight;



                    // Validate coordinates - skip if invalid
                    if (isNaN(x) || isNaN(y) || width === 0 || height === 0) {

                        return;
                    }

                    // Find the node data to get the type
                    const nodeData = currentDiagram.nodes.find(n => n.id === nodeId);
                    const nodeType = nodeData ? nodeData.type : 'process';

                    nodePositions[nodeId] = {
                        id: nodeId,  // Add the node ID so calculateConnectionPoints can find the DOM element
                        x: x,
                        y: y,
                        centerX: x + width / 2,
                        centerY: y + height / 2,
                        width: width,
                        height: height,
                        type: nodeType
                    };
                });



                // Redraw edges with validation
                currentDiagram.edges.forEach(edge => {
                    // Validate edge data
                    if (!edge.from || !edge.to || edge.from === edge.to) return;
                    if (!edge.from.trim() || !edge.to.trim()) return; // Skip empty IDs



                    const fromNode = nodePositions[edge.from];
                    const toNode = nodePositions[edge.to];

                    if (fromNode && toNode) {

                        // Draw into the dedicated edges group
                        drawEdge(edgesGroup, fromNode, toNode, edge);
                    }
                });

                // Log the final state after drawing all connections

            } finally {
                // Release the update lock even if something throws
                isUpdatingConnections = false;
                // hover info disabled

                // Restore selection if there was one before the update
                if (currentSelection) {
                    selectEdge(currentSelection);
                }
            }
        }

        // Autosave configuration
        let autosaveEnabled = true;
        let autosaveDelay = 1500; // ms
        let autosaveTimer = null;

        function scheduleAutoSave() {
            if (!autosaveEnabled) return;
            if (!hasUnsavedChanges) return;
            try { clearTimeout(autosaveTimer); } catch (_) { }
            // Update nav status: pending autosave
            updateAutosaveStatus('pending');
            autosaveTimer = setTimeout(() => {
                // Silent autosave to avoid UI noise
                updateAutosaveStatus('saving');
                saveDiagram(true);
            }, autosaveDelay);
        }

        // ===== Autosave status indicator helper =====
        // States: 'hidden' | 'dirty' | 'pending' | 'saving' | 'saved' | 'error'
        function updateAutosaveStatus(state) {
            const el = document.getElementById('autosaveStatus');
            if (!el) return;
            const cls = ['hidden', 'dirty', 'pending', 'saving', 'saved', 'error'];
            cls.forEach(c => el.classList.remove(c));
            el.classList.add(state);
            switch (state) {
                case 'hidden':
                    el.textContent = '';
                    break;
                case 'dirty':
                    el.textContent = 'Unsaved changes';
                    break;
                case 'pending':
                    el.textContent = 'Auto-saving soon…';
                    break;
                case 'saving':
                    el.textContent = 'Saving…';
                    break;
                case 'saved':
                    el.textContent = 'Auto-saved';
                    // Fade back to hidden after a short delay
                    setTimeout(() => {
                        // Only hide if not dirty again
                        if (hasUnsavedChanges) return;
                        updateAutosaveStatus('hidden');
                    }, 2000);
                    break;
                case 'error':
                    el.textContent = 'Save failed';
                    break;
            }
        }

        // No special delete delay; deletes trigger an immediate forced save.

        // Serialize saves to avoid out-of-order overwrites on the server
        let _saveQueue = window._saveQueue || Promise.resolve();
        window._saveQueue = _saveQueue;

        async function _performSave(silent = false, force = false) {
            if (!currentDiagram) return;
            if (!hasUnsavedChanges && !force) return;

            try {
                if (!silent) showMessage('Saving diagram...', 'info');
                // Reflect saving state in navbar
                updateAutosaveStatus('saving');

                const payload = getDiagramForSave(currentDiagram);
                // Simple fingerprint for consistency check after re-fetch
                const expectedCounts = {
                    nodes: Array.isArray(payload.nodes) ? payload.nodes.length : 0,
                    edges: Array.isArray(payload.edges) ? payload.edges.length : 0
                };
                const response = await fetch(`http://localhost:3001/api/v1/diagrams/${currentDiagram.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                    // Ensure background saves outlive navigation (refresh/close)
                    keepalive: true
                });

                if (response.ok) {
                    hasUnsavedChanges = false;
                    const sb = document.getElementById('saveButton');
                    if (sb) sb.classList.remove('show');
                    if (!silent) showMessage('Diagram saved successfully!', 'success');
                    updateAutosaveStatus('saved');
                    // Track last save time for UI
                    lastSavedAt = new Date();
                    // Persist last-opened diagram id on successful save so reload restores this one
                    try { if (currentDiagram && currentDiagram.id) setLastOpenedDiagramId(currentDiagram.id); } catch (_) { }
                    if (!silent) {
                        // Re-fetch latest diagram from backend to reflect any canonicalization/normalization
                        try {
                            // Retry a couple of times to allow backend to fully persist before re-read
                            let attempts = 0;
                            let fresh = null;
                            while (attempts < 3) {
                                const res2 = await fetch(`http://localhost:3001/api/v1/diagrams/${currentDiagram.id}`);
                                if (res2.ok) {
                                    const d = await res2.json();
                                    const nn = Array.isArray(d.nodes) ? d.nodes.length : 0;
                                    const ee = Array.isArray(d.edges) ? d.edges.length : 0;
                                    if (nn === expectedCounts.nodes && ee === expectedCounts.edges) {
                                        fresh = d;
                                        break;
                                    }
                                }
                                // Small backoff before retrying
                                await new Promise(r => setTimeout(r, 200));
                                attempts++;
                            }
                            if (fresh) {
                                currentDiagram = normalizeDiagramNumbers(fresh);
                                renderFlowchart(currentDiagram);
                                updateConnections();
                            }
                            updateDiagramInfoBox();
                        } catch (_) {
                            updateDiagramInfoBox();
                        }
                        // If currently viewing Raw Data, keep YAML in sync after save
                        const isRawActive = document.getElementById('configurationTab')?.style.display === 'block';
                        if (isRawActive) {
                            try { await loadYamlConfig(); } catch (_) { }
                        }
                    } else {
                        // Silent saves: avoid re-fetch to prevent jitter; refresh summary only
                        updateDiagramInfoBox();
                        // If viewing Raw Data, refresh YAML so changes are visible immediately
                        const isRawActive = document.getElementById('configurationTab')?.style.display === 'block';
                        if (isRawActive) {
                            try { await loadYamlConfig(); } catch (_) { }
                        }
                    }
                } else {
                    updateAutosaveStatus('error');
                    const errText = await response.text().catch(() => '');
                    throw new Error(`Save failed: ${response.status} ${errText}`);
                }
            } catch (err) {
                console.error('Error saving diagram:', err);
                if (!silent) showMessage('Error saving diagram', 'danger');
                updateAutosaveStatus('error');
            } finally {
                try { clearTimeout(autosaveTimer); } catch (_) { }
                autosaveTimer = null;
            }
        }

        // Public save function: queue saves sequentially to avoid races
        function saveDiagram(silent = false, force = false) {
            const run = () => _performSave(silent, force);
            // Chain regardless of previous state to keep queue intact
            _saveQueue = _saveQueue.then(run, run);
            window._saveQueue = _saveQueue;
            return _saveQueue;
        }

        function showMessage(text, type) {
            // Create/reuse a bottom-right toast container
            let container = document.getElementById('toastContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toastContainer';
                Object.assign(container.style, {
                    position: 'fixed',
                    right: '20px',
                    bottom: '20px',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px',
                    zIndex: '1002',
                    maxWidth: '360px',
                    pointerEvents: 'none' // allow clicks to pass through except on toasts
                });
                document.body.appendChild(container);
            }

            const msg = document.createElement('div');
            msg.className = 'message';
            msg.textContent = text;
            Object.assign(msg.style, {
                padding: '10px 14px',
                borderRadius: '6px',
                color: '#fff',
                fontWeight: '600',
                fontSize: '13px',
                boxShadow: '0 6px 16px rgba(0,0,0,0.18)',
                maxWidth: '100%',
                pointerEvents: 'auto',
                opacity: '0',
                transform: 'translateY(6px)',
                transition: 'opacity 120ms ease, transform 160ms ease'
            });

            switch (type) {
                case 'success':
                    msg.style.background = '#27ae60';
                    break;
                case 'error':
                    msg.style.background = '#e74c3c';
                    break;
                case 'info':
                default:
                    msg.style.background = '#3498db';
            }

            container.appendChild(msg);
            // trigger transition
            requestAnimationFrame(() => {
                msg.style.opacity = '1';
                msg.style.transform = 'translateY(0)';
            });

            // Auto-remove after 3 seconds with fade-out
            setTimeout(() => {
                msg.style.opacity = '0';
                msg.style.transform = 'translateY(6px)';
                setTimeout(() => { if (msg.parentNode) msg.remove(); }, 180);
            }, 3000);
        }

        // Update the ribbon Diagram Info box with current diagram details
        function updateDiagramInfoBox() {
            const box = document.getElementById('diagramInfoBox');
            if (!box) return;
            const d = window.currentDiagram;
            if (!d) {
                box.innerHTML = '';
                return;
            }
            const name = d.name || 'Unnamed Diagram';
            const id = d.id ? ` <span style="color:#95a5a6;">(${d.id})</span>` : '';
            const nodes = Array.isArray(d.nodes) ? d.nodes.length : 0;
            const edges = Array.isArray(d.edges) ? d.edges.length : 0;
            const layout = (d.layout && d.layout.direction) ? d.layout.direction : 'top-bottom';
            const version = d.version ? `v${d.version}` : '';
            const filePath = d.FilePath || d.filePath || '';
            const baseName = filePath ? (filePath.split(/[\\/]/).pop() || '') : '';
            const savedText = lastSavedAt ? `<br/><span style='color:#16a34a;'>Last saved:</span> ${new Date(lastSavedAt).toLocaleTimeString()}` : '';
            box.innerHTML = `
                <div style="font-weight:600;font-size:13px;color:#2c3e50;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;" title="${name}${filePath ? ` — ${filePath}` : ''}">${name}${id} ${version ? `<span style='color:#95a5a6;'>${version}</span>` : ''}</div>
                <div style="font-size:12px;color:#2c3e50;">
                    <strong>Nodes:</strong> ${nodes} · <strong>Edges:</strong> ${edges}<br/>
                    <strong>Layout:</strong> ${layout}${baseName ? ` · <span title='${filePath}'>${baseName}</span>` : ''}
                    ${savedText}
                </div>
            `;
        }

        // ======= Right-side Info Panel (hover details) =======
        let hoveredNodeEl = null;
        function setInfoPanelBody(html) {
            const body = document.getElementById('infoPanelBody');
            if (body) body.innerHTML = html;
        }
        function setInfoPanelHeader(title) {
            const header = document.getElementById('infoPanelHeader');
            if (!header) return;
            const hasTitle = !!(title && String(title).trim());
            header.textContent = hasTitle ? String(title) : '';
            header.classList.toggle('d-none', !hasTitle);
        }
        // Dock the Defaults UI into the right panel and slide it open
        function dockDefaultsPanel() {
            // Undock any existing editors
            try { closeNodeEditor(); } catch (_) { try { undockNodeEditor(); } catch (_) { } }
            try { closeEdgeEditor(); } catch (_) { try { undockEdgeEditor(); } catch (_) { } }
            const panelBody = document.getElementById('infoPanelBody');
            if (!panelBody) return;
            // Render defaults content into the body and mark as docked/open
            renderDefaultsPanel(true /*docked*/);
            editorDocked = true;
            setInfoPanelHeader('Edit Defaults');
            applyInfoPanelState();
        }
        function undockDefaultsPanel() {
            const body = document.getElementById('infoPanelBody');
            if (!body) return;
            body.innerHTML = '';
            editorDocked = false;
            applyInfoPanelState();
            renderDiagramSummaryInPanel();
            setInfoPanelHeader('');
        }
        function renderDiagramSummaryInPanel() {
            const d = window.currentDiagram;
            if (!d) { setInfoPanelHeader('', ''); setInfoPanelBody(''); return; }
            const name = d.name || 'Unnamed Diagram';
            const id = d.id || '';
            const nodes = Array.isArray(d.nodes) ? d.nodes.length : 0;
            const edges = Array.isArray(d.edges) ? d.edges.length : 0;
            const layout = (d.layout && d.layout.direction) ? d.layout.direction : 'top-bottom';
            setInfoPanelHeader('');
            setInfoPanelBody('');
        }
        function clearInfoPanelBody() {
            setInfoPanelHeader(''); setInfoPanelBody('');
        }
        function dockNodeEditor() {
            // If edge editor is currently docked, undock it first
            try { undockEdgeEditor(); } catch (_) { }
            const panelBody = document.getElementById('infoPanelBody');
            const editor = document.getElementById('nodeEditor');
            if (!panelBody || !editor) return;
            // Replace panel content with the editor element
            panelBody.innerHTML = '';
            panelBody.appendChild(editor);
            editor.classList.add('docked');
            // Move editor buttons to panel footer for proper card layout
            const footerHost = document.getElementById('infoPanelFooter');
            const btns = editor.querySelector('.editor-buttons');
            if (footerHost) {
                if (btns) {
                    footerHost.replaceChildren(btns);
                } else {
                    // Fallback: create delete button if .editor-buttons is missing
                    footerHost.innerHTML = '<button class="btn btn-danger" onclick="confirmDeleteCurrentNode()">Delete</button>';
                }
                footerHost.classList.remove('d-none');
            }
            editorDocked = true;
            // Header should reflect node editing
            setInfoPanelHeader('Edit Node');
            applyInfoPanelState();
            // Add a small editing badge to the title for visibility
            try {
                const titleEl = document.getElementById('infoTitle');
                if (titleEl && !titleEl.querySelector('[data-role="editing-badge"]')) {
                    const badge = document.createElement('span');
                    badge.className = 'badge bg-success ms-2';
                    badge.setAttribute('data-role', 'editing-badge');
                    badge.textContent = 'Editing';
                    titleEl.appendChild(badge);
                }
            } catch (_) { }
            // Accordion removed; no persistence needed
        }
        function undockNodeEditor() {
            const editor = document.getElementById('nodeEditor');
            if (!editor) return;
            editor.classList.remove('docked');
            // Ensure editor is hidden when undocked to avoid centered modal appearance
            editor.style.display = 'none';
            editorDocked = false;
            applyInfoPanelState();
            // Nothing to cleanup for Bootstrap Accordion
            // Move the editor back to the root (right before closing body) to keep DOM tidy
            const appRoot = document.querySelector('#infoPanel')?.parentElement || document.body;
            appRoot.appendChild(editor);
            // Clear panel footer content and hide it
            const footerHost = document.getElementById('infoPanelFooter');
            if (footerHost) {
                // If the footer currently holds the node editor buttons, move them back into the editor
                const nodeBtns = footerHost.querySelector('.editor-buttons');
                if (nodeBtns) {
                    editor.appendChild(nodeBtns);
                }
                footerHost.replaceChildren();
                footerHost.classList.add('d-none');
            }
            setInfoPanelHeader('');
        }

        // Edge editor docking into Info Panel
        function dockEdgeEditor() {
            // If node editor is currently docked, undock it first
            try { undockNodeEditor(); } catch (_) { }
            const panelBody = document.getElementById('infoPanelBody');
            const editor = document.getElementById('edgeEditor');
            if (!panelBody || !editor) return;
            panelBody.innerHTML = '';
            panelBody.appendChild(editor);
            editor.classList.add('docked');
            // Move editor buttons to panel footer for proper card layout
            const footerHost = document.getElementById('infoPanelFooter');
            const btns = editor.querySelector('.editor-buttons');
            if (footerHost && btns) {
                footerHost.replaceChildren(btns);
                footerHost.classList.remove('d-none');
            }
            editorDocked = true;
            // Header should reflect connector editing
            setInfoPanelHeader('Edit Connector');
            applyInfoPanelState();
            // Add Editing badge
            try {
                const titleEl = document.getElementById('infoTitle');
                if (titleEl && !titleEl.querySelector('[data-role="editing-badge"]')) {
                    const badge = document.createElement('span');
                    badge.className = 'badge bg-success ms-2';
                    badge.setAttribute('data-role', 'editing-badge');
                    badge.textContent = 'Editing';
                    titleEl.appendChild(badge);
                }
            } catch (_) { }
        }
        function undockEdgeEditor() {
            const editor = document.getElementById('edgeEditor');
            if (!editor) return;
            editor.classList.remove('docked');
            // Ensure editor is hidden when undocked to avoid centered modal appearance
            editor.style.display = 'none';
            editorDocked = false;
            applyInfoPanelState();
            const appRoot = document.querySelector('#infoPanel')?.parentElement || document.body;
            appRoot.appendChild(editor);
            // Clear panel footer content and hide it
            const footerHost = document.getElementById('infoPanelFooter');
            if (footerHost) {
                // If the footer currently holds the edge editor buttons, move them back into the editor
                const edgeBtns = footerHost.querySelector('.editor-buttons');
                if (edgeBtns) {
                    editor.appendChild(edgeBtns);
                }
                footerHost.replaceChildren();
                footerHost.classList.add('d-none');
            }
            setInfoPanelHeader('');
        }

        // Accordion removed; no persistence or related helpers required.

        // Legacy manual docked headings removed; Bootstrap Accordion is used directly.
        function computeConnectionPointCenter(cpEl) {
            const display = document.getElementById('flowchartDisplay');
            if (!display || !cpEl) return { x: 0, y: 0 };
            const displayRect = display.getBoundingClientRect();
            const rect = cpEl.getBoundingClientRect();
            // Convert viewport-relative center into content coordinates by adding scroll offset
            const cx = (((rect.left + rect.width / 2) - displayRect.left) + display.scrollLeft) / zoomScale;
            const cy = (((rect.top + rect.height / 2) - displayRect.top) + display.scrollTop) / zoomScale;
            return { x: Math.round(cx), y: Math.round(cy) };
        }
        function updateInfoPanelForNode(nodeEl) {
            // Hover-driven info panel is disabled; no-op to prevent hover content
            return;
        }

        // ============ GRID AND LAYOUT FUNCTIONS ============

        // Edge selection helpers
        function clearEdgeSelection() {
            selectedEdgeId = null;
            document.querySelectorAll('.connection-line.selected, .connection-arrowhead.selected, .connection-label-bg.selected')
                .forEach(el => el.classList.remove('selected'));
        }

        function selectEdge(edgeId) {
            clearEdgeSelection();
            selectedEdgeId = edgeId;
            const display = document.getElementById('flowchartDisplay');
            const line = display.querySelector(`line.connection-line[data-edge-id="${edgeId}"]`);
            const arrow = display.querySelector(`polygon.connection-arrowhead[data-edge-id="${edgeId}"]`);
            const bg = display.querySelector(`rect.connection-label-bg[data-edge-id="${edgeId}"]`);
            if (line) line.classList.add('selected');
            if (arrow) arrow.classList.add('selected');
            if (bg) bg.classList.add('selected');
        }

        async function deleteSelectedEdge() {
            if (!selectedEdgeId || !currentDiagram?.edges) return;
            const idx = currentDiagram.edges.findIndex(e => (e.id || `${e.from}-${e.to}`) === selectedEdgeId);
            if (idx >= 0) {
                currentDiagram.edges.splice(idx, 1);
                clearEdgeSelection();
                updateConnections();
                hasUnsavedChanges = true;
                document.getElementById('saveButton').classList.add('show');
                // Cancel any pending autosave and persist immediately
                try { clearTimeout(autosaveTimer); } catch (_) { }
                updateAutosaveStatus('saving');
                await saveDiagram(false, true);
                showMessage('Connector removed', 'success');
                updateDiagramInfoBox();
            }
        }

        function createEdgeEditorElement() {
            // Create the edgeEditor element if it doesn't exist
            if (document.getElementById('edgeEditor')) return; // Already exists

            const editorHtml = `
                <div id="edgeEditor" class="node-editor" style="display:none;">
                    <div class="editor-content">
                        <div class="editor-group">
                            <label for="edgeName">Label:</label>
                            <input type="text" id="edgeName" placeholder="e.g. calls, publishes" />
                        </div>
                        <div class="compact-row">
                            <div class="editor-group">
                                <label for="edgeTechnology">Technology:</label>
                                <select id="edgeTechnology">
                                    <option value="">— None —</option>
                                    <option value="rest">REST</option>
                                    <option value="ws">WebSocket</option>
                                    <option value="grpc">gRPC</option>
                                </select>
                            </div>
                            <div class="editor-group">
                                <label for="edgeWidth">Width (px):</label>
                                <input type="number" id="edgeWidth" min="1" max="10" step="1" value="2" />
                            </div>
                        </div>
                        <div class="compact-row">
                            <div class="editor-group">
                                <label for="edgeStroke">Stroke Color:</label>
                                <input type="color" id="edgeStroke" value="#34495e" />
                            </div>
                            <div class="editor-group">
                                <label for="edgeDash">Line Style:</label>
                                <select id="edgeDash">
                                    <option value="solid">Solid</option>
                                    <option value="dotted">Dotted</option>
                                    <option value="dashed">Dashed</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="editor-buttons">
                        <button class="btn btn-danger" onclick="deleteEdgeFromEditor()">Delete</button>
                    </div>
                </div>
            `;

            // Insert the editor element into the document body
            document.body.insertAdjacentHTML('beforeend', editorHtml);
        }

        function openEdgeEditor(edgeId) {
            // Close any existing edge editor first
            closeEdgeEditor();
            const edge = currentDiagram?.edges?.find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
            if (!edge) return;
            let modal = document.getElementById('edgeEditor');
            if (!modal) {
                console.warn('edgeEditor element not found, recreating it');
                // Recreate the edgeEditor element
                createEdgeEditorElement();
                modal = document.getElementById('edgeEditor');
                if (!modal) {
                    console.error('Could not recreate edgeEditor element');
                    return;
                }
            }
            modal.dataset.edgeId = edgeId;
            const edgeName = document.getElementById('edgeName');
            if (edgeName) edgeName.value = edge.name || '';
            const meta = edge.metadata || {};
            const edgeTechnology = document.getElementById('edgeTechnology');
            if (edgeTechnology) edgeTechnology.value = meta.technology || '';

            const style = edge.style || {};
            const edgeStroke = document.getElementById('edgeStroke');
            if (edgeStroke) edgeStroke.value = style.stroke || '#34495e';
            const edgeWidth = document.getElementById('edgeWidth');
            if (edgeWidth) edgeWidth.value = style.strokeWidth || 2;
            const edgeDash = document.getElementById('edgeDash');
            if (edgeDash) edgeDash.value = dashArrayToName(style.strokeDasharray || '');
            // Ensure panel is open
            const panel = document.getElementById('infoPanel');
            if (panel) panel.classList.add('temp-open');
            applyInfoPanelState();
            // Dock inside Info Panel
            dockEdgeEditor();
            if (modal) modal.style.display = 'block';

            // Live preview bindings: reflect changes immediately in the diagram
            try {
                const nameEl = document.getElementById('edgeName');
                const techEl = document.getElementById('edgeTechnology');
                const strokeEl = document.getElementById('edgeStroke');
                const widthEl = document.getElementById('edgeWidth');
                const dashEl = document.getElementById('edgeDash');

                let liveTimer = null;
                const applyLive = () => {
                    const id = modal.dataset.edgeId;
                    const e = currentDiagram?.edges?.find(x => (x.id || `${x.from}-${x.to}`) === id);
                    if (!e) return;
                    // Update fields on the edge
                    e.name = nameEl?.value || '';
                    e.metadata = e.metadata || {};
                    if (techEl) e.metadata.technology = techEl.value || undefined;
                    e.style = e.style || {};
                    if (strokeEl) e.style.stroke = strokeEl.value || '#34495e';
                    if (widthEl) {
                        const w = parseFloat(widthEl.value);
                        e.style.strokeWidth = isNaN(w) ? 2 : w;
                    }
                    if (dashEl) {
                        const name = (dashEl.value || 'solid');
                        const dash = dashNameToArray(name);
                        if (dash) e.style.strokeDasharray = dash; else delete e.style.strokeDasharray;
                    }
                    // Mark dirty, update visuals, and let autosave handle persistence
                    hasUnsavedChanges = true;
                    const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                    updateConnections();
                    // Debounce autosave to avoid saving on every keystroke
                    if (liveTimer) clearTimeout(liveTimer);
                    updateAutosaveStatus('pending');
                    liveTimer = setTimeout(() => {
                        updateAutosaveStatus('saving');
                        saveDiagram(true);
                        liveTimer = null;
                    }, 600);
                };

                const bind = (el, evts) => {
                    if (!el || el._liveBound) return;
                    evts.forEach(evt => el.addEventListener(evt, applyLive));
                    el._liveBound = true;
                };
                bind(nameEl, ['input', 'change']);
                bind(techEl, ['input', 'change']);
                bind(strokeEl, ['input', 'change']);
                bind(widthEl, ['input', 'change']);
                bind(dashEl, ['input', 'change']);
            } catch (_) { /* non-fatal */ }
        }

        function closeEdgeEditor() {
            const modal = document.getElementById('edgeEditor');
            if (!modal) return; // Guard against missing element
            modal.style.display = 'none';
            modal.dataset.edgeId = '';
            // Undock and restore panel
            undockEdgeEditor();
            renderDiagramSummaryInPanel();
            // Remove editing badge if present
            try {
                const titleEl = document.getElementById('infoTitle');
                titleEl?.querySelector('[data-role="editing-badge"]')?.remove();
            } catch (_) { }
            // Keep panel open (always-locked)
            setInfoPanelHeader('');
        }

        async function saveEdgeChanges() {
            const modal = document.getElementById('edgeEditor');
            const edgeId = modal.dataset.edgeId;
            const edge = currentDiagram?.edges?.find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
            if (!edge) return;
            edge.name = document.getElementById('edgeName').value;
            edge.metadata = edge.metadata || {};
            edge.metadata.technology = document.getElementById('edgeTechnology').value || undefined;

            edge.style = edge.style || {};
            edge.style.stroke = document.getElementById('edgeStroke').value || '#34495e';
            const w = parseFloat(document.getElementById('edgeWidth').value);
            edge.style.strokeWidth = isNaN(w) ? 2 : w;
            const dashName = (document.getElementById('edgeDash').value || 'solid');
            edge.style.strokeDasharray = dashNameToArray(dashName) || undefined;
            hasUnsavedChanges = true;
            const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
            scheduleAutoSave();
            // Immediate forced silent autosave for editor-based edge updates
            await saveDiagram(true, true);
            closeEdgeEditor();
            updateConnections();
            showMessage('Connector updated', 'success');
        }

        function deleteEdgeFromEditor() {
            const modal = document.getElementById('edgeEditor');
            const edgeId = modal.dataset.edgeId;
            closeEdgeEditor();
            selectedEdgeId = edgeId;
            deleteSelectedEdge();
        }

        // ===== Bulk connector operations =====
        function selectAllConnectors() {
            // Ensure connections are drawn
            try { updateConnections(); } catch (_) { }
            // Clear single-edge selection state
            selectedEdgeId = null;
            // Select all line segments, arrowheads, and label backgrounds
            const display = document.getElementById('flowchartDisplay');
            if (!display) return;
            display.querySelectorAll('line.connection-line, polygon.connection-arrowhead, rect.connection-label-bg')
                .forEach(el => el.classList.add('selected'));
            showMessage('All connectors selected', 'info');
        }

        function openBulkEdgeEditorModal() {
            // Only allow open when explicitly triggered via nav/menu click
            if (!bulkOpenIntent) { return; }
            bulkOpenIntent = false;
            if (!currentDiagram || !Array.isArray(currentDiagram.edges) || currentDiagram.edges.length === 0) {
                showMessage('No connectors to format', 'info');
                return;
            }
            // Visually select all connectors before opening the modal for clear context
            try { selectAllConnectors(); } catch (_) { }
            // Prefill with first edge style as a convenience
            const e0 = currentDiagram.edges[0] || {};
            const s0 = (e0.style || {});
            const stroke = s0.stroke || '#34495e';
            const width = (typeof s0.strokeWidth === 'number' && s0.strokeWidth > 0) ? s0.strokeWidth : 2;
            const dash = dashArrayToName(s0.strokeDasharray || '');
            const strokeEl = document.getElementById('bulkEdgeStroke');
            const widthEl = document.getElementById('bulkEdgeWidth');
            const dashEl = document.getElementById('bulkEdgeDash');
            if (strokeEl) strokeEl.value = stroke;
            if (widthEl) widthEl.value = width;
            if (dashEl) dashEl.value = dash;
            const modal = document.getElementById('bulkEdgeEditorModal');
            if (modal) modal.style.display = 'flex';
        }

        function closeBulkEdgeEditorModal() {
            const modal = document.getElementById('bulkEdgeEditorModal');
            if (modal) modal.style.display = 'none';
        }

        function applyBulkEdgeFormatting() {
            if (!currentDiagram || !Array.isArray(currentDiagram.edges) || currentDiagram.edges.length === 0) {
                showMessage('No connectors to format', 'info');
                closeBulkEdgeEditorModal();
                return;
            }
            const strokeEl = document.getElementById('bulkEdgeStroke');
            const widthEl = document.getElementById('bulkEdgeWidth');
            const dashEl = document.getElementById('bulkEdgeDash');
            const stroke = (strokeEl && strokeEl.value) ? strokeEl.value : '#34495e';
            const widthV = widthEl ? parseFloat(widthEl.value) : 2;
            const width = isNaN(widthV) ? 2 : Math.max(1, Math.min(20, widthV));
            const dashName = (dashEl && dashEl.value) || 'solid';
            const dash = dashNameToArray(dashName) || '';

            currentDiagram.edges.forEach(e => {
                e.style = e.style || {};
                e.style.stroke = stroke;
                e.style.strokeWidth = width;
                if (dash) e.style.strokeDasharray = dash; else delete e.style.strokeDasharray;
            });

            hasUnsavedChanges = true;
            const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
            scheduleAutoSave();
            // Silent immediate save and redraw
            saveDiagram(true);
            updateConnections();
            updateDiagramInfoBox();
            closeBulkEdgeEditorModal();
            showMessage('Applied formatting to all connectors', 'success');
        }

        // Edge creation interactions
        function startEdgeCreation(connectionPointEl, clientX, clientY) {
            if (!editMode) return;
            const nodeEl = connectionPointEl.closest('.node');
            if (!nodeEl) return;
            const nodeId = nodeEl.dataset.nodeId;
            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();
            const ptRect = connectionPointEl.getBoundingClientRect();
            // Include container scroll when converting to stage/content coordinates
            const startX = (((ptRect.left + ptRect.width / 2) - displayRect.left) + displayEl.scrollLeft) / zoomScale;
            const startY = (((ptRect.top + ptRect.height / 2) - displayRect.top) + displayEl.scrollTop) / zoomScale;
            // Ensure a connections SVG exists (create if missing)
            const stage = document.getElementById('diagramStage') || document.getElementById('flowchartDisplay');
            let svg = stage.querySelector('svg.connections-layer');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.className = 'connections-layer';
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.zIndex = '1';
                svg.style.pointerEvents = 'auto';
                stage.appendChild(svg);
                const edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                edgesGroup.setAttribute('class', 'edges-layer');
                svg.appendChild(edgesGroup);
            }
            const preview = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            preview.setAttribute('x1', startX);
            preview.setAttribute('y1', startY);
            preview.setAttribute('x2', startX);
            preview.setAttribute('y2', startY);
            preview.setAttribute('stroke', '#7f8c8d');
            preview.setAttribute('stroke-width', '2');
            preview.setAttribute('stroke-dasharray', '4,2');
            preview.setAttribute('class', 'connection-preview');
            // Important: don't block pointer events so drops register on nodes/points beneath
            preview.style.pointerEvents = 'none';
            svg.appendChild(preview);
            // Temporarily disable pointer events on the whole SVG during drag so hit-testing finds nodes beneath
            const prevPointerEvents = svg.style.pointerEvents;
            svg.style.pointerEvents = 'none';
            edgeCreation = {
                sourceNodeId: nodeId,
                sourceSide: connectionPointEl.dataset.side,
                startX, startY,
                previewLine: preview,
                svgEl: svg,
                prevPointerEvents
            };
            // Global listeners for drag
            document.addEventListener('mousemove', handleMouseMove, { passive: false });
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
        }

        function updateEdgeCreationPreview(clientX, clientY) {
            if (!edgeCreation) return;
            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();
            // Include scroll offsets to align with content coordinates
            const x2 = ((clientX - displayRect.left) + displayEl.scrollLeft) / zoomScale;
            const y2 = ((clientY - displayRect.top) + displayEl.scrollTop) / zoomScale;
            const line = edgeCreation.previewLine;
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);

            // Highlight potential drop target under cursor
            const stack = (document.elementsFromPoint ? document.elementsFromPoint(clientX, clientY) : [document.elementFromPoint(clientX, clientY)]).filter(Boolean);
            // Clear previous highlight
            document.querySelectorAll('#flowchartDisplay .node.drop-target').forEach(n => n.classList.remove('drop-target'));
            let targetNode = null;
            for (const el of stack) {
                // Skip overlays
                if (el.matches && (el.matches('svg.connections-layer') || el.matches('svg.grid-overlay'))) continue;
                const cp = el.closest && el.closest('.connection-point');
                if (cp && cp.closest) { targetNode = cp.closest('.node'); }
                if (!targetNode && el.closest) targetNode = el.closest('.node');
                if (targetNode) break;
            }
            if (targetNode) targetNode.classList.add('drop-target');
        }

        function cancelEdgeCreation() {
            if (!edgeCreation) return;
            try { edgeCreation.previewLine?.remove(); } catch (_) { }
            // Restore SVG pointer events if we changed them
            try { if (edgeCreation.svgEl) edgeCreation.svgEl.style.pointerEvents = edgeCreation.prevPointerEvents || 'auto'; } catch (_) { }
            edgeCreation = null;
            // Clear any target highlight
            document.querySelectorAll('#flowchartDisplay .node.drop-target').forEach(n => n.classList.remove('drop-target'));
            // Remove global listeners added during drag
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
        }

        async function finishEdgeCreation(eventLike) {
            if (!edgeCreation) return;
            // Determine if the end is over a valid connection point of another node
            const stack = (document.elementsFromPoint ? document.elementsFromPoint(eventLike.clientX, eventLike.clientY) : [document.elementFromPoint(eventLike.clientX, eventLike.clientY)]).filter(Boolean);
            // Accept either a connection point or any part of a node for the drop
            let targetNodeEl = null;
            for (const el of stack) {
                if (el.matches && (el.matches('svg.connections-layer') || el.matches('svg.grid-overlay'))) continue;
                const cp = el.closest && el.closest('.connection-point');
                if (cp && cp.closest) targetNodeEl = cp.closest('.node');
                if (!targetNodeEl && el.closest) targetNodeEl = el.closest('.node');
                if (targetNodeEl) break;
            }
            const targetNodeId = targetNodeEl ? targetNodeEl.dataset.nodeId : null;
            const sourceNodeId = edgeCreation.sourceNodeId;
            // Remove preview
            cancelEdgeCreation();
            // Ensure highlight cleared
            document.querySelectorAll('#flowchartDisplay .node.drop-target').forEach(n => n.classList.remove('drop-target'));
            if (!targetNodeId || targetNodeId === sourceNodeId) return;
            // Create new edge
            currentDiagram.edges = currentDiagram.edges || [];
            const newEdge = {
                id: `${sourceNodeId}-${targetNodeId}-${Date.now()}`,
                from: sourceNodeId,
                to: targetNodeId,
                name: '',
                style: { stroke: '#34495e', strokeWidth: 2 },
                metadata: {}
            };
            currentDiagram.edges.push(newEdge);
            hasUnsavedChanges = true;
            const sbAdd = document.getElementById('saveButton'); if (sbAdd) sbAdd.classList.add('show');
            scheduleAutoSave();
            // Immediate autosave on connector add (drag-connect)
            await saveDiagram(true, true);
            updateConnections();
            updateDiagramInfoBox();
            // Optionally open editor
            openEdgeEditor(newEdge.id);
        }

        // === Resize handles ===
        function addResizeHandles(nodeEl, node) {
            // Remove existing handles/edges to avoid duplicates
            nodeEl.querySelectorAll('.resize-handle, .resize-edge').forEach(h => h.remove());
            const typesSquare = new Set(['decision', 'start', 'end', 'connector']);

            function makeHandle(cls) {
                const h = document.createElement('div');
                h.className = `resize-handle ${cls}`;
                nodeEl.appendChild(h);
                return h;
            }

            function makeEdge(cls) {
                const e = document.createElement('div');
                e.className = `resize-edge ${cls}`;
                nodeEl.appendChild(e);
                return e;
            }

            // Decide which handles to show to avoid overlapping with connection points
            // Rule:
            //  - Decision (diamond): connection points sit on corners → hide corner handle (SE), show side handles (E, S)
            //  - Others (rectangles, circles, hexagon, etc.): connection points sit on side midpoints → hide side handles (E, S), show corner handle (SE)
            const isDecision = node?.type === 'decision';
            const showE = !!isDecision;
            const showS = !!isDecision;
            const showSE = !isDecision; // only show corner for non-diamond shapes

            const created = [];
            if (showE) created.push(makeHandle('resize-e'));
            if (showS) created.push(makeHandle('resize-s'));
            if (showSE) created.push(makeHandle('resize-se'));
            // Full-length hover/click areas for intuitive resizing near sides (only when showing that side)
            if (showE) created.push(makeEdge('e'));
            if (showS) created.push(makeEdge('s'));

            const displayRect = () => document.getElementById('flowchartDisplay').getBoundingClientRect();

            function startResize(e, dir) {
                if (!editMode) return;
                e.preventDefault(); e.stopPropagation();
                // Prevent hover scale and bring node to a stable state during resize
                nodeEl.classList.add('resizing');
                // No autosave while resizing (only on release)
                let resizeSaveTimer = null;
                const rect = nodeEl.getBoundingClientRect();
                const startX = ('clientX' in e) ? e.clientX : e.touches[0].clientX;
                const startY = ('clientY' in e) ? e.clientY : e.touches[0].clientY;
                const startW = rect.width;
                const startH = rect.height;
                const isSquare = typesSquare.has(node.type);

                function onMove(ev) {
                    const cx = ('clientX' in ev) ? ev.clientX : ev.touches[0].clientX;
                    const cy = ('clientY' in ev) ? ev.clientY : ev.touches[0].clientY;
                    const z = (zoomScale || 1);
                    const minW = 40; // minimum width for usability
                    const minH = 30; // minimum height for usability
                    const deadzone = 0.5; // px tolerance to avoid accidental jumps

                    // Deltas in element space
                    let dW = dir.includes('e') ? (cx - startX) / z : 0;
                    let dH = dir.includes('s') ? (cy - startY) / z : 0;
                    if (Math.abs(dW) < deadzone) dW = 0;
                    if (Math.abs(dH) < deadzone) dH = 0;

                    // Raw sizes before snapping
                    const rawW = startW + dW;
                    const rawH = startH + dH;

                    let newW = dir.includes('e') ? Math.max(minW, rawW) : startW;
                    let newH = dir.includes('s') ? Math.max(minH, rawH) : startH;

                    if (isSquare) {
                        // Base size on dragged axis to allow shrinking
                        const minSize = Math.max(minW, minH);
                        const startSize = Math.max(startW, startH);
                        let rawSize = (dir === 'e') ? rawW : (dir === 's') ? rawH : Math.max(rawW, rawH);
                        let dSize = rawSize - startSize;
                        if (snapToGrid) {
                            const gs = Math.max(5, gridSize);
                            if (dSize > 0) rawSize = Math.ceil(rawSize / gs) * gs; // growing → snap up
                            else if (dSize < 0) rawSize = Math.floor(rawSize / gs) * gs; // shrinking → snap down
                            else rawSize = Math.round(rawSize / gs) * gs; // no movement → nearest
                        }
                        const size = Math.max(minSize, rawSize);
                        newW = size;
                        newH = size;
                    } else if (snapToGrid) {
                        // Non-square: snap each axis based on movement direction to avoid immediate grow
                        const gs = Math.max(5, gridSize);
                        if (dir.includes('e')) {
                            const delta = rawW - startW;
                            if (delta > 0) newW = Math.ceil(rawW / gs) * gs; // growing → snap up
                            else if (delta < 0) newW = Math.floor(rawW / gs) * gs; // shrinking → snap down
                            else newW = Math.round(rawW / gs) * gs;
                            newW = Math.max(minW, newW);
                        }
                        if (dir.includes('s')) {
                            const delta = rawH - startH;
                            if (delta > 0) newH = Math.ceil(rawH / gs) * gs;
                            else if (delta < 0) newH = Math.floor(rawH / gs) * gs;
                            else newH = Math.round(rawH / gs) * gs;
                            newH = Math.max(minH, newH);
                        }
                    }

                    nodeEl.style.width = `${newW}px`;
                    nodeEl.style.height = `${newH}px`;
                    // Update connections live
                    updateConnections();

                    // Persist live size to model so mid-drag autosaves reflect current dimensions
                    const n = (currentDiagram?.nodes || []).find(n0 => n0.id === nodeEl.dataset.nodeId);
                    if (n) {
                        n.dimensions = n.dimensions || { width: Math.round(newW), height: Math.round(newH) };
                        n.dimensions.width = Math.round(newW);
                        n.dimensions.height = Math.round(newH);
                        n.manualSize = true;
                    }
                    hasUnsavedChanges = true;
                }
                function onUp(ev) {
                    // Exit resizing state
                    nodeEl.classList.remove('resizing');
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                    window.removeEventListener('touchmove', onMove);
                    window.removeEventListener('touchend', onUp);
                    if (resizeSaveTimer) { try { clearTimeout(resizeSaveTimer); } catch (_) { } resizeSaveTimer = null; }
                    // Persist size back to diagram
                    const w = nodeEl.offsetWidth;
                    const h = nodeEl.offsetHeight;
                    const n = (currentDiagram?.nodes || []).find(n0 => n0.id === nodeEl.dataset.nodeId);
                    if (n) {
                        n.dimensions = n.dimensions || { width: w, height: h };
                        n.dimensions.width = w;
                        n.dimensions.height = h;
                        // For decision (diamond) and circles, record manualSize to prevent auto-resize overrides
                        n.manualSize = true;
                    }
                    hasUnsavedChanges = true;
                    const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                    scheduleAutoSave();
                    // Immediate silent autosave for size changes
                    saveDiagram(true);
                }
                window.addEventListener('mousemove', onMove, { passive: false });
                window.addEventListener('mouseup', onUp);
                window.addEventListener('touchmove', onMove, { passive: false });
                window.addEventListener('touchend', onUp);
            }

            created.forEach((h) => {
                const dir = h.classList.contains('resize-se') ? 'se'
                    : (h.classList.contains('resize-e') || h.classList.contains('e')) ? 'e'
                        : (h.classList.contains('resize-s') || h.classList.contains('s')) ? 's'
                            : 'se';
                h.addEventListener('mousedown', (e) => startResize(e, dir));
                h.addEventListener('touchstart', (e) => startResize(e, dir), { passive: false });
            });
        }

        function toggleGrid() {
            // Prevent disabling grid while in edit mode
            if (editMode && gridEnabled) {
                showMessage('Grid stays ON while editing', 'info');
                return;
            }
            gridEnabled = !gridEnabled;
            if (gridEnabled) {
                showGrid();
            } else {
                hideGrid();
            }
            // Keep snapping aligned with grid visibility
            snapToGrid = gridEnabled;
            updateGridSettings();
            // Persist setting
            appSettings.gridEnabled = gridEnabled;
            appSettings.snapToGrid = snapToGrid;
            saveAppSettingsSilent();
        }

        // Keep grid/snap settings in sync and reapply grid if needed
        function updateGridSettings() {
            // Ensure snap matches grid state
            snapToGrid = gridEnabled;
            // If grid should be visible but missing (e.g., after re-render), recreate it
            const hasGrid = !!document.querySelector('#flowchartDisplay svg.grid-overlay');
            if (gridEnabled && !hasGrid) {
                showGrid();
            }
            if (!gridEnabled && hasGrid) {
                hideGrid();
            }
        }

        function showGrid() {
            const container = document.getElementById('diagramStage') || document.getElementById('flowchartDisplay');

            // Remove existing grid
            if (gridSvg) {
                gridSvg.remove();
            }

            // Create grid SVG
            gridSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            gridSvg.className = 'grid-overlay';
            gridSvg.style.position = 'absolute';
            gridSvg.style.top = '0';
            gridSvg.style.left = '0';
            gridSvg.style.width = '100%';
            gridSvg.style.height = '100%';
            gridSvg.style.pointerEvents = 'none';
            gridSvg.style.zIndex = '1';

            // Create grid pattern
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.id = 'grid-pattern';
            pattern.setAttribute('width', gridSize);
            pattern.setAttribute('height', gridSize);
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${gridSize} 0 L 0 0 0 ${gridSize}`);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', gridColor || '#bdc3c7');
            path.setAttribute('stroke-width', '1');
            path.setAttribute('opacity', String(gridOpacity ?? 0.3));

            pattern.appendChild(path);
            defs.appendChild(pattern);
            gridSvg.appendChild(defs);

            // Create grid rectangle
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '100%');
            rect.setAttribute('height', '100%');
            rect.setAttribute('fill', 'url(#grid-pattern)');

            gridSvg.appendChild(rect);
            container.appendChild(gridSvg);
        }

        function hideGrid() {
            if (gridSvg) {
                gridSvg.remove();
                gridSvg = null;
            }
        }

        function snapToGridPosition(x, y) {
            if (!snapToGrid) return { x, y };

            const snappedX = Math.round(x / gridSize) * gridSize;
            const snappedY = Math.round(y / gridSize) * gridSize;

            return { x: snappedX, y: snappedY };
        }

        // Snap a node based on its type; diamonds snap by center
        function snapNodePosition(nodeEl, x, y, useTolerance = false) {
            if (!snapToGrid || !nodeEl) return { x, y };
            const nodeId = nodeEl.dataset.nodeId;
            const node = currentDiagram?.nodes?.find(n => n.id === nodeId);
            const type = node?.type || 'process';
            const width = nodeEl.offsetWidth;
            const height = nodeEl.offsetHeight;
            const tolerance = useTolerance ? 5 : 0;

            if (type === 'decision') {
                // Snap diamond center to the grid
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const gridCX = Math.round(centerX / gridSize) * gridSize;
                const gridCY = Math.round(centerY / gridSize) * gridSize;
                const snappedCX = Math.abs(centerX - gridCX) < tolerance ? gridCX : centerX;
                const snappedCY = Math.abs(centerY - gridCY) < tolerance ? gridCY : centerY;
                return {
                    x: Math.round(snappedCX - width / 2),
                    y: Math.round(snappedCY - height / 2),
                };
            }

            // Default: snap top-left corner
            const gridX = Math.round(x / gridSize) * gridSize;
            const gridY = Math.round(y / gridSize) * gridSize;
            return {
                x: Math.abs(x - gridX) < tolerance ? gridX : x,
                y: Math.abs(y - gridY) < tolerance ? gridY : y,
            };
        }

        function openNodeEditor(node, nodeElement) {
            editingNode = node;
            editingNodeElement = nodeElement;

            // Auto-open panel if in auto mode and currently collapsed
            const panel = document.getElementById('infoPanel');
            if (panel && panel.classList.contains('collapsed')) {
                if ((appSettings.infoPanelMode || 'auto') === 'auto') {
                    panel.classList.add('temp-open');
                }
                applyInfoPanelState();
                if ((appSettings.infoPanelMode || 'auto') === 'auto') panel.dataset.autoOpened = 'true';
            }

            // Ensure editor is docked inside the Info Panel
            dockNodeEditor();

            // Populate form with current values (name edited inline, so no field)
            document.getElementById('nodeType').value = node.type || 'process';
            // rotation and text alignment controls removed
            // Populate border controls
            const bcEl = document.getElementById('nodeBorderColor');
            const bwEl = document.getElementById('nodeBorderWidth');
            if (bcEl) bcEl.value = (node.style?.stroke) || (appSettings?.defaults?.node?.borderColor) || '#1f2937';
            if (bwEl) bwEl.value = (node.style?.strokeWidth ?? (appSettings?.defaults?.node?.borderWidth ?? 2));

            // Live-persist border changes: update node.style and autosave
            if (bcEl && !bcEl._bound) {
                bcEl._bound = true;
                bcEl.addEventListener('input', () => {
                    if (!editingNode) return;
                    editingNode.style = editingNode.style || {};
                    editingNode.style.stroke = bcEl.value || '#1f2937';
                    try { updateNodeVisual(editingNode, editingNodeElement); } catch (_) { }
                    try { updateConnections(); } catch (_) { }
                    hasUnsavedChanges = true;
                    const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                    scheduleAutoSave();
                    saveDiagram(true);
                });
            }
            if (bwEl && !bwEl._bound) {
                bwEl._bound = true;
                bwEl.addEventListener('input', () => {
                    if (!editingNode) return;
                    const n = Math.max(0, parseInt(bwEl.value, 10) || 0);
                    editingNode.style = editingNode.style || {};
                    editingNode.style.strokeWidth = n;
                    try { updateNodeVisual(editingNode, editingNodeElement); } catch (_) { }
                    try { updateConnections(); } catch (_) { }
                    hasUnsavedChanges = true;
                    const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                    scheduleAutoSave();
                    saveDiagram(true);
                });
            }

            // text position controls removed

            // Initialize color picker selection and favorites
            renderFavoriteColors();
            const currentColor = node.style?.fill || getNodeTypeColor(node.type);
            // UI-only initialization (do not mutate the node or trigger autosave)
            setSelectedColor(currentColor, { applyToNode: false });
            // Bind palette clicks (favorites are bound in renderFavoriteColors)
            document.querySelectorAll('#fillColorGrid .color-option').forEach(option => {
                option.onclick = () => {
                    const color = option.dataset.color;
                    if (color) setSelectedColor(color);
                };
            });

            // text position controls removed

            // Show the editor (docked)
            const ed = document.getElementById('nodeEditor');
            ed.style.display = 'block';

            // Enforce square inputs for decision nodes during editing
            const typeEl = document.getElementById('nodeType');
            const wEl = null;
            const hEl = null;

            function applySquareLockForDecision() {
                if (typeEl.value === 'decision') {
                    // Size handled via resize handles; no inputs to mirror
                } else {
                    // nothing
                }
            }

            // Bind type change to toggle the lock (and keep existing onchange behavior)
            if (!typeEl._squareLockListener) {
                typeEl._squareLockListener = () => applySquareLockForDecision();
                typeEl.addEventListener('change', typeEl._squareLockListener);
            }
            // Apply initial lock state
            applySquareLockForDecision();
        }

        function closeNodeEditor() {
            const ed = document.getElementById('nodeEditor');
            // Hide and undock
            ed.style.display = 'none';
            undockNodeEditor();
            editingNode = null;
            editingNodeElement = null;
            // Restore info panel default content
            renderDiagramSummaryInPanel();
            // Remove editing badge if present
            try {
                const titleEl = document.getElementById('infoTitle');
                titleEl?.querySelector('[data-role="editing-badge"]')?.remove();
            } catch (_) { }

            // If we auto-opened the panel for editing, collapse it back (auto mode only)
            const panel = document.getElementById('infoPanel');
            if (panel && panel.dataset.autoOpened === 'true' && (appSettings.infoPanelMode || 'auto') === 'auto') {
                panel.classList.remove('temp-open');
                delete panel.dataset.autoOpened;
                applyInfoPanelState();
            }
            setInfoPanelHeader('');
        }

        async function confirmDeleteCurrentNode() {
            deleteNode(editingNode, editingNodeElement);
            saveDiagram(true);
            closeNodeEditor();
        }

        function saveNodeChanges() {
            if (!editingNode || !editingNodeElement) return;

            // Get form values
            const newName = editingNode.name; // inline-edited on shape
            const newType = document.getElementById('nodeType').value;
            const newRotation = node.rotation || 0;
            let newWidth = editingNode.dimensions?.width || 100;
            let newHeight = editingNode.dimensions?.height || 50;
            // Diamonds must be square: force equal dimensions
            if (newType === 'decision') {
                const size = Math.max(newWidth || 0, newHeight || 0);
                newWidth = size; newHeight = size;
            }
            // text alignment control removed
            // Determine selected color preference
            const selectedValueEl = document.getElementById('selectedColorValue');
            const sv = selectedValueEl ? (selectedValueEl.value || '') : '';
            let newColor = (sv && /^#([0-9A-Fa-f]{6})$/.test(sv)) ? sv : null;
            if (!newColor) {
                const selectedColor = document.querySelector('#fillColorGrid .color-option.selected, #favoriteColors .color-option.selected');
                newColor = selectedColor ? selectedColor.dataset.color : getNodeTypeColor(newType);
            }

            // Text position removed from editor; keep existing value
            const textPosition = node.textPosition || { horizontal: 'center', vertical: 'center' };

            // Check if name changed (for auto-resize)
            const nameChanged = editingNode.name !== newName;
            const typeChanged = editingNode.type !== newType;

            // Update the node data
            editingNode.name = newName;
            editingNode.type = newType;
            editingNode.rotation = newRotation;
            editingNode.textPosition = textPosition;
            // preserve existing alignment; editing via panel removed
            editingNode.dimensions = editingNode.dimensions || {};

            // Determine if user changed dimensions in this edit
            const oldWidth = editingNode.dimensions?.width || 100;
            const oldHeight = editingNode.dimensions?.height || 50;
            const sizeChanged = false; // size changes come from inline resize, not the panel

            // Keep existing dimensions (managed by inline resize/auto-resize)
            editingNode.dimensions.width = newWidth;
            editingNode.dimensions.height = newHeight;
            // Diamonds must remain square
            if (newType === 'decision') {
                const size = Math.max(newWidth || 0, newHeight || 0);
                editingNode.dimensions.width = size;
                editingNode.dimensions.height = size;
            }
            // If size changed, mark as manual so future renders won't auto-resize over it
            // manualSize is controlled by resize handles/auto sizing

            editingNode.style = editingNode.style || {};
            editingNode.style.fill = newColor;
            // Border style
            const bc = (document.getElementById('nodeBorderColor') || {}).value || '#1f2937';
            const bwRaw = (document.getElementById('nodeBorderWidth') || {}).value;
            const bw = Math.max(0, parseInt(bwRaw, 10) || 0);
            editingNode.style.stroke = bc;
            editingNode.style.strokeWidth = bw;

            // Update the visual element
            updateNodeVisual(editingNode, editingNodeElement);

            // Update connections
            updateConnections();

            // Mark as changed
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            scheduleAutoSave();
            // Immediate silent autosave for editor-based node updates
            saveDiagram(true);

            // Close editor
            closeNodeEditor();

            showMessage('Node updated successfully!', 'success');
        }

        function updateNodeVisual(node, nodeElement) {
            // Auto-resize for text content if not manually overridden
            if (!node.manualSize) {
                autoResizeNode(node, nodeElement);
            }

            // Update dimensions
            nodeElement.style.width = (node.dimensions?.width || 100) + 'px';
            nodeElement.style.height = (node.dimensions?.height || 50) + 'px';

            // Update colors
            const style = node.style || {};
            nodeElement.style.backgroundColor = style.fill || getNodeTypeColor(node.type);
            // Rendering fallbacks only (do not pull from appSettings.defaults to avoid retroactive changes)
            const defaultBorderWidth = 2;
            const defaultBorderColor = '#333';
            // Determine border width: respect explicit 0 (no border); otherwise use configured default
            let strokeWidth;
            if (style && Object.prototype.hasOwnProperty.call(style, 'strokeWidth')) {
                strokeWidth = Math.max(0, Number(style.strokeWidth) || 0);
            } else {
                strokeWidth = Math.max(0, Number(defaultBorderWidth) || 0);
            }
            const borderColor = (style.stroke != null ? style.stroke : defaultBorderColor);

            // Ensure CSS classes reflect current type (used by affordance styling)
            if ((node.type || '').toLowerCase() === 'decision') {
                nodeElement.classList.add('decision-node');
            } else {
                nodeElement.classList.remove('decision-node');
            }

            // Get or create text element
            let textEl = nodeElement.querySelector('.node-text');
            if (!textEl) {
                textEl = document.createElement('div');
                textEl.className = 'node-text';
                nodeElement.appendChild(textEl);
            }

            // Update text content
            textEl.textContent = node.name;

            // Apply text positioning
            const textPos = node.textPosition || { horizontal: 'center', vertical: 'center' };
            const textAlign = node.textAlign || 'center';

            textEl.style.alignItems = textPos.vertical;
            textEl.style.justifyContent = textPos.horizontal;
            textEl.style.textAlign = textAlign;

            // Update shape based on type and reset transforms
            nodeElement.style.transform = '';
            nodeElement.style.borderRadius = '';
            nodeElement.style.clipPath = '';
            textEl.style.transform = '';
            // Reset border and remove any prior overlays
            nodeElement.style.border = '';
            nodeElement.querySelectorAll('.shape-border-overlay').forEach(el => el.remove());

            if (node.type === 'decision') {
                // Diamond shape for decisions - ensure square dimensions
                if (!node.manualSize) {
                    const size = Math.max(node.dimensions?.width || 100, node.dimensions?.height || 100);
                    node.dimensions = node.dimensions || {};
                    node.dimensions.width = size;
                    node.dimensions.height = size;
                    nodeElement.style.width = size + 'px';
                    nodeElement.style.height = size + 'px';
                }

                nodeElement.style.transform = `rotate(45deg)`;
                if (node.rotation) {
                    nodeElement.style.transform += ` rotate(${node.rotation}deg)`;
                }
                nodeElement.style.transformOrigin = 'center';
                textEl.style.transform = 'rotate(-45deg)';
            } else if (node.type === 'start' || node.type === 'end' || node.type === 'connector') {
                // Ellipse for start/end
                nodeElement.style.borderRadius = '50%';
                if (node.rotation) {
                    nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                }
            } else if (node.type === 'data') {
                // Hexagon for data
                nodeElement.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                if (node.rotation) {
                    nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                }
                // Overlay border for hexagon
                if (strokeWidth > 0) {
                    const overlay = document.createElement('div');
                    overlay.className = 'shape-border-overlay';
                    Object.assign(overlay.style, {
                        position: 'absolute', top: '0', left: '0', right: '0', bottom: '0',
                        pointerEvents: 'none',
                        clipPath: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
                        boxShadow: `inset 0 0 0 ${strokeWidth}px ${borderColor}`
                    });
                    nodeElement.appendChild(overlay);
                }
            } else if (node.type === 'io') {
                // Parallelogram (I/O)
                nodeElement.style.clipPath = 'polygon(15% 0%, 100% 0%, 85% 100%, 0% 100%)';
                if (node.rotation) nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                if (strokeWidth > 0) {
                    const overlay = document.createElement('div');
                    overlay.className = 'shape-border-overlay';
                    Object.assign(overlay.style, {
                        position: 'absolute', inset: '0', pointerEvents: 'none',
                        clipPath: 'polygon(15% 0%, 100% 0%, 85% 100%, 0% 100%)',
                        boxShadow: `inset 0 0 0 ${strokeWidth}px ${borderColor}`
                    });
                    nodeElement.appendChild(overlay);
                }
            } else if (node.type === 'manualInput') {
                // Trapezoid (Manual Input)
                nodeElement.style.clipPath = 'polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%)';
                if (node.rotation) nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                if (strokeWidth > 0) {
                    const overlay = document.createElement('div');
                    overlay.className = 'shape-border-overlay';
                    Object.assign(overlay.style, {
                        position: 'absolute', inset: '0', pointerEvents: 'none',
                        clipPath: 'polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%)',
                        boxShadow: `inset 0 0 0 ${strokeWidth}px ${borderColor}`
                    });
                    nodeElement.appendChild(overlay);
                }
            } else if (node.type === 'subroutine') {
                // Rectangle with two vertical inner lines
                nodeElement.style.borderRadius = '8px';
                if (node.rotation) nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                // Add inner stripes as overlay children
                const leftStripe = document.createElement('div');
                leftStripe.className = 'shape-border-overlay subroutine-stripe-left';
                Object.assign(leftStripe.style, {
                    position: 'absolute', top: '4px', bottom: '4px', left: '8px', width: '2px',
                    background: borderColor, pointerEvents: 'none'
                });
                const rightStripe = document.createElement('div');
                rightStripe.className = 'shape-border-overlay subroutine-stripe-right';
                Object.assign(rightStripe.style, {
                    position: 'absolute', top: '4px', bottom: '4px', right: '8px', width: '2px',
                    background: borderColor, pointerEvents: 'none'
                });
                nodeElement.appendChild(leftStripe);
                nodeElement.appendChild(rightStripe);
            } else if (node.type === 'database') {
                // Cylindrical database approximation
                nodeElement.style.borderRadius = '10px/20px';
                if (node.rotation) nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                // Top ellipse overlay
                if (strokeWidth > 0) {
                    const topEllipse = document.createElement('div');
                    topEllipse.className = 'shape-border-overlay';
                    Object.assign(topEllipse.style, {
                        position: 'absolute', left: '4px', right: '4px', top: '-2px', height: '12px',
                        border: `${Math.max(1, strokeWidth)}px solid ${borderColor}`, borderBottom: 'none',
                        borderRadius: '999px/12px', pointerEvents: 'none', background: 'transparent'
                    });
                    nodeElement.appendChild(topEllipse);
                }
            } else if (node.type === 'delay') {
                // D-shape: rectangle with fully rounded right side
                nodeElement.style.borderRadius = '0 999px 999px 0';
                if (node.rotation) nodeElement.style.transform = `rotate(${node.rotation}deg)`;
            } else if (node.type === 'offPage') {
                // Off-Page Connector: notched shape
                nodeElement.style.clipPath = 'polygon(0 0,100% 0,100% 70%,60% 70%,60% 100%,0 100%)';
                if (node.rotation) nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                if (strokeWidth > 0) {
                    const overlay = document.createElement('div');
                    overlay.className = 'shape-border-overlay';
                    Object.assign(overlay.style, {
                        position: 'absolute', inset: '0', pointerEvents: 'none',
                        clipPath: 'polygon(0 0,100% 0,100% 70%,60% 70%,60% 100%,0 100%)',
                        boxShadow: `inset 0 0 0 ${strokeWidth}px ${borderColor}`
                    });
                    nodeElement.appendChild(overlay);
                }
            } else {
                // Rectangle for process nodes
                nodeElement.style.borderRadius = '8px';
                if (node.rotation) {
                    nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                }
            }

            // Apply standard border to non-hexagon shapes
            if (node.type !== 'data' && node.type !== 'io' && node.type !== 'manualInput' && node.type !== 'offPage') {
                if (strokeWidth > 0) {
                    nodeElement.style.border = `${strokeWidth}px solid ${borderColor}`;
                } else {
                    nodeElement.style.border = 'none';
                }
            }
            // Ensure resize handles reflect the current shape and avoid overlapping connection points
            try { addResizeHandles(nodeElement, node); } catch (_) { /* no-op if not yet in DOM */ }
        }

        function autoResizeNode(node, nodeElement) {

            // Establish layout constants: paddings and border widths
            // Defaults match styles/app.css (.node has padding:10px, border:2px; .node-text has padding:10px)
            let nodePadding = 10; // each side
            let textPadding = 10; // each side
            let borderWidth = 2; // each side for non-hexagon shapes
            const t = (node.type || '').toLowerCase();
            if (t === 'data') borderWidth = 0; // hex uses overlay, not the element border

            // Note: Decision (diamond) visual padding is reduced via CSS (.decision-node).
            // Keep measurement defaults here to avoid sizing inconsistencies when nodeElement is null.

            // If we have a nodeElement, try to read actual computed styles
            if (nodeElement) {
                try {
                    const csNode = getComputedStyle(nodeElement);
                    const nPadTop = parseFloat(csNode.paddingTop) || nodePadding;
                    const nPadLeft = parseFloat(csNode.paddingLeft) || nodePadding;
                    nodePadding = Math.round((nPadTop + nPadLeft) / 2);
                    const b = parseFloat(csNode.borderLeftWidth) || borderWidth;
                    borderWidth = b;
                    const textEl = nodeElement.querySelector('.node-text');
                    if (textEl) {
                        const csText = getComputedStyle(textEl);
                        const tPadTop = parseFloat(csText.paddingTop) || textPadding;
                        const tPadLeft = parseFloat(csText.paddingLeft) || textPadding;
                        textPadding = Math.round((tPadTop + tPadLeft) / 2);
                    }
                } catch (_) { /* fallback to defaults */ }
            } else if (node && node.style && node.type !== 'data') {
                // Use configured strokeWidth if available when no DOM element is passed
                const sw = Math.max(0, Number(node.style.strokeWidth) || 0);
                if (sw > 0) borderWidth = sw;
            }

            // Build measurer that mirrors .node-text box (border-box with its own padding only)
            let measurer = document.getElementById('text-measurer');
            if (!measurer) {
                measurer = document.createElement('div');
                measurer.id = 'text-measurer';
                document.body.appendChild(measurer);
            }
            Object.assign(measurer.style, {
                position: 'fixed', left: '-9999px', top: '-9999px', visibility: 'hidden',
                display: 'inline-block', boxSizing: 'border-box',
                padding: textPadding + 'px',
                whiteSpace: 'normal', wordBreak: 'break-word', overflowWrap: 'break-word',
                margin: '0', border: '0',
                fontWeight: '700',
                fontSize: '0.8rem', // mirror .node font-size
                fontFamily: 'inherit', lineHeight: '1.25'
            });
            measurer.textContent = node.name;

            // Compute text box dimensions: prefer natural width below cap, otherwise wrap at cap
            const MAX_TEXT_WIDTH = 220; // cap for wrapping to avoid overly wide nodes
            // First, natural size (no explicit width)
            measurer.style.width = 'auto';
            measurer.style.display = 'inline-block';
            const naturalRect = measurer.getBoundingClientRect();
            let textBoxW = Math.ceil(naturalRect.width);
            let textBoxH = Math.ceil(naturalRect.height);
            if (textBoxW > MAX_TEXT_WIDTH) {
                measurer.style.display = 'block';
                measurer.style.width = MAX_TEXT_WIDTH + 'px';
                textBoxW = MAX_TEXT_WIDTH;
                textBoxH = Math.ceil(measurer.scrollHeight);
            }

            // Now convert text box (which equals .node-text border-box) to node dimensions
            const totalPad = 2 * (nodePadding + borderWidth); // amount added to content box per dimension

            let width, height;
            if (t === 'decision') {
                // For diamonds (rotated square), choose total side S so that:
                // 1) content box width/height (node.contentBox) accommodate text box exactly
                //    node.contentBoxWidth = S - 2*(nodePadding + borderWidth) >= textBoxW
                // 2) axis-aligned rectangle fits within rotated square (inscribed square side S/√2)
                //    textBoxW, textBoxH <= S/√2
                const need1 = textBoxW + totalPad; // ensures content box is wide enough
                const need2 = Math.SQRT2 * Math.max(textBoxW, textBoxH); // ensures inscribed square is large enough
                const S = Math.max(need1, need2, 72); // apply a reasonable minimum
                width = Math.ceil(S);
                height = Math.ceil(S);
            } else if (t === 'start' || t === 'end' || t === 'connector') {
                // Circles: choose diameter D
                // Constraints:
                // 1) content box width accommodates text box => D >= textBoxW + totalPad
                // 2) rectangle (text box) must fit in circle => D >= hypot(textBoxW, textBoxH)
                const needWidth = textBoxW + totalPad;
                const needCircle = Math.hypot(textBoxW, textBoxH);
                const D = Math.max(needWidth, needCircle, 48);
                width = height = Math.ceil(D);
            } else if (t === 'data') {
                // Hexagon: approximate as rectangle plus a small inset to avoid clip; keep tight
                const inset = 6; // small visual margin
                width = Math.max(80, Math.ceil(textBoxW + totalPad + inset));
                height = Math.max(40, Math.ceil(textBoxH + totalPad + inset));
            } else if (t === 'io') {
                // Parallelogram: add small insets to avoid clipping text near slants
                const inset = 6;
                width = Math.max(90, Math.ceil(textBoxW + totalPad + inset));
                height = Math.max(40, Math.ceil(textBoxH + totalPad + inset));
            } else if (t === 'manualInput') {
                // Trapezoid: similar to parallelogram
                const inset = 6;
                width = Math.max(90, Math.ceil(textBoxW + totalPad + inset));
                height = Math.max(40, Math.ceil(textBoxH + totalPad + inset));
            } else if (t === 'subroutine') {
                // Subroutine: rectangle with inner stripes; treat like process with a touch more width
                const extra = 10; // for visual breathing room around stripes
                width = Math.max(100, Math.ceil(textBoxW + totalPad + extra));
                height = Math.max(40, Math.ceil(textBoxH + totalPad));
            } else if (t === 'database') {
                // Cylinder: a bit taller for ellipse
                const inset = 8;
                width = Math.max(100, Math.ceil(textBoxW + totalPad + inset));
                height = Math.max(50, Math.ceil(textBoxH + totalPad + inset));
            } else if (t === 'delay') {
                // D-shape: similar to process
                width = Math.max(90, Math.ceil(textBoxW + totalPad));
                height = Math.max(40, Math.ceil(textBoxH + totalPad));
            } else if (t === 'offPage') {
                // Notched: allow small inset
                const inset = 6;
                width = Math.max(90, Math.ceil(textBoxW + totalPad + inset));
                height = Math.max(40, Math.ceil(textBoxH + totalPad + inset));
            } else {
                // Rectangles: tight fit to text box + paddings
                width = Math.max(80, Math.ceil(textBoxW + totalPad));
                height = Math.max(40, Math.ceil(textBoxH + totalPad));
            }

            node.dimensions = node.dimensions || {};
            node.dimensions.width = width;
            node.dimensions.height = height;
        }

        // Rebuild a node's connection points UI based on its current type
        function rebuildNodeConnectionPoints(node, nodeElement) {
            if (!node || !nodeElement) return;
            // Remove existing connection points
            try { nodeElement.querySelectorAll('.connection-point').forEach(el => el.remove()); } catch (_) { }

            // Add connection points on each side (different positioning for different shapes)
            const styleForCP = node.style || {};
            const bwForCP = Object.prototype.hasOwnProperty.call(styleForCP, 'strokeWidth')
                ? Math.max(0, Number(styleForCP.strokeWidth) || 0)
                : 2;
            const bump = Math.max(2, Math.round(bwForCP / 2) + 2);

            let connectionPoints;
            if (node.type === 'decision') {
                connectionPoints = [
                    { side: 'top', x: '0%', y: '0%', transform: 'translate(-50%, -50%)' },
                    { side: 'right', x: '100%', y: '0%', transform: 'translate(-50%, -50%)' },
                    { side: 'bottom', x: '100%', y: '100%', transform: 'translate(-50%, -50%)' },
                    { side: 'left', x: '0%', y: '100%', transform: 'translate(-50%, -50%)' }
                ];
            } else if (node.type === 'start' || node.type === 'end') {
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else if (node.type === 'data') {
                connectionPoints = [
                    { side: 'top', x: '50%', y: '6%', transform: 'translate(-50%, -50%)' },
                    { side: 'right', x: '94%', y: '50%', transform: 'translate(-50%, -50%)' },
                    { side: 'bottom', x: '50%', y: '94%', transform: 'translate(-50%, -50%)' },
                    { side: 'left', x: '6%', y: '50%', transform: 'translate(-50%, -50%)' }
                ];
            } else if (node.type === 'io') {
                // Parallelogram: midpoints shifted slightly to account for slants
                connectionPoints = [
                    { side: 'top', x: '52%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '48%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else if (node.type === 'manualInput') {
                // Trapezoid: use standard side midpoints
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else if (node.type === 'subroutine') {
                // Same as rectangle
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else if (node.type === 'database') {
                // Treat like rectangle
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else if (node.type === 'delay') {
                // D-shape: standard midpoints
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else if (node.type === 'offPage') {
                // Use rectangle midpoints
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            } else {
                connectionPoints = [
                    { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                    { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                    { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                    { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                ];
            }

            connectionPoints.forEach(point => {
                const connectionPoint = document.createElement('div');
                connectionPoint.className = 'connection-point';
                connectionPoint.dataset.side = point.side;
                connectionPoint.dataset.nodeId = node.id;
                connectionPoint.style.position = 'absolute';
                connectionPoint.style.left = point.x;
                connectionPoint.style.top = point.y;
                connectionPoint.style.transform = point.transform;
                connectionPoint.style.width = '12px';
                connectionPoint.style.height = '12px';
                connectionPoint.style.backgroundColor = 'rgba(52, 152, 219, 0.6)';
                connectionPoint.style.border = '1px solid rgba(255, 255, 255, 0.7)';
                connectionPoint.style.borderRadius = '50%';
                connectionPoint.style.zIndex = '15';
                connectionPoint.style.cursor = 'crosshair';
                connectionPoint.style.transition = 'opacity 0.2s, transform 0.2s';

                // Hover effects
                connectionPoint.addEventListener('mouseenter', () => {
                    connectionPoint.style.transform = point.transform + ' scale(1.12)';
                    connectionPoint.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.9), 0 2px 8px rgba(0,0,0,0.2)';
                    connectionPoint.style.backgroundColor = 'rgba(41, 128, 185, 0.95)';
                    connectionPoint.style.borderColor = 'rgba(255,255,255,1)';
                });
                connectionPoint.addEventListener('mouseleave', () => {
                    connectionPoint.style.transform = point.transform + ' scale(1)';
                    connectionPoint.style.boxShadow = '';
                    connectionPoint.style.backgroundColor = 'rgba(52, 152, 219, 0.6)';
                    connectionPoint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
                });

                // Begin connection on mousedown/touch
                connectionPoint.addEventListener('mousedown', (evt) => {
                    if (!editMode) return;
                    evt.preventDefault(); evt.stopPropagation();
                    startEdgeCreation(connectionPoint, evt.clientX, evt.clientY);
                });
                connectionPoint.addEventListener('touchstart', (evt) => {
                    if (!editMode) return;
                    const t = evt.touches[0];
                    evt.preventDefault(); evt.stopPropagation();
                    startEdgeCreation(connectionPoint, t.clientX, t.clientY);
                }, { passive: false });

                // Double-click to auto-add a connected step on this side
                connectionPoint.addEventListener('dblclick', (evt) => {
                    if (!editMode) return;
                    evt.preventDefault(); evt.stopPropagation();
                    const srcId = nodeElement.dataset.nodeId;
                    addStepFromNode(srcId, point.side);
                });

                nodeElement.appendChild(connectionPoint);
            });
        }

        function updateShapePreview() {
            // Apply live shape change to the currently edited node
            const typeSel = document.getElementById('nodeType');
            if (!typeSel || !editingNode || !editingNodeElement) return;
            const newType = typeSel.value || 'process';
            if (editingNode.type === newType) return;

            // Update model
            editingNode.type = newType;
            // Clear manual sizing so auto-resize can adapt the new shape
            editingNode.manualSize = false;
            try { autoResizeNode(editingNode, null); } catch (_) { }
            try { updateNodeVisual(editingNode, editingNodeElement); } catch (_) { }
            try { addResizeHandles(editingNodeElement, editingNode); } catch (_) { }
            try { rebuildNodeConnectionPoints(editingNode, editingNodeElement); } catch (_) { }
            try { updateConnections(); } catch (_) { }

            // Mark dirty and autosave silently
            hasUnsavedChanges = true;
            const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
            scheduleAutoSave();
            saveDiagram(true);
        }

        // rotation preview removed

        // Add keyboard shortcuts (and extended ones)
        document.addEventListener('keydown', (e) => {
            if (!editMode) return;
            if (e.key === 'Escape') {
                closeNodeEditor();
                closeEdgeEditor();
                cancelEdgeCreation();
                // Cancel click-to-connect mode
                clickConnectState = null;
                hoveredNodeEl = null;
                // Leave info panel content as-is; do not clear on Esc
            } else if (e.key === 'Delete' && selectedEdgeId) {
                deleteSelectedEdge();
            } else if ((e.key === 'c' || e.key === 'C')) {
                // Arm click-to-connect from the currently selected node element
                const src = selectedNodeElement;
                if (src) {
                    clickConnectState = { sourceNodeId: src.dataset.nodeId };
                    showMessage('Click a target node to connect', 'info');
                    hoveredNodeEl = src;
                } else {
                    showMessage('Select a source node first, then press C', 'info');
                }
            }
            // Global app shortcuts (Cmd/Ctrl)
            const cmd = e.metaKey || e.ctrlKey;
            if (cmd && !e.shiftKey && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                // Force a save so users always get a confirmation toast even if autosave already cleared the dirty flag
                saveDiagram(false, true);
            } else if (cmd && e.shiftKey && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                openSaveAsModal();
            } else if (cmd && (e.key === 'o' || e.key === 'O')) {
                e.preventDefault();
                openOpenDiagramModal();
            } else if (cmd && (e.key === 'n' || e.key === 'N')) {
                e.preventDefault();
                openNewDiagramModal();
            }
        });

        // Click-to-connect state
        let clickConnectState = null;

        async function deleteNode(node, nodeElement) {
            if (!currentDiagram) return;

            // Remove from diagram data
            const nodeIndex = currentDiagram.nodes.findIndex(n => n.id === node.id);
            if (nodeIndex > -1) {
                currentDiagram.nodes.splice(nodeIndex, 1);
            }

            // Remove edges connected to this node
            currentDiagram.edges = currentDiagram.edges.filter(edge =>
                edge.from !== node.id && edge.to !== node.id
            );

            // Remove visual element
            nodeElement.remove();
            if (selectedNodeElement === nodeElement) selectedNodeElement = null;

            // Update connections
            updateConnections();

            // Mark as changed
            hasUnsavedChanges = true;
            const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
            // Cancel any pending autosave and persist immediately
            try { clearTimeout(autosaveTimer); } catch (_) { }
            updateAutosaveStatus('saving');
            await saveDiagram(false, true);

            closeNodeEditor();
            showMessage('Node deleted successfully!', 'success');
            updateDiagramInfoBox();
        }

        // Tabs removed: Bootstrap Accordion is used for categories

        function setSize(width, height) {
            const type = (document.getElementById('nodeType') || {}).value;
            if (type === 'decision') {
                const size = Math.max(width, height);
                document.getElementById('nodeWidth').value = size;
                document.getElementById('nodeHeight').value = size;
            } else {
                document.getElementById('nodeWidth').value = width;
                document.getElementById('nodeHeight').value = height;
            }
        }

        function autoResizeCurrentNode() {
            if (!editingNode || !editingNodeElement) return;

            // Get current name from the form
            const currentName = document.getElementById('nodeName').value;
            const currentType = document.getElementById('nodeType').value;

            // Temporarily update node for measurement
            const tempNode = { ...editingNode, name: currentName, type: currentType };
            autoResizeNode(tempNode, null);

            // Update the form inputs
            document.getElementById('nodeWidth').value = tempNode.dimensions.width;
            document.getElementById('nodeHeight').value = tempNode.dimensions.height;

            // Apply the new dimensions to the actual node
            editingNode.dimensions = editingNode.dimensions || {};
            editingNode.dimensions.width = tempNode.dimensions.width;
            editingNode.dimensions.height = tempNode.dimensions.height;

            // Clear manual size flag so it will auto-resize in the future
            editingNode.manualSize = false;

            // Update the visual element immediately
            updateNodeVisual(editingNode, editingNodeElement);

            // Update connections
            updateConnections();

            // Mark as changed
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            scheduleAutoSave();

            // Immediate silent autosave for auto-size changes
            saveDiagram(true);

            showMessage('Node auto-resized to fit text!', 'success');
        }

        function renderFlowchart(diagram) {

            const display = document.getElementById('flowchartDisplay');


            display.innerHTML = '';
            // Clear any previous selection
            selectedNodeElement = null;
            display.style.position = 'relative';
            display.style.height = `100%`; // CSS parent (.diagram-layout) controls the height
            display.style.overflow = 'auto';

            // Create a stage wrapper so we can scale contents together
            const stage = document.createElement('div');
            stage.id = 'diagramStage';
            stage.style.position = 'absolute';
            stage.style.inset = '0';
            stage.style.transformOrigin = '0 0';
            stage.style.zIndex = '1';
            display.appendChild(stage);

            // Re-apply grid overlay if enabled (rendering cleared the container)
            if (gridEnabled) {
                showGrid();
            }

            if (!diagram || !diagram.nodes) {
                console.error('Invalid diagram data:', diagram);
                display.innerHTML = '<div style="color: red;">Invalid diagram data</div>';
                return;
            }



            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            diagram.nodes.forEach(node => {
                minX = Math.min(minX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxX = Math.max(maxX, node.position.x + (node.dimensions?.width || 100));
                maxY = Math.max(maxY, node.position.y + (node.dimensions?.height || 50));
            });



            const padding = 50;
            const containerWidth = maxX - minX + 2 * padding;
            const containerHeight = maxY - minY + 2 * padding;

            // Create or reuse SVG for connections
            let svg = stage.querySelector('svg.connections-layer');

            // Remove any duplicate connections SVGs first (but keep grid SVG)
            const connectionsSvgs = display.querySelectorAll('svg.connections-layer');
            if (connectionsSvgs.length > 1) {

                // Keep the first one, remove the rest
                for (let i = 1; i < connectionsSvgs.length; i++) {
                    connectionsSvgs[i].remove();
                }
                svg = connectionsSvgs[0]; // Use the first one
            }

            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.className = 'connections-layer';
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.zIndex = '1';
                svg.style.pointerEvents = 'auto';
                stage.appendChild(svg);
            }

            // Ensure a dedicated edges group exists and clear it
            let edgesGroup = svg.querySelector('g.edges-layer');
            if (!edgesGroup) {
                edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                edgesGroup.setAttribute('class', 'edges-layer');
                svg.appendChild(edgesGroup);
            } else {
                const allEdgeGroups = svg.querySelectorAll('g.edges-layer');
                if (allEdgeGroups.length > 1) {
                    for (let i = 1; i < allEdgeGroups.length; i++) allEdgeGroups[i].remove();
                    edgesGroup = allEdgeGroups[0];
                }
            }
            // Remove any stray edge elements directly under the SVG (not in edges group)
            const strayAtRoot = Array.from(svg.children).filter(el =>
                el.tagName && ['LINE', 'POLYGON', 'TEXT', 'RECT', 'PATH', 'CIRCLE', 'ELLIPSE'].includes(el.tagName) &&
                el.getAttribute('class') !== 'edges-layer'
            );
            if (strayAtRoot.length) {

                strayAtRoot.forEach(el => el.remove());
            }

            edgesGroup.replaceChildren();




            // Ensure all nodes have IDs (generate if missing)
            diagram.nodes.forEach((node, index) => {
                if (!node.id || !node.id.trim()) {
                    node.id = node.type || `node_${index}`;
                }
                if (!node.name || !node.name.trim()) {
                    node.name = `${node.type || 'Node'} ${index + 1}`;
                }
            });

            // Also update edges to match the node IDs we just created
            if (diagram.edges) {
                diagram.edges.forEach(edge => {
                    // Try to find nodes by the edge's from/to values
                    const fromNode = diagram.nodes.find(n => n.type === edge.from || n.id === edge.from);
                    const toNode = diagram.nodes.find(n => n.type === edge.to || n.id === edge.to);
                    if (fromNode) edge.from = fromNode.id;
                    if (toNode) edge.to = toNode.id;
                });
            }

            // Create a map of node positions for edge drawing
            const nodePositions = {};
            const validNodes = diagram.nodes.filter(node => node.id && node.id.trim());


            diagram.nodes.filter(node => node.id && node.id.trim()).forEach(node => {
                const x = node.position.x - minX + padding;
                const y = node.position.y - minY + padding;
                const width = node.dimensions?.width || 100;
                const height = node.dimensions?.height || 50;
                nodePositions[node.id] = {
                    id: node.id,  // Add the node ID so calculateConnectionPoints can find the DOM element
                    x: x,
                    y: y,
                    centerX: x + width / 2,
                    centerY: y + height / 2,
                    width: width,
                    height: height,
                    type: node.type || 'process'
                };
            });

            // Create nodes first (edges will be drawn after all nodes are in the DOM)
            const nodesToRender = diagram.nodes.filter(node => node.id && node.id.trim());


            diagram.nodes.filter(node => node.id && node.id.trim()).forEach((node, index) => {

                // Auto-size only if dimensions are missing
                if (!node.dimensions || !node.dimensions.width || !node.dimensions.height) {
                    autoResizeNode(node, null);
                }

                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                if ((node.type || '').toLowerCase() === 'decision') {
                    nodeEl.classList.add('decision-node');
                }
                nodeEl.dataset.nodeId = node.id; // Store node ID for updates

                // Create text container
                const textEl = document.createElement('div');
                textEl.className = 'node-text';
                textEl.textContent = node.name || `Node ${index + 1}`;

                // Apply text positioning
                const textPos = node.textPosition || { horizontal: 'center', vertical: 'center' };
                const textAlign = node.textAlign || 'center';

                textEl.style.alignItems = textPos.vertical;
                textEl.style.justifyContent = textPos.horizontal;
                textEl.style.textAlign = textAlign;

                nodeEl.appendChild(textEl);

                // Inline label editing on click (true inline, contentEditable)
                textEl.addEventListener('click', (ev) => {
                    if (!editMode || !appSettings.inlineLabelEditingEnabled) return;
                    ev.stopPropagation();
                    // If already editing, ignore
                    if (textEl.isContentEditable) return;
                    // Pause dragging and enter editing state
                    disableDragging(nodeEl);
                    nodeEl.classList.add('editing');
                    // Enable contentEditable on the text element
                    textEl.contentEditable = 'true';
                    textEl.spellcheck = false;
                    // Ensure the side panel with the Node Editor is visible while live editing
                    try { setSelectedNode(nodeEl); openNodeEditor(node, nodeEl); } catch (_) { /* non-fatal */ }
                    // Remember original state for cancel
                    const original = {
                        text: node.name || '',
                        w: node.dimensions?.width,
                        h: node.dimensions?.height
                    };
                    // Focus and move caret to end
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.selectNodeContents(textEl);
                    range.collapse(false); // end
                    sel.removeAllRanges();
                    sel.addRange(range);
                    textEl.focus();

                    function commit(save) {
                        // Exit editing state and disable contentEditable
                        textEl.contentEditable = 'false';
                        nodeEl.classList.remove('editing');
                        enableDragging(nodeEl);
                        const val = (textEl.textContent || '').trim();
                        if (!save) {
                            // Revert text and size
                            textEl.textContent = original.text;
                            if (original.w && original.h) {
                                node.dimensions = node.dimensions || {};
                                node.dimensions.width = original.w;
                                node.dimensions.height = original.h;
                                nodeEl.style.width = original.w + 'px';
                                nodeEl.style.height = original.h + 'px';
                                updateConnections();
                            }
                            return;
                        }
                        if (val === (node.name || '')) return;
                        // Update node data and auto-resize
                        node.name = val;
                        node.manualSize = false;
                        autoResizeNode(node, nodeEl);
                        // Apply new size
                        nodeEl.style.width = node.dimensions.width + 'px';
                        nodeEl.style.height = node.dimensions.height + 'px';
                        updateConnections();
                        // Mark changed and autosave
                        hasUnsavedChanges = true;
                        const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                        scheduleAutoSave();
                        saveDiagram(true);
                    }

                    // Live auto-size as user types
                    const onInput = () => {
                        const temp = { ...node, name: (textEl.textContent || ''), manualSize: false };
                        autoResizeNode(temp, nodeEl);
                        nodeEl.style.width = temp.dimensions.width + 'px';
                        nodeEl.style.height = temp.dimensions.height + 'px';
                        updateConnections();
                    };
                    textEl.addEventListener('input', onInput);
                    textEl.addEventListener('keyup', onInput);
                    textEl.addEventListener('paste', () => setTimeout(onInput, 0));
                    textEl.addEventListener('compositionend', onInput);

                    const onKey = (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); commit(true); cleanup(); }
                        else if (e.key === 'Escape') { e.preventDefault(); commit(false); cleanup(); }
                    };
                    textEl.addEventListener('keydown', onKey);

                    const onBlur = () => { commit(true); cleanup(); };
                    textEl.addEventListener('blur', onBlur, { once: true });

                    function cleanup() {
                        textEl.removeEventListener('input', onInput);
                        textEl.removeEventListener('keyup', onInput);
                        textEl.removeEventListener('paste', onInput);
                        textEl.removeEventListener('compositionend', onInput);
                        textEl.removeEventListener('keydown', onKey);
                    }
                });

                // Mini toolbar (Shape | X) shown on hover in edit mode (feature-gated)
                let toolbar = null;
                if (appSettings.onCanvasToolbarEnabled) {
                    toolbar = document.createElement('div');
                    toolbar.className = 'node-toolbar';
                    toolbar.innerHTML = `
                    <button type="button" class="tb-btn" data-action="shape" title="Change shape">▲ <span>shape</span></button>
                    <button type="button" class="tb-btn delete" data-action="delete" title="Delete step">✕</button>
                    <div class="shape-popover">
                        <div class="shape-option" data-shape="process" title="Process">
                            <div style="width:24px;height:16px;border:2px solid #374151;border-radius:4px;"></div>
                            <div class="shape-label">proc</div>
                        </div>
                        <div class="shape-option" data-shape="decision" title="Decision">
                            <div style="width:20px;height:20px;transform:rotate(45deg);border:2px solid #374151;"></div>
                            <div class="shape-label">decision</div>
                        </div>
                        <div class="shape-option" data-shape="start" title="Start">
                            <div style="width:20px;height:20px;border-radius:999px;border:2px solid #374151;"></div>
                            <div class="shape-label">start</div>
                        </div>
                        <div class="shape-option" data-shape="end" title="End">
                            <div style="width:20px;height:20px;border-radius:999px;border:2px solid #374151;"></div>
                            <div class="shape-label">end</div>
                        </div>
                        <div class="shape-option" data-shape="data" title="Data">
                            <div style="width:24px;height:18px;clip-path:polygon(25% 0%,75% 0%,100% 50%,75% 100%,25% 100%,0 50%);border:2px solid #374151;"></div>
                            <div class="shape-label">data</div>
                        </div>
                        <div class="shape-option" data-shape="io" title="Input/Output">
                            <div style="width:26px;height:16px;clip-path:polygon(15% 0%,100% 0%,85% 100%,0% 100%);border:2px solid #374151;"></div>
                            <div class="shape-label">I/O</div>
                        </div>
                        <div class="shape-option" data-shape="manualInput" title="Manual Input">
                            <div style="width:26px;height:16px;clip-path:polygon(10% 0%,90% 0%,100% 100%,0% 100%);border:2px solid #374151;"></div>
                            <div class="shape-label">manual</div>
                        </div>
                        <div class="shape-option" data-shape="subroutine" title="Subroutine">
                            <div style="width:24px;height:16px;border:2px solid #374151;border-radius:4px;position:relative;">
                                <div style="position:absolute;top:2px;bottom:2px;left:4px;width:2px;background:#374151;"></div>
                                <div style="position:absolute;top:2px;bottom:2px;right:4px;width:2px;background:#374151;"></div>
                            </div>
                            <div class="shape-label">sub</div>
                        </div>
                        <div class="shape-option" data-shape="database" title="Database">
                            <div style="width:24px;height:16px;border:2px solid #374151;border-radius:6px/12px 12px 6px 6px;position:relative;overflow:hidden;">
                                <div style="position:absolute;top:-2px;left:0;right:0;height:6px;border:2px solid #374151;border-bottom:none;border-radius:12px/6px;"></div>
                            </div>
                            <div class="shape-label">db</div>
                        </div>
                        <div class="shape-option" data-shape="delay" title="Delay">
                            <div style="width:24px;height:16px;border:2px solid #374151;border-radius:0 999px 999px 0;"></div>
                            <div class="shape-label">delay</div>
                        </div>
                        <div class="shape-option" data-shape="offPage" title="Off Page">
                            <div style="width:24px;height:18px;clip-path:polygon(0 0,100% 0,100% 70%,60% 70%,60% 100%,0 100%);border:2px solid #374151;"></div>
                            <div class="shape-label">off</div>
                        </div>
                    </div>`;
                    nodeEl.appendChild(toolbar);

                    const shapeBtn = toolbar.querySelector('[data-action="shape"]');
                    const deleteBtn = toolbar.querySelector('[data-action="delete"]');
                    const popover = toolbar.querySelector('.shape-popover');
                    function togglePopover(show) {
                        if (show) popover.classList.add('open'); else popover.classList.remove('open');
                    }
                    shapeBtn.addEventListener('click', (e) => {
                        if (!editMode) return;
                        e.stopPropagation();
                        togglePopover(!popover.classList.contains('open'));
                    });
                    // Popover closing handled by a single global document listener (see below)
                    // Handle shape selection
                    popover.querySelectorAll('.shape-option').forEach(opt => {
                        opt.addEventListener('click', (e) => {
                            if (!editMode) return;
                            e.stopPropagation();
                            const newType = opt.getAttribute('data-shape');
                            if (!newType || newType === node.type) { togglePopover(false); return; }
                            node.type = newType;
                            // Clear manual size to allow auto-sizing to adjust to new shape
                            node.manualSize = false;
                            autoResizeNode(node, null);
                            // Re-render just this node visually using existing util
                            updateNodeVisual(node, nodeEl);
                            // Rebuild resize handles to reflect new shape and avoid overlap
                            addResizeHandles(nodeEl, node);
                            // Rebuild connection points for the new shape
                            rebuildNodeConnectionPoints(node, nodeEl);
                            updateConnections();
                            togglePopover(false);
                            hasUnsavedChanges = true;
                            const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                            scheduleAutoSave();
                            saveDiagram(true);
                        });
                    });
                    // Delete button
                    deleteBtn.addEventListener('click', (e) => {
                        if (!editMode) return;
                        e.stopPropagation();
                        // quick confirm
                        if (!confirm('Delete this step and its connectors?')) return;
                        deleteNode(node, nodeEl);
                    });
                }

                // In-canvas delete button removed; deletion is handled in Node Editor

                // Add connection points on each side (different positioning for different shapes)
                // Offset outward from thick borders so points don't hide inside the border
                const styleForCP = node.style || {};
                const bwForCP = Object.prototype.hasOwnProperty.call(styleForCP, 'strokeWidth')
                    ? Math.max(0, Number(styleForCP.strokeWidth) || 0)
                    : 2;
                const bump = Math.max(2, Math.round(bwForCP / 2) + 2); // outward offset in px

                let connectionPoints;
                if (node.type === 'decision') {
                    // Diamond is a square rotated 45°. Place connectors at the unrotated square's corners
                    // so that after rotation they land exactly on the diamond's vertices.
                    // Corner ↔ side mapping after 45° rotation:
                    //  - top-left  -> top vertex
                    //  - top-right -> right vertex
                    //  - bottom-right -> bottom vertex
                    //  - bottom-left -> left vertex
                    connectionPoints = [
                        { side: 'top', x: '0%', y: '0%', transform: 'translate(-50%, -50%)' },
                        { side: 'right', x: '100%', y: '0%', transform: 'translate(-50%, -50%)' },
                        { side: 'bottom', x: '100%', y: '100%', transform: 'translate(-50%, -50%)' },
                        { side: 'left', x: '0%', y: '100%', transform: 'translate(-50%, -50%)' }
                    ];
                } else if (node.type === 'start' || node.type === 'end') {
                    // Circular shapes - connection points at the actual edge of the circle
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else if (node.type === 'data') {
                    // Hexagon shapes - inset points slightly to avoid clip-path cutting them off
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '6%', transform: 'translate(-50%, -50%)' },
                        { side: 'right', x: '94%', y: '50%', transform: 'translate(-50%, -50%)' },
                        { side: 'bottom', x: '50%', y: '94%', transform: 'translate(-50%, -50%)' },
                        { side: 'left', x: '6%', y: '50%', transform: 'translate(-50%, -50%)' }
                    ];
                } else if (node.type === 'io') {
                    // Parallelogram: nudge top/bottom a bit for better orthogonal entry
                    connectionPoints = [
                        { side: 'top', x: '52%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '48%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else if (node.type === 'manualInput') {
                    // Trapezoid: standard side midpoints
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else if (node.type === 'subroutine') {
                    // Rectangle: standard midpoints
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else if (node.type === 'database') {
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else if (node.type === 'delay') {
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else if (node.type === 'offPage') {
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                } else {
                    // Rectangular shapes - connection points at middle of each side
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: `translate(-50%, -50%) translateY(-${bump}px)` },
                        { side: 'right', x: '100%', y: '50%', transform: `translate(-50%, -50%) translateX(${bump}px)` },
                        { side: 'bottom', x: '50%', y: '100%', transform: `translate(-50%, -50%) translateY(${bump}px)` },
                        { side: 'left', x: '0%', y: '50%', transform: `translate(-50%, -50%) translateX(-${bump}px)` }
                    ];
                }

                connectionPoints.forEach(point => {
                    const connectionPoint = document.createElement('div');
                    connectionPoint.className = 'connection-point';
                    connectionPoint.dataset.side = point.side;
                    connectionPoint.dataset.nodeId = node.id;
                    connectionPoint.style.position = 'absolute';
                    connectionPoint.style.left = point.x;
                    connectionPoint.style.top = point.y;
                    connectionPoint.style.transform = point.transform;
                    connectionPoint.style.width = '12px';
                    connectionPoint.style.height = '12px';
                    connectionPoint.style.backgroundColor = 'rgba(52, 152, 219, 0.6)';
                    connectionPoint.style.border = '1px solid rgba(255, 255, 255, 0.7)';
                    connectionPoint.style.borderRadius = '50%';
                    connectionPoint.style.zIndex = '15';
                    connectionPoint.style.cursor = 'crosshair';
                    connectionPoint.style.transition = 'opacity 0.2s, transform 0.2s';

                    // Add hover effects (bolder on hover)
                    connectionPoint.addEventListener('mouseenter', () => {
                        connectionPoint.style.transform = point.transform + ' scale(1.12)';
                        connectionPoint.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.9), 0 2px 8px rgba(0,0,0,0.2)';
                        connectionPoint.style.backgroundColor = 'rgba(41, 128, 185, 0.95)';
                        connectionPoint.style.borderColor = 'rgba(255,255,255,1)';
                    });

                    connectionPoint.addEventListener('mouseleave', () => {
                        connectionPoint.style.transform = point.transform + ' scale(1)';
                        connectionPoint.style.boxShadow = '';
                        connectionPoint.style.backgroundColor = 'rgba(52, 152, 219, 0.6)';
                        connectionPoint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
                    });

                    // Begin connection on mousedown/touch
                    connectionPoint.addEventListener('mousedown', (evt) => {
                        if (!editMode) return;
                        evt.preventDefault(); evt.stopPropagation();
                        startEdgeCreation(connectionPoint, evt.clientX, evt.clientY);
                    });
                    connectionPoint.addEventListener('touchstart', (evt) => {
                        if (!editMode) return;
                        const t = evt.touches[0];
                        evt.preventDefault(); evt.stopPropagation();
                        startEdgeCreation(connectionPoint, t.clientX, t.clientY);
                    }, { passive: false });

                    // Double-click to auto-add a connected step on this side
                    connectionPoint.addEventListener('dblclick', (evt) => {
                        if (!editMode) return;
                        evt.preventDefault(); evt.stopPropagation();
                        const srcId = nodeEl.dataset.nodeId;
                        addStepFromNode(srcId, point.side);
                    });

                    nodeEl.appendChild(connectionPoint);
                    // No on-canvas labels; shown in Info Panel instead
                });

                // Position relative to container
                const x = node.position.x - minX + padding;
                const y = node.position.y - minY + padding;

                nodeEl.style.left = x + 'px';
                nodeEl.style.top = y + 'px';
                nodeEl.style.width = (node.dimensions?.width || 100) + 'px';
                nodeEl.style.height = (node.dimensions?.height || 50) + 'px';
                nodeEl.style.zIndex = '10';

                // Apply styling
                const style = node.style || {};
                nodeEl.style.backgroundColor = style.fill || getNodeTypeColor(node.type);
                // Rendering fallback only; do not read appSettings.defaults here to avoid retroactively changing existing items
                const defaultBorderWidth = 2;
                const defaultBorderColor = '#333';
                const borderColor = (style.stroke != null ? style.stroke : defaultBorderColor);
                let borderWidth;
                if (Object.prototype.hasOwnProperty.call(style, 'strokeWidth')) {
                    borderWidth = Math.max(0, Number(style.strokeWidth) || 0);
                } else {
                    borderWidth = Math.max(0, Number(defaultBorderWidth) || 0);
                }
                // Reset any previous borders/overlays
                nodeEl.style.border = '';
                nodeEl.querySelectorAll('.shape-border-overlay').forEach(el => el.remove());

                // Add special styling for different node types
                if (node.type === 'decision') {
                    nodeEl.style.transform = `rotate(45deg)`;
                    if (node.rotation) {
                        nodeEl.style.transform += ` rotate(${node.rotation}deg)`;
                    }
                    nodeEl.style.transformOrigin = 'center';
                    textEl.style.transform = 'rotate(-45deg)';
                } else if (node.type === 'start' || node.type === 'end') {
                    nodeEl.style.borderRadius = '50%';
                    if (node.rotation) {
                        nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    }
                } else if (node.type === 'data') {
                    nodeEl.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                    if (node.rotation) {
                        nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    }
                    // Use an overlay to draw a clean border around the hexagon
                    if (borderWidth > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'shape-border-overlay';
                        Object.assign(overlay.style, {
                            position: 'absolute', top: '0', left: '0', right: '0', bottom: '0',
                            pointerEvents: 'none',
                            clipPath: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
                            boxShadow: `inset 0 0 0 ${borderWidth}px ${borderColor}`
                        });
                        nodeEl.appendChild(overlay);
                    }
                } else if (node.type === 'io') {
                    nodeEl.style.clipPath = 'polygon(15% 0%, 100% 0%, 85% 100%, 0% 100%)';
                    if (node.rotation) nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    if (borderWidth > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'shape-border-overlay';
                        Object.assign(overlay.style, {
                            position: 'absolute', top: 0, right: 0, bottom: 0, left: 0,
                            pointerEvents: 'none',
                            clipPath: 'polygon(15% 0%, 100% 0%, 85% 100%, 0% 100%)',
                            boxShadow: `inset 0 0 0 ${borderWidth}px ${borderColor}`
                        });
                        nodeEl.appendChild(overlay);
                    }
                } else if (node.type === 'manualInput') {
                    nodeEl.style.clipPath = 'polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%)';
                    if (node.rotation) nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    if (borderWidth > 0) {
                        const overlay = document.createElement('div');
                        overlay.className = 'shape-border-overlay';
                        Object.assign(overlay.style, {
                            position: 'absolute', top: 0, right: 0, bottom: 0, left: 0,
                            pointerEvents: 'none',
                            clipPath: 'polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%)',
                            boxShadow: `inset 0 0 0 ${borderWidth}px ${borderColor}`
                        });
                        nodeEl.appendChild(overlay);
                    }
                } else if (node.type === 'subroutine') {
                    if (node.rotation) nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    // Add inner stripes
                    const leftStripe = document.createElement('div');
                    leftStripe.className = 'shape-border-overlay subroutine-stripe-left';
                    Object.assign(leftStripe.style, {
                        position: 'absolute', top: '4px', bottom: '4px', left: '8px', width: '2px',
                        background: borderColor, pointerEvents: 'none'
                    });
                    const rightStripe = document.createElement('div');
                    rightStripe.className = 'shape-border-overlay subroutine-stripe-right';
                    Object.assign(rightStripe.style, {
                        position: 'absolute', top: '4px', bottom: '4px', right: '8px', width: '2px',
                        background: borderColor, pointerEvents: 'none'
                    });
                    nodeEl.appendChild(leftStripe);
                    nodeEl.appendChild(rightStripe);
                } else {
                    // Rectangle/process
                    if (node.rotation) {
                        nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    }
                }

                // Apply border to shapes that don't use overlay borders
                if (node.type !== 'data' && node.type !== 'io' && node.type !== 'manualInput') {
                    if (borderWidth > 0) {
                        nodeEl.style.border = `${borderWidth}px solid ${borderColor}`;
                    } else {
                        nodeEl.style.border = 'none';
                    }
                }

                // Add click handler (info when not in edit mode, drag when in edit mode)
                let dragStarted = false;
                let mouseDownTime = 0;

                nodeEl.addEventListener('mousedown', (e) => {
                    mouseDownTime = Date.now();
                    dragStarted = false;
                    if (editMode) setSelectedNode(nodeEl);
                    hoveredNodeEl = nodeEl; // track selection only
                    // Alt/Option + drag from node body starts a connector from the nearest side
                    if (editMode && e.altKey && !e.target.closest('.connection-point')) {
                        e.preventDefault();
                        // Determine nearest side to cursor
                        const rect = nodeEl.getBoundingClientRect();
                        const cx = e.clientX - rect.left;
                        const cy = e.clientY - rect.top;
                        const sides = [
                            { side: 'top', d: Math.abs(cy) },
                            { side: 'bottom', d: Math.abs(rect.height - cy) },
                            { side: 'left', d: Math.abs(cx) },
                            { side: 'right', d: Math.abs(rect.width - cx) }
                        ];
                        sides.sort((a, b) => a.d - b.d);
                        const nearest = sides[0].side;
                        // Find the corresponding connection point element
                        const cp = nodeEl.querySelector(`.connection-point[data-side="${nearest}"]`);
                        if (cp) {
                            startEdgeCreation(cp, e.clientX, e.clientY);
                        }
                    }
                });

                nodeEl.addEventListener('mousemove', (e) => {
                    if (mouseDownTime > 0 && Date.now() - mouseDownTime > 100) {
                        dragStarted = true;
                    }
                    // live update while hovering
                    // hover info disabled
                });

                nodeEl.onclick = async (e) => {
                    // Only trigger click if it wasn't a drag operation
                    if (!dragStarted) {
                        if (editMode) {
                            // Click-to-connect flow takes precedence
                            if (clickConnectState && clickConnectState.sourceNodeId) {
                                const srcId = clickConnectState.sourceNodeId;
                                const dstId = node.id;
                                clickConnectState = null;
                                if (srcId && dstId && srcId !== dstId) {
                                    currentDiagram.edges = currentDiagram.edges || [];
                                    const newEdge = {
                                        id: `${srcId}-${dstId}-${Date.now()}`,
                                        from: srcId,
                                        to: dstId,
                                        name: '',
                                        style: {
                                            stroke: appSettings?.defaults?.edge?.stroke || '#34495e',
                                            strokeWidth: appSettings?.defaults?.edge?.strokeWidth ?? 2,
                                            ...(appSettings?.defaults?.edge?.strokeDasharray ? { strokeDasharray: appSettings.defaults.edge.strokeDasharray } : {})
                                        },
                                        metadata: {}
                                    };
                                    currentDiagram.edges.push(newEdge);
                                    hasUnsavedChanges = true;
                                    const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                                    scheduleAutoSave();
                                    // Immediate forced autosave on connector add (click-to-connect)
                                    await saveDiagram(true, true);
                                    updateConnections();
                                    updateDiagramInfoBox();
                                    openEdgeEditor(newEdge.id);
                                    dragStarted = false; mouseDownTime = 0; return;
                                }
                            }
                            // Default single-click in edit mode: open Node Editor in the side panel
                            try { setSelectedNode(nodeEl); openNodeEditor(node, nodeEl); } catch (_) { }
                        } else {
                            // View mode: show summary info
                            showNodeInfo(node);
                        }
                    }
                    dragStarted = false;
                    mouseDownTime = 0;
                };

                // Hover-driven info panel disabled

                // Add double-click handler for editing
                nodeEl.ondblclick = (e) => {
                    if (editMode) {
                        e.stopPropagation();
                        setSelectedNode(nodeEl);
                        openNodeEditor(node, nodeEl);
                    }
                };

                // Add right-click context menu
                nodeEl.oncontextmenu = (e) => {
                    if (editMode) {
                        e.preventDefault();
                        setSelectedNode(nodeEl);
                        openNodeEditor(node, nodeEl);
                    }
                };

                // Add visual indicators for enterprise features
                if (node.integrations?.jira || node.drillDown) {
                    const indicators = document.createElement('div');
                    indicators.style.position = 'absolute';
                    indicators.style.top = '5px';
                    indicators.style.right = '5px';
                    indicators.style.fontSize = '10px';
                    indicators.style.zIndex = '1';

                    if (node.integrations?.jira) {
                        const jiraIcon = document.createElement('span');
                        jiraIcon.textContent = '🔗';
                        jiraIcon.title = `Jira: ${node.integrations.jira.projectKey}-${node.integrations.jira.issueKey}`;
                        indicators.appendChild(jiraIcon);
                    }

                    if (node.drillDown) {
                        const drillIcon = document.createElement('span');
                        drillIcon.textContent = '📋';
                        drillIcon.title = `Drill-down: ${node.drillDown}`;
                        indicators.appendChild(drillIcon);
                    }

                    nodeEl.appendChild(indicators);
                }

                // Enable dragging for all nodes
                enableDragging(nodeEl);

                // Add resize handles (east, south, southeast)
                addResizeHandles(nodeEl, node);

                stage.appendChild(nodeEl);
            });

            // Draw edges after all nodes are created and added to the DOM
            // Use setTimeout to ensure DOM is fully updated
            setTimeout(() => {
                if (diagram.edges) {
                    diagram.edges.filter(edge => edge.from && edge.to && edge.from.trim() && edge.to.trim()).forEach(edge => {
                        const fromNode = nodePositions[edge.from];
                        const toNode = nodePositions[edge.to];

                        if (fromNode && toNode) {
                            drawEdge(edgesGroup, fromNode, toNode, edge);
                        }
                    });
                }
            }, 10); // Small delay to ensure DOM is ready

            // Apply current zoom to the stage and update the info box
            applyZoom();
            updateDiagramInfoBox();
            // hover info disabled
        }

        function applyZoom() {
            const stage = document.getElementById('diagramStage');
            if (stage) {
                stage.style.transformOrigin = '0 0';
                stage.style.transform = `scale(${zoomScale})`;
            }
            const grid = document.querySelector('#flowchartDisplay svg.grid-overlay');
            if (grid) grid.style.transform = `scale(${zoomScale})`;
            if (grid) grid.style.transformOrigin = '0 0';
            const label = document.getElementById('zoomLevelLabel');
            if (label) label.textContent = `${Math.round(zoomScale * 100)}%`;
            try { localStorage.setItem('flowgen.zoomScale', String(zoomScale)); } catch (_) { }
            // Recompute connectors after zoom so old lines and labels are cleared and redrawn
            // Note: updateConnections() safely clears the edges layer before drawing
            updateConnections();
            // Update info panel positions if hovering
            // hover info disabled
        }

        function zoomIn() { zoomScale = Math.min(ZOOM_MAX, +(zoomScale + ZOOM_STEP).toFixed(2)); applyZoom(); }
        function zoomOut() { zoomScale = Math.max(ZOOM_MIN, +(zoomScale - ZOOM_STEP).toFixed(2)); applyZoom(); }
        // Warn if navigating away with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        function zoomReset() { zoomScale = 1.0; applyZoom(); }

        // ============ ALIGNMENT FUNCTIONS ============
        function clusterValues(sortedValues, tolerance) {
            // Input must be sorted array of numbers
            const groups = [];
            let current = [];
            for (let i = 0; i < sortedValues.length; i++) {
                const v = sortedValues[i];
                if (current.length === 0) {
                    current.push(v);
                } else {
                    const last = current[current.length - 1];
                    if (Math.abs(v - last) <= tolerance) {
                        current.push(v);
                    } else {
                        groups.push(current);
                        current = [v];
                    }
                }
            }
            if (current.length) groups.push(current);
            // Return group centers (mean) and original group arrays
            return groups.map(g => ({
                values: g,
                center: g.reduce((a, b) => a + b, 0) / g.length
            }));
        }

        function normalizeCenters(centers, spacingHint) {
            // centers: sorted numeric array; return normalized equally spaced centers preserving count
            if (centers.length <= 1) return centers.slice();
            const minC = centers[0];
            const maxC = centers[centers.length - 1];
            let spacing = spacingHint;
            if (!spacing) {
                // average delta
                let sum = 0;
                let cnt = 0;
                for (let i = 1; i < centers.length; i++) { sum += (centers[i] - centers[i - 1]); cnt++; }
                spacing = cnt ? (sum / cnt) : (gridSize * 3);
            }
            // Snap spacing to grid to make it look consistent
            spacing = Math.max(gridSize, Math.round(spacing / gridSize) * gridSize);
            const norm = [Math.round(minC / gridSize) * gridSize];
            for (let i = 1; i < centers.length; i++) norm.push(norm[i - 1] + spacing);
            return norm;
        }

        function alignDiagram() {
            const display = document.getElementById('flowchartDisplay');
            const nodes = Array.from(display.querySelectorAll('.node'));
            if (!nodes.length) return;

            // Gather node metrics
            const metrics = nodes.map(nodeEl => {
                const x = parseInt(nodeEl.style.left) || 0;
                const y = parseInt(nodeEl.style.top) || 0;
                const w = nodeEl.offsetWidth;
                const h = nodeEl.offsetHeight;
                const cx = x + w / 2;
                const cy = y + h / 2;
                return { nodeEl, x, y, w, h, cx, cy };
            });

            // Tolerance for clustering (use ~gridSize)
            const tol = Math.max(10, gridSize);

            // Cluster Y (rows) by centerY
            const sortedCY = metrics.map(m => m.cy).sort((a, b) => a - b);
            const yGroups = clusterValues(sortedCY, tol);
            let yCenters = yGroups.map(g => g.center).sort((a, b) => a - b);
            if (yCenters.length > 1) {
                // Normalize spacing for consistent rows
                yCenters = normalizeCenters(yCenters);
            }

            // Cluster X (columns) by centerX
            const sortedCX = metrics.map(m => m.cx).sort((a, b) => a - b);
            const xGroups = clusterValues(sortedCX, tol);
            let xCenters = xGroups.map(g => g.center).sort((a, b) => a - b);
            if (xCenters.length > 1) {
                // Normalize spacing for consistent columns
                xCenters = normalizeCenters(xCenters);
            }

            // For mapping: assign each node to nearest row and column center
            function nearest(arr, value) {
                let best = arr[0];
                let bestD = Math.abs(value - best);
                for (let i = 1; i < arr.length; i++) {
                    const d = Math.abs(value - arr[i]);
                    if (d < bestD) { best = arr[i]; bestD = d; }
                }
                return best;
            }

            // Move nodes to aligned centers
            const displayRect = display.getBoundingClientRect();
            metrics.forEach(m => {
                const targetCY = yCenters.length ? nearest(yCenters, m.cy) : m.cy;
                const targetCX = xCenters.length ? nearest(xCenters, m.cx) : m.cx;
                let targetX = Math.round(targetCX - m.w / 2);
                let targetY = Math.round(targetCY - m.h / 2);

                // Snap to grid using shape-aware snapping
                const snapped = snapNodePosition(m.nodeEl, targetX, targetY, false);
                targetX = snapped.x; targetY = snapped.y;

                // Constrain within container
                const maxX = displayRect.width - m.w;
                const maxY = displayRect.height - m.h;
                targetX = Math.max(0, Math.min(targetX, maxX));
                targetY = Math.max(0, Math.min(targetY, maxY));

                m.nodeEl.style.left = targetX + 'px';
                m.nodeEl.style.top = targetY + 'px';
            });

            // Persist and redraw
            updateDiagramData();
            updateConnections();
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            showMessage('Diagram aligned', 'success');
        }

        // ============ APPLICATION SETTINGS (Persistent) ============
        const defaultAppSettings = {
            gridEnabled: false,
            snapToGrid: false,
            gridSize: 25,
            gridColor: '#bdc3c7',
            gridOpacity: 0.3,
            // Info panel is always locked open now
            // Feature flags: enable inline editing only, keep toolbar off
            inlineLabelEditingEnabled: true,
            onCanvasToolbarEnabled: false,
            // Connector routing: 'straight' (direct lines) or 'orthogonal' (90-degree turns)
            connectorRouting: 'straight',
            // Defaults for newly added items
            defaults: {
                node: {
                    type: 'process',
                    width: 120,
                    height: 60,
                    fill: '#3498db',
                    borderColor: '#1f2937',
                    borderWidth: 2
                },
                edge: {
                    stroke: '#34495e',
                    strokeWidth: 2,
                    strokeDasharray: ''
                }
            }
        };
        let appSettings = { ...defaultAppSettings };

        function loadAppSettings() {
            try {
                const raw = localStorage.getItem('flowgen.settings');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    appSettings = { ...defaultAppSettings, ...parsed };
                } else {
                    appSettings = { ...defaultAppSettings };
                }
            } catch (_) {
                appSettings = { ...defaultAppSettings };
            }
            applySettings(false); // apply without forcing redraw
            // Also apply non-grid UI based on settings
            try { populateNavbarInfoPanelMode(); } catch (_) { }
            try { populateNavbarConnectorRouting(); } catch (_) { }
        }

        function saveAppSettings() {
            // Persist current form values, then apply
            collectSettingsFromForm(appSettings);
            saveAppSettingsSilent();
            applySettings(true); // apply and refresh grid
            showMessage('Settings saved', 'success');
        }

        function saveAppSettingsSilent() {
            try {
                localStorage.setItem('flowgen.settings', JSON.stringify(appSettings));
            } catch (_) { /* ignore */ }
        }

        function resetAppSettings() {
            appSettings = { ...defaultAppSettings };
            saveAppSettingsSilent();
            populateSettingsForm();
            applySettings(true);
            showMessage('Settings reset to defaults', 'success');
        }

        function populateSettingsForm() {
            const gridEnabledEl = document.getElementById('settingsGridEnabled');
            const snapEl = document.getElementById('settingsSnapToGrid');
            const sizeEl = document.getElementById('settingsGridSize');
            const colorEl = document.getElementById('settingsGridColor');
            const opacityEl = document.getElementById('settingsGridOpacity');

            if (gridEnabledEl) gridEnabledEl.checked = !!appSettings.gridEnabled;
            if (snapEl) snapEl.checked = !!appSettings.snapToGrid;
            if (sizeEl) sizeEl.value = appSettings.gridSize;
            if (colorEl) colorEl.value = appSettings.gridColor || '#bdc3c7';
            if (opacityEl) opacityEl.value = appSettings.gridOpacity ?? 0.3;
        }

        // ===== Defaults Panel =====
        function renderDefaultsPanel(isDocked = false) {
            const body = document.getElementById('infoPanelBody');
            if (!body) return;
            const d = (appSettings.defaults || {});
            const n = d.node || {};
            const e = d.edge || {};
            const html = `
                <div class="info-section" style="border:1px solid #e5e7eb;border-radius:8px;padding:12px;background:#fff;">
                    <div class="panel-title" style="font-weight:600;font-size:13px;margin-bottom:8px;color:#374151;">Default Settings</div>

                    <div class="editor-group">
                        <label style="font-weight:600;">New Node</label>
                        <div style="display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center;">
                            <span>Type</span>
                            <select id="defNodeType">
                                <option value="process">Process</option>
                                <option value="start">Start</option>
                                <option value="end">End</option>
                                <option value="decision">Decision</option>
                                <option value="data">Data</option>
                                <option value="connector">Connector</option>
                            </select>
                            <span>Width</span>
                            <input type="number" id="defNodeW" min="40" max="600" step="5" />
                            <span>Height</span>
                            <input type="number" id="defNodeH" min="30" max="400" step="5" />
                            <span>Fill</span>
                            <input type="color" id="defNodeFill" />
                            <span>Border Color</span>
                            <input type="color" id="defNodeBorderColor" />
                            <span>Border Width</span>
                            <input type="number" id="defNodeBorderWidth" min="0" max="10" step="1" />
                        </div>
                    </div>
                    <div class="editor-group" style="margin-top:16px;">
                        <label style="font-weight:600;">New Connector</label>
                        <div style="display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center;">
                            <span>Stroke</span>
                            <input type="color" id="defEdgeStroke" />
                            <span>Width</span>
                            <input type="number" id="defEdgeWidth" min="1" max="20" step="1" />
                            <span>Line Style</span>
                            <select id="defEdgeDash">
                                <option value="solid">Solid</option>
                                <option value="dotted">Dotted</option>
                                <option value="dashed">Dashed</option>
                            </select>
                        </div>
                    </div>
                    <div style="font-size:11px;color:#6b7280;margin-top:8px;">Defaults apply to newly added nodes/connectors. Existing items are unchanged.</div>
                </div>
            `;
            body.innerHTML = html;
            // Populate values
            document.getElementById('defNodeType').value = n.type || 'process';
            document.getElementById('defNodeW').value = n.width ?? 120;
            document.getElementById('defNodeH').value = n.height ?? 60;
            document.getElementById('defNodeFill').value = n.fill || '#3498db';
            document.getElementById('defNodeBorderColor').value = n.borderColor || '#1f2937';
            document.getElementById('defNodeBorderWidth').value = n.borderWidth ?? 2;
            document.getElementById('defEdgeStroke').value = e.stroke || '#34495e';
            document.getElementById('defEdgeWidth').value = e.strokeWidth ?? 2;
            document.getElementById('defEdgeDash').value = dashArrayToName(e.strokeDasharray || '');

            // Autosave on change (no explicit Save button)
            const commitDefaults = () => {
                const next = {
                    node: {
                        type: document.getElementById('defNodeType').value || 'process',
                        width: clampInt(document.getElementById('defNodeW').value, 40, 600, 120),
                        height: clampInt(document.getElementById('defNodeH').value, 30, 400, 60),
                        fill: document.getElementById('defNodeFill').value || '#3498db',
                        borderColor: document.getElementById('defNodeBorderColor').value || '#1f2937',
                        borderWidth: clampInt(document.getElementById('defNodeBorderWidth').value, 0, 10, 2)
                    },
                    edge: {
                        stroke: document.getElementById('defEdgeStroke').value || '#34495e',
                        strokeWidth: clampInt(document.getElementById('defEdgeWidth').value, 1, 20, 2),
                        strokeDasharray: dashNameToArray(document.getElementById('defEdgeDash').value || 'solid')
                    }
                };
                appSettings.defaults = next;
                saveAppSettingsSilent();
                // Soft toast without distraction
                showMessage('Defaults updated', 'info');
            };
            ['defNodeType', 'defNodeW', 'defNodeH', 'defNodeFill', 'defNodeBorderColor', 'defNodeBorderWidth', 'defEdgeStroke', 'defEdgeWidth', 'defEdgeDash']
                .forEach(id => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    ['change', 'input'].forEach(evt => el.addEventListener(evt, commitDefaults));
                });
        }

        function clampInt(val, min, max, fallback) {
            const n = parseInt(val, 10);
            if (isNaN(n)) return fallback;
            return Math.max(min, Math.min(max, n));
        }

        // Keep ribbon grid controls in sync with app settings
        function populateRibbonGridControls() {
            const snapEl = document.getElementById('ribbonSnapToGrid');
            const sizeEl = document.getElementById('ribbonGridSize');
            const colorEl = document.getElementById('ribbonGridColor');
            const opacityEl = document.getElementById('ribbonGridOpacity');
            if (snapEl) snapEl.checked = !!appSettings.snapToGrid;
            if (sizeEl) sizeEl.value = appSettings.gridSize;
            if (colorEl) colorEl.value = appSettings.gridColor || '#bdc3c7';
            if (opacityEl) opacityEl.value = appSettings.gridOpacity ?? 0.3;
        }

        function applyRibbonGridChange() {
            // Mirror ribbon controls to appSettings and apply immediately
            const snapEl = document.getElementById('ribbonSnapToGrid');
            const sizeEl = document.getElementById('ribbonGridSize');
            const colorEl = document.getElementById('ribbonGridColor');
            const opacityEl = document.getElementById('ribbonGridOpacity');

            if (snapEl) appSettings.snapToGrid = !!snapEl.checked;
            if (sizeEl) appSettings.gridSize = Math.max(5, Math.min(200, parseInt(sizeEl.value || '25', 10)));
            if (colorEl) appSettings.gridColor = colorEl.value || '#bdc3c7';
            if (opacityEl) appSettings.gridOpacity = Math.max(0, Math.min(1, parseFloat(opacityEl.value || '0.3')));

            // Keep runtime vars aligned and redraw grid
            saveAppSettingsSilent();
            applySettings(true);
            // Keep settings form (in Settings tab) in sync too
            populateSettingsForm();
        }

        // ===== Navbar: Connector Routing Mode =====
        function populateNavbarConnectorRouting() {
            const straight = document.getElementById('navRoutingStraight');
            const orthogonal = document.getElementById('navRoutingOrthogonal');
            const mode = appSettings.connectorRouting || 'straight';
            if (straight) straight.checked = (mode === 'straight');
            if (orthogonal) orthogonal.checked = (mode === 'orthogonal');
        }
        function onNavbarConnectorRoutingChange(e) {
            const val = e && e.target ? e.target.value : 'straight';
            appSettings.connectorRouting = (val === 'orthogonal') ? 'orthogonal' : 'straight';
            saveAppSettingsSilent();
            // Redraw all connections with the new routing mode
            updateConnections();
            showMessage(`Connector routing: ${appSettings.connectorRouting}`, 'info');
        }

        // Navbar Info Panel mode removed; panel is always open.

        // Dropdown open/close logic for Grid
        function toggleGridDropdown(event) {
            event.stopPropagation();
            const dd = document.getElementById('gridDropdown');
            if (!dd) return;
            dd.classList.toggle('open');
        }
        // Close dropdown on outside click or Escape; also close any shape popovers (if feature enabled)
        document.addEventListener('click', (e) => {
            const dd = document.getElementById('gridDropdown');
            if (dd && !dd.contains(e.target)) dd.classList.remove('open');
            // Close all shape popovers if clicking outside
            if (appSettings && appSettings.onCanvasToolbarEnabled) {
                document.querySelectorAll('.shape-popover.open').forEach(pop => {
                    const shapeBtn = pop.parentElement?.querySelector('[data-action="shape"]');
                    if (!pop.contains(e.target) && e.target !== shapeBtn) {
                        pop.classList.remove('open');
                    }
                });
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const dd = document.getElementById('gridDropdown');
                if (dd) dd.classList.remove('open');
                // Escape closes the docked node editor if open
                if (editorDocked) {
                    e.stopPropagation();
                    closeNodeEditor();
                }
                // Escape closes any open shape popovers
                if (appSettings && appSettings.onCanvasToolbarEnabled) {
                    document.querySelectorAll('.shape-popover.open').forEach(pop => pop.classList.remove('open'));
                }
            }
        });

        // Grid button UI removed

        function applySettings(refreshGrid) {
            gridEnabled = !!appSettings.gridEnabled;
            snapToGrid = !!appSettings.snapToGrid;
            gridSize = parseInt(appSettings.gridSize || 25, 10);
            gridColor = appSettings.gridColor || '#bdc3c7';
            gridOpacity = (appSettings.gridOpacity ?? 0.3);

            // grid button UI removed

            if (refreshGrid) {
                // Recreate the grid with new settings; do not force in edit mode
                if (gridEnabled) { showGrid(); } else { hideGrid(); }
                updateConnections();
            }

            // Whenever settings are applied, reflect them into ribbon controls
            populateRibbonGridControls();
        }

        function collectSettingsFromForm(target) {
            const gridEnabledEl = document.getElementById('settingsGridEnabled');
            const snapEl = document.getElementById('settingsSnapToGrid');
            const sizeEl = document.getElementById('settingsGridSize');
            const colorEl = document.getElementById('settingsGridColor');
            const opacityEl = document.getElementById('settingsGridOpacity');

            if (gridEnabledEl) target.gridEnabled = !!gridEnabledEl.checked;
            if (snapEl) target.snapToGrid = !!snapEl.checked;
            if (sizeEl) target.gridSize = Math.max(5, Math.min(200, parseInt(sizeEl.value || '25', 10)));
            if (colorEl) target.gridColor = colorEl.value || '#bdc3c7';
            if (opacityEl) target.gridOpacity = Math.max(0, Math.min(1, parseFloat(opacityEl.value || '0.3')));
        }

        // Apply Now: apply current form values without saving to localStorage
        function applyAppSettings() {
            const temp = { ...appSettings };
            collectSettingsFromForm(temp);
            appSettings = temp;
            saveAppSettingsSilent(); // persist immediately on change
            applySettings(true);
        }

        // Initialize settings on load
        document.addEventListener('DOMContentLoaded', () => {
            loadAppSettings();
            populateRibbonGridControls();
            populateNavbarGridControls();
            populateNavbarConnectorRouting();
            // Force grid and snapping off by default (override any older saved setting)
            appSettings.gridEnabled = false;
            appSettings.snapToGrid = false;
            saveAppSettingsSilent();
            applySettings(true);
            // Grid is not auto-shown; only render if explicitly enabled (kept for completeness)
            if (gridEnabled) { showGrid(); }
            // grid button UI removed
            // Initialize color picker controls and favorites container
            try { initColorPickerControls(); renderFavoriteColors(); } catch (_) { }
            // Initialize info panel with a diagram summary
            renderDiagramSummaryInPanel();
            // Ensure Info Panel is always open
            const panel = document.getElementById('infoPanel');
            if (panel) panel.classList.add('temp-open');
            applyInfoPanelState();
            // Set initial View highlight to Diagram (edit mode)
            try { updateViewButtons('diagram'); } catch (_) { }
        });

        // Removed the Add Step (+) overlay in favor of double-clicking connection points

        async function addStepFromNode(sourceNodeId, side, newType) {
            if (!currentDiagram) return;
            const source = currentDiagram.nodes.find(n => n.id === sourceNodeId);
            if (!source) return;

            // Create a new node (default process)
            const newId = `${sourceNodeId}_step_${Date.now()}`;
            const defaultW = 120, defaultH = 60;
            const gap = Math.max(40, gridSize * 2);

            // Compute new node position relative to source node position in the DOM coordinates
            const sourceEl = document.querySelector(`[data-node-id="${sourceNodeId}"]`);
            const x = parseInt(sourceEl.style.left) || 0;
            const y = parseInt(sourceEl.style.top) || 0;
            const w = sourceEl.offsetWidth;
            const h = sourceEl.offsetHeight;
            let newLeft = x, newTop = y;
            switch (side) {
                case 'top': newLeft = x; newTop = y - gap - defaultH; break;
                case 'bottom': newLeft = x; newTop = y + h + gap; break;
                case 'left': newLeft = x - gap - defaultW; newTop = y; break;
                case 'right': newLeft = x + w + gap; newTop = y; break;
                default: newLeft = x + w + gap; newTop = y; break;
            }
            // Snap new position
            const snapped = snapToGrid ? snapToGridPosition(newLeft, newTop) : { x: newLeft, y: newTop };

            const display = document.getElementById('flowchartDisplay');
            const displayRect = display.getBoundingClientRect();
            // Convert DOM position back to diagram coordinates (+padding offset)
            const diagramX = snapped.x + 50;
            const diagramY = snapped.y + 50;

            const t = newType || (appSettings?.defaults?.node?.type || 'process');
            const newNode = {
                id: newId,
                name: 'New Step',
                type: t,
                position: { x: diagramX, y: diagramY },
                dimensions: { width: appSettings?.defaults?.node?.width ?? defaultW, height: appSettings?.defaults?.node?.height ?? defaultH },
                style: {
                    fill: appSettings?.defaults?.node?.fill || getNodeTypeColor(t),
                    stroke: appSettings?.defaults?.node?.borderColor || '#1f2937',
                    strokeWidth: appSettings?.defaults?.node?.borderWidth ?? 2
                }
            };
            currentDiagram.nodes.push(newNode);

            // Create an edge from source to new node (direction depends on side: default from source to new)
            currentDiagram.edges = currentDiagram.edges || [];
            const edge = {
                id: `${sourceNodeId}-${newId}-${Date.now()}`,
                from: sourceNodeId,
                to: newId,
                name: '',
                style: {
                    stroke: appSettings?.defaults?.edge?.stroke || '#34495e',
                    strokeWidth: appSettings?.defaults?.edge?.strokeWidth ?? 2,
                    ...(appSettings?.defaults?.edge?.strokeDasharray ? { strokeDasharray: appSettings.defaults.edge.strokeDasharray } : {})
                },
                metadata: {}
            };
            currentDiagram.edges.push(edge);

            // Re-render
            renderFlowchart(currentDiagram);
            updateConnections();
            hasUnsavedChanges = true;
            const sb1 = document.getElementById('saveButton'); if (sb1) sb1.classList.add('show');
            // Autosave when adding a connected step (creates a connector)
            scheduleAutoSave();
            // Force a silent save to ensure immediate persistence and await completion
            await saveDiagram(true, true);
            updateDiagramInfoBox();

            // Open node editor for the new step so the user can name it/configure
            const newNodeEl = document.querySelector(`[data-node-id="${newId}"]`);
            if (newNodeEl) {
                openNodeEditor(newNode, newNodeEl);
            }
        }

        // Quick Add from ribbon: adds a new node near the center if diagram is empty,
        // or adds to the right of the last selected node (if any), else near top-left.
        async function quickAddNode() {
            const typeSel = document.getElementById('insertNodeType');
            const t = typeSel ? (typeSel.value || (appSettings?.defaults?.node?.type || 'process')) : (appSettings?.defaults?.node?.type || 'process');
            if (!currentDiagram) {
                // Create a new empty diagram shell if none exists yet
                currentDiagram = { id: 'untitled', name: 'Untitled', version: '1.0.0', nodes: [], edges: [], layout: { direction: 'top-bottom' } };
            }
            const display = document.getElementById('flowchartDisplay');
            const stage = document.getElementById('diagramStage');
            const centerX = 200, centerY = 120;
            const pos = { x: centerX + 50, y: centerY + 50 };
            const id = `${t}_${Date.now()}`;
            const dims = { width: appSettings?.defaults?.node?.width ?? (t === 'decision' || t === 'start' || t === 'end' || t === 'connector' ? 100 : 120), height: appSettings?.defaults?.node?.height ?? (t === 'decision' || t === 'start' || t === 'end' || t === 'connector' ? 100 : 60) };
            const node = { id, name: 'New Step', type: t, position: pos, dimensions: dims, style: { fill: appSettings?.defaults?.node?.fill || getNodeTypeColor(t), stroke: appSettings?.defaults?.node?.borderColor || '#1f2937', strokeWidth: appSettings?.defaults?.node?.borderWidth ?? 2 } };
            currentDiagram.nodes.push(node);
            renderFlowchart(currentDiagram);
            updateConnections();
            hasUnsavedChanges = true;
            const sb2 = document.getElementById('saveButton'); if (sb2) sb2.classList.add('show');
            updateDiagramInfoBox();
            // Immediate silent autosave for quick add (force) and await completion
            await saveDiagram(true, true);
            const el = document.querySelector(`[data-node-id="${id}"]`);
            if (el) openNodeEditor(node, el);
        }

        // Double-click canvas to add a node at clicked location (respect selected type)
        document.addEventListener('DOMContentLoaded', () => {
            const display = document.getElementById('flowchartDisplay');
            display.addEventListener('dblclick', async (e) => {
                // Ignore if double-clicking an existing node or UI element
                if (e.target.closest('.node') || e.target.closest('.ribbon') || e.target.closest('.modal')) return;
                const typeSel = document.getElementById('insertNodeType');
                const t = typeSel ? (typeSel.value || (appSettings?.defaults?.node?.type || 'process')) : (appSettings?.defaults?.node?.type || 'process');
                if (!currentDiagram) currentDiagram = { id: 'untitled', name: 'Untitled', version: '1.0.0', nodes: [], edges: [], layout: { direction: 'top-bottom' } };
                const rect = display.getBoundingClientRect();
                const x = (e.clientX - rect.left) / (zoomScale || 1);
                const y = (e.clientY - rect.top) / (zoomScale || 1);
                // Convert to diagram coords (+padding)
                const pos = { x: Math.round(x) + 50, y: Math.round(y) + 50 };
                const id = `${t}_${Date.now()}`;
                const dims = { width: appSettings?.defaults?.node?.width ?? (t === 'decision' || t === 'start' || t === 'end' || t === 'connector' ? 100 : 120), height: appSettings?.defaults?.node?.height ?? (t === 'decision' || t === 'start' || t === 'end' || t === 'connector' ? 100 : 60) };
                const node = { id, name: 'New Step', type: t, position: pos, dimensions: dims, style: { fill: appSettings?.defaults?.node?.fill || getNodeTypeColor(t), stroke: appSettings?.defaults?.node?.borderColor || '#1f2937', strokeWidth: appSettings?.defaults?.node?.borderWidth ?? 2 } };
                currentDiagram.nodes.push(node);
                renderFlowchart(currentDiagram);
                updateConnections();
                hasUnsavedChanges = true;
                const sb3 = document.getElementById('saveButton'); if (sb3) sb3.classList.add('show');
                scheduleAutoSave();
                // Immediate silent autosave for canvas double-click add (force) and await completion
                await saveDiagram(true, true);
                updateDiagramInfoBox();
                const el = document.querySelector(`[data-node-id="${id}"]`);
                if (el) openNodeEditor(node, el);
            });
        });

        function calculateConnectionPoints(fromNode, toNode) {
            // Calculate the angle between the two nodes to determine best connection points
            const dx = toNode.centerX - fromNode.centerX;
            const dy = toNode.centerY - fromNode.centerY;
            const angle = Math.atan2(dy, dx);

            // Function to get actual connection point coordinates from DOM elements
            function getActualConnectionPoint(nodeId, targetAngle) {
                // Find the node element in the DOM
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (!nodeElement) {
                    return null;
                }

                // Collect connection point elements
                const connectionPoints = nodeElement.querySelectorAll('.connection-point');
                if (connectionPoints.length === 0) {
                    return null;
                }

                // Compute node center in stage/content coordinates (include container scroll)
                const displayEl = document.getElementById('flowchartDisplay');
                const displayRect = displayEl.getBoundingClientRect();
                const nodeRect = nodeElement.getBoundingClientRect();
                const nodeCX = (((nodeRect.left + nodeRect.width / 2) - displayRect.left) + displayEl.scrollLeft) / (zoomScale || 1);
                const nodeCY = (((nodeRect.top + nodeRect.height / 2) - displayRect.top) + displayEl.scrollTop) / (zoomScale || 1);

                // Choose the connector whose actual angle from the node center best matches targetAngle
                let best = null;
                let bestDiff = Infinity;
                let bestEl = null;

                connectionPoints.forEach(point => {
                    const pr = point.getBoundingClientRect();
                    const px = (((pr.left + pr.width / 2) - displayRect.left) + displayEl.scrollLeft) / (zoomScale || 1);
                    const py = (((pr.top + pr.height / 2) - displayRect.top) + displayEl.scrollTop) / (zoomScale || 1);
                    const ang = Math.atan2(py - nodeCY, px - nodeCX);
                    const diff = Math.abs(normalizeAngle(targetAngle - ang));
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        best = { x: px, y: py };
                        bestEl = point;
                    }
                });

                if (!best) {
                    return null;
                }

                return { x: best.x, y: best.y, side: bestEl?.dataset?.side };
            }

            // Helper function to normalize angle difference
            function normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }

            // Get connection points for both nodes
            const fromPoint = getActualConnectionPoint(fromNode.id, angle);
            const toPoint = getActualConnectionPoint(toNode.id, angle + Math.PI); // Opposite direction

            // Fallback to center points if connection points not found
            if (!fromPoint || !toPoint) {

                return {
                    from: { x: fromNode.centerX, y: fromNode.centerY },
                    to: { x: toNode.centerX, y: toNode.centerY }
                };
            }

            return {
                from: { x: fromPoint.x, y: fromPoint.y, side: fromPoint.side },
                to: { x: toPoint.x, y: toPoint.y, side: toPoint.side }
            };
        }

        // Return all available connection points for a node with absolute positions and side metadata
        function getNodeConnectionPoints(nodeId) {
            const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
            if (!nodeElement) return [];

            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();
            const cps = nodeElement.querySelectorAll('.connection-point');
            const out = [];
            cps.forEach(cp => {
                const pr = cp.getBoundingClientRect();
                const px = (((pr.left + pr.width / 2) - displayRect.left) + displayEl.scrollLeft) / (zoomScale || 1);
                const py = (((pr.top + pr.height / 2) - displayRect.top) + displayEl.scrollTop) / (zoomScale || 1);
                out.push({ x: px, y: py, side: cp?.dataset?.side });
            });
            return out;
        }

        function getEdgeRenderStyle(edge) {
            const user = edge.style || {};
            const tech = (edge.metadata && edge.metadata.technology) || '';
            const defaults = { stroke: '#34495e', strokeWidth: 2, strokeDasharray: undefined };
            if (tech === 'rest') {
                defaults.strokeDasharray = defaults.strokeDasharray || '6,3';
                defaults.stroke = defaults.stroke || '#2c3e50';
            } else if (tech === 'ws') {
                defaults.stroke = '#2980b9';
            } else if (tech === 'grpc') {
                defaults.stroke = '#8e44ad';
                defaults.strokeWidth = 2.5;
            }
            return {
                stroke: user.stroke || defaults.stroke,
                strokeWidth: user.strokeWidth || defaults.strokeWidth,
                strokeDasharray: user.strokeDasharray || defaults.strokeDasharray
            };
        }

        // Orthogonal pathfinding algorithm for 90-degree connector routing
        function findOrthogonalPath(x1, y1, x2, y2, nodeObstacles, fromSide, toSide) {
            const clearance = 15; // Minimum distance from node edges
            const minSegmentLength = 20; // Minimum length for perpendicular segments

            // Determine perpendicular directions based on connection sides
            const fromDirection = getPerpendicularDirection(fromSide);
            const toDirection = getPerpendicularDirection(toSide);            // Calculate the perpendicular exit points from both nodes
            const exitPoint1 = {
                x: x1 + fromDirection.x * minSegmentLength,
                y: y1 + fromDirection.y * minSegmentLength
            };
            const exitPoint2 = {
                x: x2 + toDirection.x * minSegmentLength,
                y: y2 + toDirection.y * minSegmentLength
            };

            // Try direct connection if aligned and clear
            if (canConnectDirectly(exitPoint1, exitPoint2, fromDirection, toDirection, nodeObstacles, clearance)) {
                const path = createDirectPath(x1, y1, x2, y2, exitPoint1, exitPoint2, fromDirection, toDirection);
                if (path.length >= 2) return path;
            }

            // Try L-shaped routing (minimal turns)
            const lShapedPath = createLShapedPath(x1, y1, x2, y2, fromDirection, toDirection, nodeObstacles, clearance, minSegmentLength);
            if (lShapedPath) return lShapedPath;

            // Try U-shaped routing around obstacles
            const uShapedPath = createUShapedPath(x1, y1, x2, y2, fromDirection, toDirection, nodeObstacles, clearance, minSegmentLength);
            if (uShapedPath) return uShapedPath;

            // Fallback: create a simple orthogonal path even if complex routing failed
            return createSimpleOrthogonalPath(x1, y1, x2, y2, fromDirection, toDirection, minSegmentLength);
        }

        function getPerpendicularDirection(side) {
            switch (side) {
                case 'top': return { x: 0, y: -1 };
                case 'bottom': return { x: 0, y: 1 };
                case 'left': return { x: -1, y: 0 };
                case 'right': return { x: 1, y: 0 };
                default: return { x: 1, y: 0 }; // Default to right
            }
        }

        function canConnectDirectly(point1, point2, dir1, dir2, obstacles, clearance) {
            // Check if we can make a direct orthogonal connection
            if (Math.abs(dir1.x) === Math.abs(dir2.x) && Math.abs(dir1.y) === Math.abs(dir2.y)) {
                // Same axis - check if direct line is clear
                return isSegmentClear(point1.x, point1.y, point2.x, point2.y, obstacles, clearance);
            }
            return false;
        }

        function createDirectPath(x1, y1, x2, y2, exit1, exit2, dir1, dir2) {
            // For direct connections along the same axis
            if (Math.abs(dir1.x) === Math.abs(dir2.x) && Math.abs(dir1.y) === Math.abs(dir2.y)) {
                if (Math.abs(exit1.x - exit2.x) < 5) {
                    // Vertical connection
                    return [{ x: x1, y: y1 }, { x: exit1.x, y: exit1.y }, { x: exit2.x, y: exit2.y }, { x: x2, y: y2 }];
                } else if (Math.abs(exit1.y - exit2.y) < 5) {
                    // Horizontal connection
                    return [{ x: x1, y: y1 }, { x: exit1.x, y: exit1.y }, { x: exit2.x, y: exit2.y }, { x: x2, y: y2 }];
                }
            }
            return [];
        }

        function createLShapedPath(x1, y1, x2, y2, fromDir, toDir, obstacles, clearance, minLength) {
            // Create L-shaped path with minimal turns
            const exit1 = { x: x1 + fromDir.x * minLength, y: y1 + fromDir.y * minLength };

            // Try different corner positions
            const cornerOptions = [];

            if (fromDir.x !== 0) {
                // From horizontal direction
                cornerOptions.push({ x: exit1.x, y: y2 + toDir.y * minLength });
                cornerOptions.push({ x: x2 + toDir.x * minLength, y: exit1.y });
            } else {
                // From vertical direction  
                cornerOptions.push({ x: x2 + toDir.x * minLength, y: exit1.y });
                cornerOptions.push({ x: exit1.x, y: y2 + toDir.y * minLength });
            }

            for (const corner of cornerOptions) {
                const exit2 = { x: x2 + toDir.x * minLength, y: y2 + toDir.y * minLength };
                const path = [
                    { x: x1, y: y1 },
                    { x: exit1.x, y: exit1.y },
                    { x: corner.x, y: corner.y },
                    { x: exit2.x, y: exit2.y },
                    { x: x2, y: y2 }
                ];

                if (isPathClear(path, obstacles, clearance)) {
                    return path;
                }
            }

            return null;
        }

        function createUShapedPath(x1, y1, x2, y2, fromDir, toDir, obstacles, clearance, minLength) {
            // Create U-shaped path when L-shape doesn't work
            const exit1 = { x: x1 + fromDir.x * minLength, y: y1 + fromDir.y * minLength };
            const exit2 = { x: x2 + toDir.x * minLength, y: y2 + toDir.y * minLength };

            // Find intermediate points that route around obstacles
            const midX = (exit1.x + exit2.x) / 2;
            const midY = (exit1.y + exit2.y) / 2;

            // Try routing with intermediate waypoints
            const pathOptions = [
                [
                    { x: x1, y: y1 },
                    { x: exit1.x, y: exit1.y },
                    { x: midX, y: exit1.y },
                    { x: midX, y: exit2.y },
                    { x: exit2.x, y: exit2.y },
                    { x: x2, y: y2 }
                ],
                [
                    { x: x1, y: y1 },
                    { x: exit1.x, y: exit1.y },
                    { x: exit1.x, y: midY },
                    { x: exit2.x, y: midY },
                    { x: exit2.x, y: exit2.y },
                    { x: x2, y: y2 }
                ]
            ];

            for (const path of pathOptions) {
                if (isPathClear(path, obstacles, clearance)) {
                    return path;
                }
            }

            return null;
        }

        function createSimpleOrthogonalPath(x1, y1, x2, y2, fromDirection, toDirection, minLength) {
            // Always leave and enter perpendicular to the surfaces via exit points
            const exit1 = { x: x1 + fromDirection.x * minLength, y: y1 + fromDirection.y * minLength };
            const exit2 = { x: x2 + toDirection.x * minLength, y: y2 + toDirection.y * minLength };

            // Two L-shape variants; both end with exit2 -> target to ensure perpendicular entry
            const optionA = [
                { x: x1, y: y1 },
                { x: exit1.x, y: exit1.y },
                { x: exit1.x, y: exit2.y },
                { x: exit2.x, y: exit2.y },
                { x: x2, y: y2 }
            ];
            const optionB = [
                { x: x1, y: y1 },
                { x: exit1.x, y: exit1.y },
                { x: exit2.x, y: exit1.y },
                { x: exit2.x, y: exit2.y },
                { x: x2, y: y2 }
            ];

            // Prefer the shorter Manhattan option (both are valid orthogonal paths)
            const len = (pts) => pts.reduce((acc, p, i) => i ? acc + Math.abs(p.x - pts[i - 1].x) + Math.abs(p.y - pts[i - 1].y) : 0, 0);
            return len(optionA) <= len(optionB) ? optionA : optionB;
        }

        function isPathClear(path, obstacles, clearance) {
            for (let i = 0; i < path.length - 1; i++) {
                const segment = {
                    x1: path[i].x, y1: path[i].y,
                    x2: path[i + 1].x, y2: path[i + 1].y
                };

                if (segmentIntersectsObstacles(segment, obstacles, clearance)) {
                    return false;
                }
            }
            return true;
        }

        function isSegmentClear(x1, y1, x2, y2, obstacles, clearance) {
            const segment = { x1, y1, x2, y2 };
            return !segmentIntersectsObstacles(segment, obstacles, clearance);
        }

        // --- Utilities to ensure strictly orthogonal paths ---
        function mergeColinearSegments(points) {
            if (!points || points.length < 3) return points;
            const out = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                const a = out[out.length - 1];
                const b = points[i];
                const c = points[i + 1];
                // If a-b-c are colinear horizontally or vertically, skip b
                if ((a.x === b.x && b.x === c.x) || (a.y === b.y && b.y === c.y)) {
                    continue;
                }
                out.push(b);
            }
            out.push(points[points.length - 1]);
            return out;
        }

        function removeTinySegments(points, minLen = 1.0) {
            if (!points || points.length < 2) return points;
            const out = [points[0]];
            for (let i = 1; i < points.length; i++) {
                const prev = out[out.length - 1];
                const curr = points[i];
                const dist = Math.abs(curr.x - prev.x) + Math.abs(curr.y - prev.y);
                if (dist < minLen) {
                    // Skip tiny move by overwriting the last point to current (keep continuity)
                    out[out.length - 1] = curr;
                } else {
                    out.push(curr);
                }
            }
            return out;
        }

        function normalizeOrthogonalPath(points, epsilon = 0.75) {
            if (!points || points.length < 2) return points || [];

            const snap = (v) => Math.round(v);
            const src = points.map(p => ({ x: snap(p.x), y: snap(p.y) }));

            // Rebuild path: keep endpoints fixed, insert axis-aligned joints between them
            const out = [src[0]];
            for (let i = 1; i < src.length; i++) {
                const prev = out[out.length - 1];
                const target = src[i];
                const dx = target.x - prev.x;
                const dy = target.y - prev.y;

                if (Math.abs(dx) <= epsilon && Math.abs(dy) <= epsilon) {
                    // Same point (or tiny move) → collapse
                    continue;
                }

                // Choose the dominant axis to travel first, then the other axis
                if (Math.abs(dx) <= Math.abs(dy)) {
                    // Go vertical then horizontal: (prev.x, target.y) then (target.x,target.y)
                    // But avoid duplicate points if already aligned
                    const mid = { x: prev.x, y: target.y };
                    if (!(mid.x === prev.x && mid.y === prev.y)) out.push({ x: snap(mid.x), y: snap(mid.y) });
                    if (!(target.x === out[out.length - 1].x && target.y === out[out.length - 1].y)) out.push({ x: target.x, y: target.y });
                } else {
                    // Go horizontal then vertical: (target.x, prev.y) then (target.x,target.y)
                    const mid = { x: target.x, y: prev.y };
                    if (!(mid.x === prev.x && mid.y === prev.y)) out.push({ x: snap(mid.x), y: snap(mid.y) });
                    if (!(target.x === out[out.length - 1].x && target.y === out[out.length - 1].y)) out.push({ x: target.x, y: target.y });
                }
            }

            // Cleanup
            let cleaned = removeTinySegments(out, 1.0);
            cleaned = mergeColinearSegments(cleaned);
            // Ensure last point is exactly the original last endpoint
            const last = src[src.length - 1];
            if (cleaned.length === 0 || cleaned[cleaned.length - 1].x !== last.x || cleaned[cleaned.length - 1].y !== last.y) {
                cleaned.push({ x: last.x, y: last.y });
            }
            return cleaned;
        }

        function segmentIntersectsObstacles(segment, obstacles, clearance) {
            const { x1, y1, x2, y2 } = segment;
            const minX = Math.min(x1, x2) - clearance;
            const maxX = Math.max(x1, x2) + clearance;
            const minY = Math.min(y1, y2) - clearance;
            const maxY = Math.max(y1, y2) + clearance;

            for (const obs of obstacles) {
                const obsLeft = obs.x;
                const obsRight = obs.x + obs.w;
                const obsTop = obs.y;
                const obsBottom = obs.y + obs.h;

                // Check if expanded segment rectangle intersects with obstacle
                if (maxX >= obsLeft && minX <= obsRight &&
                    maxY >= obsTop && minY <= obsBottom) {
                    return true;
                }
            }
            return false;
        }

        function routeAroundObstacles(x1, y1, x2, y2, obstacles, gap) {
            // Find obstacles that block the direct horizontal-first or vertical-first paths
            const blockingObstacles = obstacles.filter(obs => {
                const obsLeft = obs.x - gap;
                const obsRight = obs.x + obs.w + gap;
                const obsTop = obs.y - gap;
                const obsBottom = obs.y + obs.h + gap;

                // Check if obstacle blocks horizontal-first path
                const hPath = [
                    { x: x1, y: y1 },
                    { x: x2, y: y1 },
                    { x: x2, y: y2 }
                ];

                // Check if obstacle blocks vertical-first path
                const vPath = [
                    { x: x1, y: y1 },
                    { x: x1, y: y2 },
                    { x: x2, y: y2 }
                ];

                return !isPathClear(hPath, [obs], gap) || !isPathClear(vPath, [obs], gap);
            });

            if (blockingObstacles.length === 0) {
                // No blocking obstacles, use simple horizontal-first routing
                return [{ x: x1, y: y1 }, { x: x2, y: y1 }, { x: x2, y: y2 }];
            }

            // Route around the first blocking obstacle
            const obs = blockingObstacles[0];
            const obsLeft = obs.x - gap;
            const obsRight = obs.x + obs.w + gap;
            const obsTop = obs.y - gap;
            const obsBottom = obs.y + obs.h + gap;

            // Determine best routing direction based on obstacle position relative to start/end points
            const goRight = x2 > x1;
            const goDown = y2 > y1;

            let routeX, routeY;

            if (goRight) {
                routeX = obsRight;
            } else {
                routeX = obsLeft;
            }

            if (goDown) {
                routeY = obsBottom;
            } else {
                routeY = obsTop;
            }

            // Create path routing around the obstacle
            return [
                { x: x1, y: y1 },
                { x: x1, y: routeY },
                { x: routeX, y: routeY },
                { x: routeX, y: y2 },
                { x: x2, y: y2 }
            ];
        }

        function drawEdge(svg, fromNode, toNode, edge) {
            // Validate input nodes
            if (!fromNode || !toNode || !fromNode.centerX || !fromNode.centerY || !toNode.centerX || !toNode.centerY) {

                return;
            }

            // Calculate optimal connection points on the edges of the shapes
            const connectionPoints = calculateConnectionPoints(fromNode, toNode);
            const x1 = connectionPoints.from.x;
            const y1 = connectionPoints.from.y;
            const x2 = connectionPoints.to.x;
            const y2 = connectionPoints.to.y;

            // Validate connection points
            if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {

                return;
            }

            const style = getEdgeRenderStyle(edge);
            const edgeId = edge.id || `${edge.from}-${edge.to}`;

            // Determine routing mode
            const routingMode = appSettings.connectorRouting || 'straight';
            let pathPoints = [{ x: x1, y: y1 }, { x: x2, y: y2 }]; // Default to straight line

            if (routingMode === 'orthogonal') {
                // Get obstacle information for pathfinding
                const nodeObstacles = Array.from(document.querySelectorAll('#flowchartDisplay .node')).map(nodeEl => ({
                    x: parseInt(nodeEl.style.left) || 0,
                    y: parseInt(nodeEl.style.top) || 0,
                    w: nodeEl.offsetWidth,
                    h: nodeEl.offsetHeight
                }));

                // Evaluate all side combinations to pick minimal-turn, minimal-length path
                const fromCPs = getNodeConnectionPoints(fromNode.id);
                const toCPs = getNodeConnectionPoints(toNode.id);

                let best = null; // { path, from, to, turns, length }
                const prevSides = edgeRoutingState.get(edgeId) || null;
                const sideChangePenalty = draggedNode ? 60 : 30; // be stickier while dragging

                function scorePath(path, fSide, tSide) {
                    // Count turns (number of interior vertices where both dx and dy change)
                    let turns = 0;
                    for (let i = 1; i < path.length - 1; i++) {
                        const a = path[i - 1];
                        const b = path[i];
                        const c = path[i + 1];
                        const abH = (a.y === b.y);
                        const bcH = (b.y === c.y);
                        if (abH !== bcH) turns++;
                    }
                    // Manhattan length
                    let length = 0;
                    for (let i = 0; i < path.length - 1; i++) {
                        length += Math.abs(path[i + 1].x - path[i].x) + Math.abs(path[i + 1].y - path[i].y);
                    }
                    // Add hysteresis to avoid flapping between sides during drag
                    let penalty = 0;
                    if (prevSides) {
                        if (fSide && prevSides.fromSide && fSide !== prevSides.fromSide) penalty += sideChangePenalty;
                        if (tSide && prevSides.toSide && tSide !== prevSides.toSide) penalty += sideChangePenalty;
                    }
                    return { turns, length: length + penalty };
                }

                for (const f of fromCPs) {
                    for (const t of toCPs) {
                        if (!f.side || !t.side) continue;
                        const p = findOrthogonalPath(f.x, f.y, t.x, t.y, nodeObstacles, f.side, t.side);
                        if (!p || p.length < 2) continue;
                        // Ensure the path is clear of obstacles
                        if (!isPathClear(p, nodeObstacles, 15)) continue;
                        const s = scorePath(p, f.side, t.side);
                        if (!best || s.turns < best.turns || (s.turns === best.turns && s.length < best.length)) {
                            best = { path: p, from: f, to: t, ...s };
                        }
                    }
                }

                if (best) {
                    pathPoints = best.path;
                    // Persist chosen sides for stability across frames
                    edgeRoutingState.set(edgeId, { fromSide: best.from.side, toSide: best.to.side });
                } else {
                    // Fallback to previously chosen points if no combination produced a valid path
                    pathPoints = findOrthogonalPath(x1, y1, x2, y2, nodeObstacles, connectionPoints.from.side, connectionPoints.to.side);
                }
                // Normalize to strictly orthogonal segments and merge tiny/colinear segments
                pathPoints = normalizeOrthogonalPath(pathPoints);
            }

            // Helper: map technology to marker style
            function getTechMarkerSpec(techRaw) {
                const tech = (techRaw || '').toString().trim().toLowerCase();
                // Colors: WS=red, REST=yellow, HTTP=green; keep a neutral default
                const colors = {
                    ws: { fill: '#e74c3c', stroke: '#b93a2c', label: 'WS' },
                    websocket: { fill: '#e74c3c', stroke: '#b93a2c', label: 'WS' },
                    rest: { fill: '#f1c40f', stroke: '#b7950b', label: 'REST' },
                    http: { fill: '#27ae60', stroke: '#1f7a45', label: 'HTTP' },
                    https: { fill: '#27ae60', stroke: '#1f7a45', label: 'HTTP' }
                };
                const spec = colors[tech];
                if (spec) return { shape: 'rect', ...spec };
                return { shape: 'rect', fill: '#7f8c8d', stroke: '#566163', label: (tech || 'N/A').toUpperCase().slice(0, 6) };
            }

            function drawTechMarker(svgGroup, pathPoints, edge) {
                if (!edge || !edge.metadata) return;
                const tech = edge.metadata.technology;
                if (!tech || !Array.isArray(pathPoints) || pathPoints.length < 2) return;
                const spec = getTechMarkerSpec(tech);
                // Compute a midpoint and orientation: straight => segment midpoint; orth => longest segment midpoint
                let midX, midY, tx, ty, nx, ny;
                if (pathPoints.length === 2) {
                    midX = (pathPoints[0].x + pathPoints[1].x) / 2;
                    midY = (pathPoints[0].y + pathPoints[1].y) / 2;
                    const dx = pathPoints[1].x - pathPoints[0].x;
                    const dy = pathPoints[1].y - pathPoints[0].y;
                    const len = Math.max(1, Math.hypot(dx, dy));
                    tx = dx / len; ty = dy / len;
                    nx = -ty; ny = tx;
                } else {
                    // Find longest segment
                    let longest = 0; let idx = 0;
                    for (let i = 0; i < pathPoints.length - 1; i++) {
                        const dx = pathPoints[i + 1].x - pathPoints[i].x;
                        const dy = pathPoints[i + 1].y - pathPoints[i].y;
                        const l = Math.hypot(dx, dy);
                        if (l > longest) { longest = l; idx = i; }
                    }
                    const p1 = pathPoints[idx], p2 = pathPoints[idx + 1];
                    midX = (p1.x + p2.x) / 2; midY = (p1.y + p2.y) / 2;
                    const dx = p2.x - p1.x; const dy = p2.y - p1.y;
                    const len = Math.max(1, Math.hypot(dx, dy));
                    tx = dx / len; ty = dy / len; nx = -ty; ny = tx;
                }
                // Ensure normal points "below" (downward on screen)
                if (ny < 0) { nx = -nx; ny = -ny; }
                // Offset perpendicular only to place below the line; keep centered along
                const perp = 16; // px below the line
                const cx = midX + nx * perp;
                const cy = midY + ny * perp;
                // Create text first to measure and size marker with padding
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', String(cx));
                label.setAttribute('y', String(cy));
                label.setAttribute('class', 'tech-marker-label');
                label.setAttribute('data-edge-id', edge.id || `${edge.from}-${edge.to}`);
                const textColor = getContrastingTextColor(spec.fill, '#ffffff', '#1f2937');
                label.setAttribute('fill', textColor);
                const labelText = spec.label || (tech || '').toString().toUpperCase().slice(0, 4);
                label.textContent = labelText;
                // Add click handler to select connector
                label.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = label.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    selectEdge(id);
                    openEdgeEditor(id);
                });
                // Detect vertical lines and rotate label 90 degrees counter-clockwise
                const isVertical = Math.abs(tx) < 0.1; // tangent is mostly vertical
                if (isVertical) {
                    label.setAttribute('transform', `rotate(-90, ${cx}, ${cy})`);
                }
                svgGroup.appendChild(label);
                // Measure label box
                let bbox = null;
                try { bbox = label.getBBox(); } catch (_) { bbox = null; }
                let textW = bbox && bbox.width ? bbox.width : Math.max(12, labelText.length * 6);
                let textH = bbox && bbox.height ? bbox.height : 10;
                const padX = 5, padY = 3; // padding around text inside marker
                const halfW = (textW / 2) + padX;
                const halfH = (textH / 2) + padY;
                // Always draw a rectangle sized to the label + padding
                let el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                let rectW = Math.ceil(halfW * 2);
                let rectH = Math.ceil(halfH * 2);

                // For vertical connectors, swap dimensions to better fit rotated text
                if (isVertical) {
                    [rectW, rectH] = [rectH, rectW];
                }

                el.setAttribute('x', String(cx - rectW / 2));
                el.setAttribute('y', String(cy - rectH / 2));
                el.setAttribute('width', String(rectW));
                el.setAttribute('height', String(rectH));
                el.setAttribute('rx', '3');
                if (!el) return;
                el.setAttribute('class', 'tech-marker');
                el.setAttribute('data-edge-id', edge.id || `${edge.from}-${edge.to}`);
                el.setAttribute('fill', spec.fill);
                el.setAttribute('stroke', spec.stroke);
                el.setAttribute('stroke-width', '1');
                el.style.cursor = 'pointer';
                // Add click handler to select connector
                el.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = el.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    selectEdge(id);
                    openEdgeEditor(id);
                });
                // Insert shape behind the label for proper stacking
                svgGroup.insertBefore(el, label);
            }

            // Create path element(s) based on routing mode
            if (pathPoints.length === 2 && routingMode === 'straight') {
                // Simple straight line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', pathPoints[0].x);
                line.setAttribute('y1', pathPoints[0].y);
                line.setAttribute('x2', pathPoints[1].x);
                line.setAttribute('y2', pathPoints[1].y);
                line.setAttribute('class', 'connection-line');
                line.setAttribute('data-edge-id', edgeId);
                // Use inline styles to ensure they override stylesheet defaults
                line.style.stroke = style.stroke;
                line.style.strokeWidth = String(style.strokeWidth);
                if (style.strokeDasharray) line.style.strokeDasharray = String(style.strokeDasharray);
                // Interactivity
                line.style.cursor = 'pointer';
                // Invisible hit area for easier clicking
                const hit = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hit.setAttribute('x1', pathPoints[0].x);
                hit.setAttribute('y1', pathPoints[0].y);
                hit.setAttribute('x2', pathPoints[1].x);
                hit.setAttribute('y2', pathPoints[1].y);
                hit.setAttribute('data-edge-id', edgeId);
                hit.style.stroke = 'transparent';
                hit.style.strokeWidth = String(Math.max(16, (style.strokeWidth || 2) + 12));
                hit.style.pointerEvents = 'stroke';
                hit.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = hit.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    selectEdge(id);
                    openEdgeEditor(id);
                });
                line.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = line.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    // Single-click selects and opens the edge editor
                    selectEdge(id);
                    openEdgeEditor(id);
                });
                // Remove need for double-click to open editor
                svg.appendChild(hit);
                svg.appendChild(line);
            } else {
                // Multi-segment path using polyline or multiple lines
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', pathPoints[i].x);
                    line.setAttribute('y1', pathPoints[i].y);
                    line.setAttribute('x2', pathPoints[i + 1].x);
                    line.setAttribute('y2', pathPoints[i + 1].y);
                    line.setAttribute('class', 'connection-line');
                    line.setAttribute('data-edge-id', edgeId);
                    // Inline style overrides for stroke, width, and dash
                    line.style.stroke = style.stroke;
                    line.style.strokeWidth = String(style.strokeWidth);
                    if (style.strokeDasharray) line.style.strokeDasharray = String(style.strokeDasharray);
                    // Interactivity - each segment should be clickable
                    line.style.cursor = 'pointer';
                    // Invisible hit area for easier clicking on each segment
                    const hit = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    hit.setAttribute('x1', pathPoints[i].x);
                    hit.setAttribute('y1', pathPoints[i].y);
                    hit.setAttribute('x2', pathPoints[i + 1].x);
                    hit.setAttribute('y2', pathPoints[i + 1].y);
                    hit.setAttribute('data-edge-id', edgeId);
                    hit.style.stroke = 'transparent';
                    hit.style.strokeWidth = String(Math.max(16, (style.strokeWidth || 2) + 12));
                    hit.style.pointerEvents = 'stroke';
                    hit.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const id = hit.getAttribute('data-edge-id');
                        if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                        selectEdge(id);
                        openEdgeEditor(id);
                    });
                    line.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        const id = line.getAttribute('data-edge-id');
                        if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                        selectEdge(id);
                        openEdgeEditor(id);
                    });
                    // Remove need for double-click to open editor
                    svg.appendChild(hit);
                    svg.appendChild(line);
                }
            }

            // Draw a single centered technology marker below the connection
            try { drawTechMarker(svg, pathPoints, edge); } catch (_) { }


            // Add arrowhead at the end of the path
            const lastPoint = pathPoints[pathPoints.length - 1];
            let secondLastPoint = pathPoints[pathPoints.length - 2];

            // For orthogonal paths, ensure arrowhead points toward the actual connection point
            if (routingMode === 'orthogonal' && pathPoints.length > 2) {
                // Find the last segment that has significant length to get proper direction
                for (let i = pathPoints.length - 2; i >= 0; i--) {
                    const dist = Math.hypot(pathPoints[i].x - lastPoint.x, pathPoints[i].y - lastPoint.y);
                    if (dist > 5) { // Minimum distance to get meaningful direction
                        secondLastPoint = pathPoints[i];
                        break;
                    }
                }
            }

            // For orthogonal mode, quantize arrow direction to exact axis based on chosen toSide if available
            let arrowFromX = secondLastPoint.x, arrowFromY = secondLastPoint.y;
            if (routingMode === 'orthogonal') {
                const state = edgeRoutingState && edgeRoutingState.get(edgeId);
                const side = state && state.toSide ? state.toSide : null;
                if (side === 'left') {
                    // Approach left side from the left -> heading +X into the node
                    arrowFromX = lastPoint.x - 10; arrowFromY = lastPoint.y;
                } else if (side === 'right') {
                    // Approach right side from the right -> heading -X into the node
                    arrowFromX = lastPoint.x + 10; arrowFromY = lastPoint.y;
                } else if (side === 'top') {
                    // Approach top side from above -> heading +Y into the node (SVG Y grows downwards)
                    arrowFromX = lastPoint.x; arrowFromY = lastPoint.y - 10;
                } else if (side === 'bottom') {
                    // Approach bottom side from below -> heading -Y into the node
                    arrowFromX = lastPoint.x; arrowFromY = lastPoint.y + 10;
                } else {
                    // Fallback: clamp to nearest axis from computed segment
                    const dx = lastPoint.x - secondLastPoint.x;
                    const dy = lastPoint.y - secondLastPoint.y;
                    if (Math.abs(dx) >= Math.abs(dy)) {
                        // horizontal
                        arrowFromY = lastPoint.y;
                    } else {
                        // vertical
                        arrowFromX = lastPoint.x;
                    }
                }
            }

            const arrowhead = createArrowhead(svg, arrowFromX, arrowFromY, lastPoint.x, lastPoint.y, style.stroke);
            arrowhead.setAttribute('class', 'connection-arrowhead');
            arrowhead.setAttribute('data-edge-id', edgeId);
            arrowhead.setAttribute('pointer-events', 'auto');
            arrowhead.style.cursor = 'pointer';
            arrowhead.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const id = arrowhead.getAttribute('data-edge-id');
                if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                selectEdge(id);
                if (editMode) openEdgeEditor(id);
            });
            // Remove need for double-click to open editor
            svg.appendChild(arrowhead);


            // Add edge label if present
            if (edge.name) {
                // Calculate label position based on path type
                let labelMidX, labelMidY, labelLen, labelTx, labelTy, labelNx, labelNy;

                if (pathPoints.length === 2) {
                    // Straight line - use midpoint
                    labelMidX = (pathPoints[0].x + pathPoints[1].x) / 2;
                    labelMidY = (pathPoints[0].y + pathPoints[1].y) / 2;
                    const dx = pathPoints[1].x - pathPoints[0].x;
                    const dy = pathPoints[1].y - pathPoints[0].y;
                    labelLen = Math.max(1, Math.hypot(dx, dy));
                    labelTx = dx / labelLen; labelTy = dy / labelLen;
                    labelNx = -labelTy; labelNy = labelTx;
                } else {
                    // Orthogonal path - use midpoint of longest segment
                    let longestSegment = 0;
                    let longestLength = 0;

                    for (let i = 0; i < pathPoints.length - 1; i++) {
                        const dx = pathPoints[i + 1].x - pathPoints[i].x;
                        const dy = pathPoints[i + 1].y - pathPoints[i].y;
                        const segLen = Math.hypot(dx, dy);
                        if (segLen > longestLength) {
                            longestLength = segLen;
                            longestSegment = i;
                        }
                    }

                    // Use midpoint of longest segment
                    const p1 = pathPoints[longestSegment];
                    const p2 = pathPoints[longestSegment + 1];
                    labelMidX = (p1.x + p2.x) / 2;
                    labelMidY = (p1.y + p2.y) / 2;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    labelLen = Math.max(1, Math.hypot(dx, dy));
                    labelTx = dx / labelLen; labelTy = dy / labelLen;
                    labelNx = -labelTy; labelNy = labelTx;
                }

                // Create and append text first so getBBox measures correctly
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-family', 'Arial');
                text.setAttribute('font-size', '10');
                text.setAttribute('fill', '#2c3e50');
                text.setAttribute('class', 'connection-label');
                text.setAttribute('data-edge-id', edge.id || `${edge.from}-${edge.to}`);
                text.style.cursor = 'pointer';
                text.textContent = edge.name;
                // Add click handler to select connector
                text.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = text.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    selectEdge(id);
                    openEdgeEditor(id);
                });
                svg.appendChild(text);

                // Measure text to size rect
                let bbox = null;
                try { bbox = text.getBBox(); } catch (_) { bbox = null; }
                let textW = 0, textH = 0;
                if (bbox && bbox.width > 0 && bbox.height > 0) {
                    textW = bbox.width; textH = bbox.height;
                } else if (typeof text.getComputedTextLength === 'function') {
                    textW = Math.max(10, text.getComputedTextLength());
                    textH = 12; // approximate for 10px font
                } else {
                    textW = Math.max(40, (edge.name || '').length * 6);
                    textH = 12;
                }

                const padX = 6, padY = 4;
                const rectW = textW + padX * 2;
                const rectH = textH + padY * 2;

                // If we have a stored relative offset, respect it; else compute a default
                let centerX, centerY, dirX, dirY;
                const stored = edge.metadata && edge.metadata.labelOffset;
                if (stored && typeof stored.along === 'number' && typeof stored.perp === 'number') {
                    const alongPx = stored.along * labelLen;
                    const perpPx = stored.perp * labelLen;
                    centerX = labelMidX + labelTx * alongPx + labelNx * perpPx;
                    centerY = labelMidY + labelTy * alongPx + labelNy * perpPx;
                    // For nudging if needed, prefer the normal direction of the stored sign
                    const s = Math.sign(stored.perp) || 1;
                    dirX = labelNx * s; dirY = labelNy * s;
                } else {
                    // Place label on opposite side from tech marker (tech markers go "below", so labels go "above")
                    // Tech markers use positive normal (below), so use negative normal (above) for labels
                    let labelNormX = labelNx, labelNormY = labelNy;
                    // Ensure normal points "above" (upward on screen) - opposite of tech marker placement
                    if (labelNormY > 0) { labelNormX = -labelNormX; labelNormY = -labelNormY; }
                    const baseOffset = 20; // increased spacing between connector and standard edge labels
                    centerX = labelMidX + labelNormX * baseOffset;
                    centerY = labelMidY + labelNormY * baseOffset;
                    dirX = labelNormX; dirY = labelNormY;
                }

                // Initial rect position
                let rectX = centerX - rectW / 2;
                let rectY = centerY - rectH / 2;

                // Clamp within container
                const container = document.getElementById('flowchartDisplay');
                const cw = container ? container.clientWidth : 1000;
                const ch = container ? container.clientHeight : 800;
                function clamp() {
                    rectX = Math.max(2, Math.min(rectX, cw - rectW - 2));
                    rectY = Math.max(2, Math.min(rectY, ch - rectH - 2));
                }
                clamp();

                // Avoid overlapping nodes only if no manual offset exists
                const hasManual = !!(edge.metadata && edge.metadata.labelOffset);
                if (!hasManual) {
                    const nodesRects = Array.from(document.querySelectorAll('#flowchartDisplay .node')).map(n => ({
                        x: parseInt(n.style.left) || 0,
                        y: parseInt(n.style.top) || 0,
                        w: n.offsetWidth,
                        h: n.offsetHeight
                    }));
                    const pad = 6;
                    function intersectsNode(x, y, w, h) {
                        for (const r of nodesRects) {
                            const rx = r.x - pad, ry = r.y - pad, rw = r.w + pad * 2, rh = r.h + pad * 2;
                            if (x < rx + rw && x + w > rx && y < ry + rh && y + h > ry) return true;
                        }
                        return false;
                    }
                    let steps = 0;
                    while (intersectsNode(rectX, rectY, rectW, rectH) && steps < 15) {
                        rectX += dirX * 6;
                        rectY += dirY * 6;
                        clamp();
                        steps++;
                    }
                }

                // Create rect and place text centered on it
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', rectX.toString());
                rect.setAttribute('y', rectY.toString());
                rect.setAttribute('width', rectW.toString());
                rect.setAttribute('height', rectH.toString());
                rect.setAttribute('fill', 'white');
                rect.setAttribute('stroke', '#bdc3c7');
                rect.setAttribute('rx', '3');
                rect.setAttribute('class', 'connection-label-bg');
                rect.setAttribute('data-edge-id', edge.id || `${edge.from}-${edge.to}`);
                rect.setAttribute('pointer-events', 'auto');
                rect.style.cursor = 'move';
                let didDrag = false;
                rect.addEventListener('mousedown', (ev) => {
                    if (!editMode) return;
                    ev.preventDefault(); ev.stopPropagation();
                    const startX = ev.clientX, startY = ev.clientY;
                    const startRectX = parseFloat(rect.getAttribute('x'));
                    const startRectY = parseFloat(rect.getAttribute('y'));
                    function onMove(e2) {
                        didDrag = true;
                        const dxm = e2.clientX - startX;
                        const dym = e2.clientY - startY;
                        const nxX = startRectX + dxm;
                        const nyY = startRectY + dym;
                        rect.setAttribute('x', nxX.toString());
                        rect.setAttribute('y', nyY.toString());
                        text.setAttribute('x', (nxX + rectW / 2).toString());
                        text.setAttribute('y', (nyY + rectH / 2).toString());
                    }
                    function onUp(e2) {
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('mouseup', onUp);
                        if (!didDrag) return; // treat as click later
                        // Compute new center and store relative offsets in metadata
                        const nxX = parseFloat(rect.getAttribute('x'));
                        const nyY = parseFloat(rect.getAttribute('y'));
                        const cX = nxX + rectW / 2;
                        const cY = nyY + rectH / 2;
                        const dxc = cX - labelMidX;
                        const dyc = cY - labelMidY;
                        const along = dxc * labelTx + dyc * labelTy; // projection onto tangent
                        const perp = dxc * labelNx + dyc * labelNy;   // projection onto normal
                        const aRel = along / labelLen;
                        const pRel = perp / labelLen;
                        edge.metadata = edge.metadata || {};
                        edge.metadata.labelOffset = { along: aRel, perp: pRel };
                        hasUnsavedChanges = true;
                        const sb = document.getElementById('saveButton');
                        if (sb) sb.classList.add('show');
                        scheduleAutoSave();
                        // Immediate silent autosave for label position change
                        saveDiagram(true);
                        // Re-render to snap label to stored position
                        updateConnections();
                        didDrag = false;
                    }
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                });
                rect.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = rect.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    if (didDrag) { didDrag = false; return; }
                    selectEdge(id);
                    openEdgeEditor(id);
                });
                // Remove need for double-click to open editor on label background

                // Insert rect behind text and position text
                svg.insertBefore(rect, text);
                text.setAttribute('x', (rectX + rectW / 2).toString());
                text.setAttribute('y', (rectY + rectH / 2).toString());
                text.setAttribute('dominant-baseline', 'middle');
            }
        }

        function createArrowhead(svg, x1, y1, x2, y2, color) {
            // Calculate arrow direction
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 8;
            const arrowAngle = Math.PI / 6;

            // Calculate arrowhead points (positioned at the connection point)
            const endX = x2;
            const endY = y2;

            const arrowX1 = endX - arrowLength * Math.cos(angle - arrowAngle);
            const arrowY1 = endY - arrowLength * Math.sin(angle - arrowAngle);
            const arrowX2 = endX - arrowLength * Math.cos(angle + arrowAngle);
            const arrowY2 = endY - arrowLength * Math.sin(angle + arrowAngle);

            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
            polygon.setAttribute('fill', color);
            polygon.setAttribute('pointer-events', 'auto');

            return polygon;
        }

        function getNodeTypeColor(type) {
            const colors = {
                'start': '#2ecc71',
                'end': '#e74c3c',
                'process': '#3498db',
                'decision': '#f39c12',
                'data': '#9b59b6',
                'io': '#1abc9c',
                'manualInput': '#16a085',
                'subroutine': '#8e44ad',
                'database': '#2c3e50',
                'delay': '#d35400',
                'offPage': '#95a5a6',
                'connector': '#1abc9c'
            };
            return colors[type] || '#95a5a6';
        }

        // Line style mapping helpers
        function dashNameToArray(name) {
            switch ((name || 'solid').toLowerCase()) {
                case 'dotted': return '2,2';
                case 'dashed': return '6,2';
                case 'solid': default: return '';
            }
        }
        function dashArrayToName(arr) {
            const val = (arr || '').toString().trim();
            if (!val) return 'solid';
            const norm = val.replace(/\s+/g, '');
            if (norm === '2,2') return 'dotted';
            if (norm === '6,2') return 'dashed';
            // Unknown/custom values fall back to dashed for now
            return 'dashed';
        }

        // Choose readable text color against a given background
        function getContrastingTextColor(bgColor, light = '#ffffff', dark = '#1f2937') {
            if (!bgColor || typeof bgColor !== 'string') return dark;
            let c = bgColor.trim();
            // Handle rgb/rgba formats quickly: use the YIQ approximation
            let r, g, b;
            if (c.startsWith('rgb')) {
                const nums = c.replace(/rgba?\(([^)]+)\)/i, '$1').split(',').map(n => parseFloat(n.trim()));
                r = nums[0] || 0; g = nums[1] || 0; b = nums[2] || 0;
            } else {
                // Normalize hex #RGB or #RRGGBB
                if (c[0] === '#') c = c.slice(1);
                if (c.length === 3) c = c.split('').map(ch => ch + ch).join('');
                if (c.length !== 6) return dark;
                r = parseInt(c.slice(0, 2), 16);
                g = parseInt(c.slice(2, 4), 16);
                b = parseInt(c.slice(4, 6), 16);
            }
            // YIQ contrast heuristic
            const yiq = (r * 299 + g * 587 + b * 114) / 1000;
            // Prefer dark text for light backgrounds
            return yiq >= 150 ? dark : light;
        }

        // ===== Color Picker & Favorites =====
        const FAVORITE_COLORS_KEY = 'flowgen.favoriteColors';

        function getFavoriteColors() {
            try {
                const raw = localStorage.getItem(FAVORITE_COLORS_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                if (Array.isArray(arr)) return arr.filter(c => typeof c === 'string');
            } catch (_) { }
            return [];
        }

        function saveFavoriteColors(colors) {
            try { localStorage.setItem(FAVORITE_COLORS_KEY, JSON.stringify(Array.from(new Set(colors)))); } catch (_) { }
        }

        function normalizeHex(color) {
            if (!color) return '';
            let c = color.trim();
            if (c[0] !== '#') c = '#' + c;
            c = c.toUpperCase();
            if (/^#([0-9A-F]{6})$/.test(c)) return c;
            return '';
        }

        function setSelectedColor(color, opts) {
            const options = Object.assign({ applyToNode: true }, opts || {});
            const norm = normalizeHex(color);
            if (!norm) return;
            const hidden = document.getElementById('selectedColorValue');
            if (hidden) hidden.value = norm;
            const colorInput = document.getElementById('customColorInput');
            const hexInput = document.getElementById('customHexInput');
            if (colorInput) colorInput.value = norm;
            if (hexInput) hexInput.value = norm;
            // Update selection UI on all swatches
            document.querySelectorAll('#fillColorGrid .color-option, #favoriteColors .color-option')
                .forEach(el => el.classList.remove('selected'));
            // Select matching swatches if any
            document.querySelectorAll(`#fillColorGrid .color-option[data-color="${norm}"]`).forEach(el => el.classList.add('selected'));
            document.querySelectorAll(`#favoriteColors .color-option[data-color="${norm}"]`).forEach(el => el.classList.add('selected'));

            // If a node is currently being edited, apply the color immediately and autosave
            if (options.applyToNode && editingNode && editingNodeElement) {
                editingNode.style = editingNode.style || {};
                editingNode.style.fill = norm;
                try { updateNodeVisual(editingNode, editingNodeElement); } catch (_) { }
                try { updateConnections(); } catch (_) { }
                hasUnsavedChanges = true;
                const sb = document.getElementById('saveButton');
                if (sb) sb.classList.add('show');
                scheduleAutoSave();
                // Silent autosave to persist color change without UI noise
                saveDiagram(true);
            }
        }

        function renderFavoriteColors() {
            const cont = document.getElementById('favoriteColors');
            if (!cont) return;
            const favs = getFavoriteColors();
            cont.replaceChildren();
            favs.forEach(c => {
                const norm = normalizeHex(c);
                if (!norm) return;
                const sw = document.createElement('div');
                sw.className = 'color-option';
                sw.style.background = norm;
                sw.dataset.color = norm;
                sw.addEventListener('click', () => setSelectedColor(norm));
                cont.appendChild(sw);
            });
            // Maintain selection highlight if current selected color is in favorites
            const hidden = document.getElementById('selectedColorValue');
            const sel = hidden ? hidden.value : '';
            if (sel) {
                document.querySelectorAll(`#favoriteColors .color-option[data-color="${sel}"]`).forEach(el => el.classList.add('selected'));
            }
        }

        function addFavoriteColor(color) {
            const norm = normalizeHex(color);
            if (!norm) return;
            const favs = getFavoriteColors();
            if (!favs.includes(norm)) {
                favs.push(norm);
                saveFavoriteColors(favs);
                renderFavoriteColors();
            }
        }

        function removeFavoriteColor(color) {
            const norm = normalizeHex(color);
            const favs = getFavoriteColors().filter(c => normalizeHex(c) !== norm);
            saveFavoriteColors(favs);
            renderFavoriteColors();
        }

        function initColorPickerControls() {
            if (window._colorPickerInited) return;
            window._colorPickerInited = true;
            const colorInput = document.getElementById('customColorInput');
            const hexInput = document.getElementById('customHexInput');
            const favBtn = document.getElementById('addFavoriteColorBtn');
            if (colorInput) {
                colorInput.addEventListener('input', (e) => {
                    const v = e.target.value;
                    if (/^#([0-9A-Fa-f]{6})$/.test(v)) setSelectedColor(v);
                });
            }
            if (hexInput) {
                hexInput.addEventListener('input', (e) => {
                    let v = (e.target.value || '').trim();
                    if (/^#?[0-9A-Fa-f]{6}$/.test(v)) {
                        if (v[0] !== '#') v = '#' + v;
                        setSelectedColor(v);
                    }
                });
            }
            if (favBtn) {
                favBtn.addEventListener('click', () => {
                    const hidden = document.getElementById('selectedColorValue');
                    const v = hidden ? hidden.value : '';
                    const color = normalizeHex(v || (colorInput ? colorInput.value : ''));
                    if (color) addFavoriteColor(color);
                });
            }
        }

        // Inline editor for edge labels: overlays a small input over the label rect
        function openInlineEdgeLabelEditor(edgeId) {
            if (!edgeId || !currentDiagram) return;
            const display = document.getElementById('flowchartDisplay');
            const svg = display.querySelector('svg.connections-layer');
            if (!svg) return;
            const rect = svg.querySelector(`rect.connection-label-bg[data-edge-id="${edgeId}"]`);
            if (!rect) return;
            const existing = display.querySelector('.edge-label-input');
            if (existing) existing.remove();

            // Compute absolute position of rect
            const rectBox = rect.getBoundingClientRect();
            const hostBox = display.getBoundingClientRect();
            // Include scroll so overlay matches content coordinates even when scrolled/zoomed
            const left = (rectBox.left - hostBox.left) + display.scrollLeft;
            const top = (rectBox.top - hostBox.top) + display.scrollTop;
            const width = rectBox.width;
            const height = rectBox.height;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edge-label-input';
            input.value = (currentDiagram.edges.find(e => (e.id || `${e.from}-${e.to}`) === edgeId)?.name) || '';
            Object.assign(input.style, {
                position: 'absolute',
                left: `${left}px`,
                top: `${top}px`,
                width: `${Math.max(60, width)}px`,
                height: `${height}px`,
                padding: '2px 6px',
                border: '1px solid #3498db',
                borderRadius: '3px',
                fontFamily: 'Arial, sans-serif',
                fontSize: '11px',
                zIndex: '2000',
                boxSizing: 'border-box'
            });

            function commit(save) {
                const el = input;
                const val = el.value.trim();
                el.remove();
                if (!save) return;
                const edge = currentDiagram.edges.find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
                if (!edge) return;
                edge.name = val;
                hasUnsavedChanges = true;
                const sb = document.getElementById('saveButton');
                if (sb) sb.classList.add('show');
                scheduleAutoSave();
                // Immediate silent autosave for label text edit
                saveDiagram(true);
                updateConnections();
            }

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') commit(true);
                else if (e.key === 'Escape') commit(false);
            });
            input.addEventListener('blur', () => commit(true));

            display.appendChild(input);
            input.focus();
            input.select();
        }

        function showNodeInfo(node) {
            let info = `Node: ${node.name || 'Unnamed'}\\nType: ${node.type}\\nPosition: (${node.position.x}, ${node.position.y})`;

            if (node.integrations?.jira) {
                info += `\\nJira: ${node.integrations.jira.projectKey}-${node.integrations.jira.issueKey}`;
            }
            if (node.drillDown) {
                info += `\\nDrill-down: ${node.drillDown}`;
            }

            alert(info);
        }

        function renderSVG() {
            if (!currentDiagram) {
                alert('Please load a diagram first');
                return;
            }

            const display = document.getElementById('flowchartDisplay');
            const svg = createSVG(currentDiagram);
            display.innerHTML = '';
            const stage = document.createElement('div');
            stage.id = 'diagramStage';
            stage.style.position = 'absolute';
            stage.style.inset = '0';
            stage.style.transformOrigin = '0 0';
            stage.innerHTML = svg;
            display.appendChild(stage);
            applyZoom();
            isRenderMode = true;
            updateDiagramInfoBox();
        }

        function renderEditable() {
            if (!currentDiagram) {
                alert('Please load a diagram first');
                return;
            }
            // Re-render the interactive editor
            renderFlowchart(currentDiagram);
            updateConnections();
            showMessage('Returned to edit mode', 'info');
            isRenderMode = false;
            updateDiagramInfoBox();
        }


        function createSVG(diagram) {
            // Enhanced SVG generation with proper connections
            const width = 1000;
            const height = 800;
            let svgContent = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
                    </marker>
                </defs>`;

            // Find bounds and normalize positions
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            diagram.nodes.forEach(node => {
                minX = Math.min(minX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxX = Math.max(maxX, node.position.x + (node.dimensions?.width || 100));
                maxY = Math.max(maxY, node.position.y + (node.dimensions?.height || 50));
            });

            const padding = 50;
            const scaleX = (width - 2 * padding) / (maxX - minX);
            const scaleY = (height - 2 * padding) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down

            // Create node position map for edges
            const nodePositions = {};
            diagram.nodes.forEach(node => {
                const x = (node.position.x - minX) * scale + padding;
                const y = (node.position.y - minY) * scale + padding;
                const width = (node.dimensions?.width || 100) * scale;
                const height = (node.dimensions?.height || 50) * scale;
                nodePositions[node.id] = {
                    x, y, width, height,
                    centerX: x + width / 2,
                    centerY: y + height / 2
                };
            });

            // Add edges first (behind nodes)
            if (diagram.edges) {
                diagram.edges.forEach(edge => {
                    const fromNode = nodePositions[edge.from];
                    const toNode = nodePositions[edge.to];

                    if (fromNode && toNode) {
                        const strokeColor = edge.style?.stroke || '#34495e';
                        const strokeWidth = edge.style?.strokeWidth || 2;
                        const strokeDash = edge.style?.strokeDasharray || '';

                        svgContent += `
                            <line x1="${fromNode.centerX}" y1="${fromNode.centerY}" 
                                  x2="${toNode.centerX}" y2="${toNode.centerY}" 
                                  stroke="${strokeColor}" stroke-width="${strokeWidth}" 
                                  ${strokeDash ? `stroke-dasharray="${strokeDash}"` : ''}
                                  marker-end="url(#arrowhead)"/>
                        `;

                        // Add edge label with minimal margin from shapes/line
                        if (edge.name) {
                            const midX = (fromNode.centerX + toNode.centerX) / 2;
                            const midY = (fromNode.centerY + toNode.centerY) / 2;
                            const label = String(edge.name);
                            const approxCharW = 7; // px approximation
                            const fontSize = 11;
                            const padX = 8;
                            const padY = 4;
                            const textW = Math.max(10, label.length * approxCharW);
                            const rectW = Math.min(Math.max(40, textW + padX * 2), width - 10);
                            const rectH = fontSize + padY * 2; // ~19px

                            // Compute edge basis vectors
                            const dx = toNode.centerX - fromNode.centerX;
                            const dy = toNode.centerY - fromNode.centerY;
                            const len = Math.max(1, Math.hypot(dx, dy));
                            const tx = dx / len, ty = dy / len;
                            const nx = -ty, ny = tx;
                            const nx2 = -nx, ny2 = -ny;
                            const baseOffset = 10;
                            function minDistToNodes(cx, cy) {
                                const d1 = Math.hypot(cx - fromNode.centerX, cy - fromNode.centerY);
                                const d2 = Math.hypot(cx - toNode.centerX, cy - toNode.centerY);
                                return Math.min(d1, d2);
                            }
                            let centerX, centerY, dirX, dirY;
                            const stored = edge.metadata && edge.metadata.labelOffset;
                            if (stored && typeof stored.along === 'number' && typeof stored.perp === 'number') {
                                const alongPx = stored.along * len;
                                const perpPx = stored.perp * len;
                                centerX = midX + tx * alongPx + nx * perpPx;
                                centerY = midY + ty * alongPx + ny * perpPx;
                                const s = Math.sign(stored.perp) || 1;
                                dirX = nx * s; dirY = ny * s;
                            } else {
                                const cand1 = { cx: midX + nx * baseOffset, cy: midY + ny * baseOffset };
                                const cand2 = { cx: midX + nx2 * baseOffset, cy: midY + ny2 * baseOffset };
                                const pick1 = minDistToNodes(cand1.cx, cand1.cy);
                                const pick2 = minDistToNodes(cand2.cx, cand2.cy);
                                const useFirst = pick1 >= pick2;
                                centerX = useFirst ? cand1.cx : cand2.cx;
                                centerY = useFirst ? cand1.cy : cand2.cy;
                                dirX = useFirst ? nx : nx2;
                                dirY = useFirst ? ny : ny2;
                            }

                            let rectX = centerX - rectW / 2;
                            let rectY = centerY - rectH / 2;
                            // Clamp to canvas
                            function clamp() {
                                rectX = Math.max(5, Math.min(rectX, width - rectW - 5));
                                rectY = Math.max(5, Math.min(rectY, height - rectH - 5));
                            }
                            clamp();

                            // Avoid overlapping nodes: nudge along normal
                            const pad = 6;
                            function intersectsNode(x, y, w, h) {
                                for (const id in nodePositions) {
                                    const n = nodePositions[id];
                                    const rx = n.x - pad, ry = n.y - pad, rw = n.width + pad * 2, rh = n.height + pad * 2;
                                    if (x < rx + rw && x + w > rx && y < ry + rh && y + h > ry) return true;
                                }
                                return false;
                            }
                            let steps = 0;
                            while (intersectsNode(rectX, rectY, rectW, rectH) && steps < 15) {
                                rectX += dirX * 6;
                                rectY += dirY * 6;
                                clamp();
                                steps++;
                            }

                            const textX = rectX + rectW / 2;
                            const textY = rectY + rectH / 2;

                            svgContent += `
                                <rect x="${rectX}" y="${rectY}" width="${rectW}" height="${rectH}" 
                                      fill="white" fill-opacity="0.95" stroke="#bdc3c7" rx="4"/>
                                <text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                                      font-family="Arial" font-size="${fontSize}" fill="#2c3e50">${label}</text>
                            `;
                        }
                    }
                });
            }

            // Add nodes (on top of edges)
            diagram.nodes.forEach(node => {
                const pos = nodePositions[node.id];
                if (!pos) return;

                const fill = node.style?.fill || getNodeTypeColor(node.type);
                const textFill = node.style?.textColor || getContrastingTextColor(fill);
                const stroke = node.style?.stroke || '#333';

                // Different shapes for different node types
                if (node.type === 'decision') {
                    // Diamond shape for decisions
                    const cx = pos.centerX;
                    const cy = pos.centerY;
                    const size = Math.min(pos.width, pos.height) / 2;
                    svgContent += `
                        <polygon points="${cx},${cy - size} ${cx + size},${cy} ${cx},${cy + size} ${cx - size},${cy}" 
                                 fill="${fill}" stroke="${stroke}" stroke-width="2"/>
                    `;
                } else if (node.type === 'start' || node.type === 'end') {
                    // Ellipse for start/end
                    svgContent += `
                        <ellipse cx="${pos.centerX}" cy="${pos.centerY}" 
                                 rx="${pos.width / 2}" ry="${pos.height / 2}" 
                                 fill="${fill}" stroke="${stroke}" stroke-width="2"/>
                    `;
                } else {
                    // Rectangle for process nodes
                    svgContent += `
                        <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}" 
                              fill="${fill}" stroke="${stroke}" stroke-width="2" rx="8"/>
                    `;
                }

                // Add node text with wrapping support
                const textContent = node.name || 'Node';
                if (textContent.length > 20 && textContent.includes(' ')) {
                    // Multi-line text for long content
                    const words = textContent.split(' ');
                    const maxCharsPerLine = 15;
                    const lines = [];
                    let currentLine = '';
                    for (const word of words) {
                        if ((currentLine + word).length <= maxCharsPerLine || currentLine === '') {
                            currentLine += (currentLine === '' ? '' : ' ') + word;
                        } else {
                            lines.push(currentLine);
                            currentLine = word;
                        }
                    }
                    if (currentLine) lines.push(currentLine);
                    // Render multiple lines
                    const lineHeight = 14;
                    const startY = pos.centerY - ((lines.length - 1) * lineHeight / 2);
                    lines.forEach((line, index) => {
                        svgContent += `
                            <text x="${pos.centerX}" y="${startY + index * lineHeight}" 
                                  text-anchor="middle" font-family="Arial" font-size="12" fill="${textFill}" font-weight="bold">
                                ${line}
                            </text>
                        `;
                    });
                } else {
                    // Single line text
                    svgContent += `
                        <text x="${pos.centerX}" y="${pos.centerY + 5}" 
                              text-anchor="middle" font-family="Arial" font-size="12" fill="${textFill}" font-weight="bold">
                            ${textContent}
                        </text>
                    `;
                }

                // Add integration indicators
                if (node.integrations?.jira) {
                    svgContent += `
                        <circle cx="${pos.x + pos.width - 8}" cy="${pos.y + 8}" r="6" 
                                fill="#0052CC" stroke="white" stroke-width="1"/>
                        <text x="${pos.x + pos.width - 8}" y="${pos.y + 12}" 
                              text-anchor="middle" font-family="Arial" font-size="8" fill="white" font-weight="bold">
                            J
                        </text>
                    `;
                }
                if (node.drillDown) {
                    svgContent += `
                        <circle cx="${pos.x + pos.width - 8}" cy="${pos.y + pos.height - 8}" r="6" 
                                fill="#9b59b6" stroke="white" stroke-width="1"/>
                        <text x="${pos.x + pos.width - 8}" y="${pos.y + pos.height - 4}" 
                              text-anchor="middle" font-family="Arial" font-size="10" fill="white" font-weight="bold">
                            ↓
                        </text>
                    `;
                }
            });

            svgContent += `</svg>`;
            return svgContent;
        }

        // showJSON removed per UX change

        function clearDisplay() {
            const display = document.getElementById('flowchartDisplay');
            // Clearing the canvas means no active diagram; reset last-opened state
            try { localStorage.removeItem(LAST_DIAGRAM_KEY); } catch (_) { }
            const tpl = document.getElementById('emptyStateTemplate');
            if (display && tpl) {
                display.innerHTML = '';
                display.appendChild(tpl.content.cloneNode(true));
            } else if (display) {
                display.innerHTML = '<div class="loading">Open or create a diagram to get started</div>';
            }
        }

        // Auto-load on page load
        window.onload = () => {
            // Clicking on the background clears selection and hides labels
            const container = document.getElementById('flowchartDisplay');
            if (container) {
                container.addEventListener('mousedown', (e) => {
                    if (!e.target.closest('.node')) {
                        setSelectedNode(null);
                        clearEdgeSelection();
                        // Removed: add-step overlay cleanup (deprecated)
                        // Close editor if user clicks on empty canvas area
                        if (editorDocked) closeNodeEditor();
                        // Do not clear info panel body here; keep last info until next hover/selection
                    }
                });
            }
            // Apply any restored zoom to update the UI label immediately
            applyZoom();
            // Ensure grid overlay/snapping are applied
            updateGridSettings();
            // Initialize sections: show diagram by default
            switchMainSection('diagram');
            // Try to auto-load the last opened diagram if present; otherwise show empty state
            const display = document.getElementById('flowchartDisplay');
            const tpl = document.getElementById('emptyStateTemplate');
            const lastId = getLastOpenedDiagramId && getLastOpenedDiagramId();
            if (lastId) {
                if (display) display.innerHTML = '<div class="loading">Loading last diagram…</div>';
                (async () => {
                    try {
                        const res = await fetch(`http://localhost:3001/api/v1/diagrams/${encodeURIComponent(lastId)}`);
                        if (!res.ok) throw new Error(`Failed to load last diagram (${res.status})`);
                        const diag = await res.json();
                        currentDiagram = normalizeDiagramNumbers(diag);
                        renderFlowchart(currentDiagram);
                        updateConnections();
                        updateDiagramInfoBox();
                        showMessage(`Restored diagram: ${diag.name || diag.id}`, 'success');
                    } catch (e) {
                        // If auto-load fails, clear the remembered ID and show empty state
                        try { localStorage.removeItem(LAST_DIAGRAM_KEY); } catch (_) { }
                        if (display && tpl) {
                            display.innerHTML = '';
                            display.appendChild(tpl.content.cloneNode(true));
                        } else if (display) {
                            display.innerHTML = '<div class="loading">Open or create a diagram to get started</div>';
                        }
                        console.warn('Auto-load last diagram failed:', e);
                    }
                })();
            } else {
                if (display && tpl) {
                    display.innerHTML = '';
                    display.appendChild(tpl.content.cloneNode(true));
                }
            }
        };

        // Ensure numeric fields (x, y, width, height, rotation, strokeWidth) are numbers, not strings
        function normalizeDiagramNumbers(diagram) {
            if (!diagram) return diagram;
            const out = JSON.parse(JSON.stringify(diagram));
            try {
                if (Array.isArray(out.nodes)) {
                    out.nodes.forEach(n => {
                        if (!n.position) n.position = { x: 0, y: 0 };
                        n.position.x = Number(n.position.x) || 0;
                        n.position.y = Number(n.position.y) || 0;
                        if (!n.dimensions) n.dimensions = { width: 100, height: 50 };
                        n.dimensions.width = Number(n.dimensions.width) || 0;
                        n.dimensions.height = Number(n.dimensions.height) || 0;
                        if (n.rotation != null) n.rotation = Number(n.rotation) || 0;
                        if (n.style && n.style.strokeWidth != null) {
                            n.style.strokeWidth = Number(n.style.strokeWidth) || 0;
                        }
                    });
                }
                if (Array.isArray(out.edges)) {
                    out.edges.forEach(e => {
                        if (e?.style?.strokeWidth != null) e.style.strokeWidth = Number(e.style.strokeWidth) || 0;
                    });
                }
            } catch (_) { }
            return out;
        }

        function getDiagramForSave(diagram) {
            const normalized = normalizeDiagramNumbers(diagram);
            return normalized;
        }
    </script>
</body>

</html>