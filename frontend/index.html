<!DOCTYPE html>
<html lang="en">

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FlowGen - Display Flowchart</title>
<!-- Bootstrap CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<!-- App styles -->
<link rel="stylesheet" href="/static/styles/app.css" />
</head>

<body>
    <!-- Modern flat Navbar -->
    <nav class="navbar" id="appNavbar">
        <a href="#" class="nav-brand" onclick="return false;">
            <span class="nav-logo" aria-label="FlowGen logo"></span>
            FlowGen
        </a>
        <div class="nav-section">
            <div class="nav-dropdown" id="navFileDd">
                <button class="nav-btn" onclick="toggleNavDropdown(event, 'navFileDd')">File ‚ñæ</button>
                <div class="nav-dropdown-menu">
                    <div class="nav-menu-item" onclick="openNewDiagramModal()">New‚Ä¶</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="openOpenDiagramModal()">Open‚Ä¶</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="saveDiagram(false, true)">Save</div>
                    <div class="nav-menu-item" onclick="openSaveAsModal()">Save As‚Ä¶</div>
                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" onclick="closeDiagram()">Close</div>
                </div>
            </div>
            <a class="nav-link" id="navViewDiagram" onclick="switchView('diagram')">Diagram</a>
            <a class="nav-link" id="navViewRender" onclick="switchView('render')">Render</a>
            <a class="nav-link" id="navViewRaw" onclick="switchView('raw')">Raw Data</a>

            <div class="nav-dropdown" id="navLayoutDd">
                <button class="nav-btn" onclick="toggleNavDropdown(event, 'navLayoutDd')">Layout ‚ñæ</button>
                <div class="nav-dropdown-menu">
                    <div class="nav-menu-item" onclick="alignDiagram()">Align Diagram</div>
                    <div class="nav-sep"></div>

                    <div class="nav-sep"></div>
                    <div class="nav-menu-item" style="cursor:default;">
                        <label style="font-size:12px;color:#6b7280;display:block;margin-bottom:6px;">Info Panel</label>
                        <label style="display:flex;align-items:center;gap:8px;padding:4px 0;cursor:pointer;">
                            <input type="radio" name="navInfoPanelMode" id="navInfoModeAuto" value="auto"
                                onchange="onNavbarInfoPanelModeChange(event)" />
                            <span>Auto-open on hover</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:8px;padding:4px 0;cursor:pointer;">
                            <input type="radio" name="navInfoPanelMode" id="navInfoModeLocked" value="locked"
                                onchange="onNavbarInfoPanelModeChange(event)" />
                            <span>Locked open</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        <div class="nav-spacer"></div>
        <div class="nav-section">
            <button class="nav-btn primary" id="navbarSaveBtn" onclick="saveDiagram(false, true)">Save</button>
        </div>
    </nav>
    <div class="container-fluid p-3">
        <!-- Diagram Tab Content -->
        <div id="diagramTab" class="main-tab-content active">
            <div class="diagram-layout">
                <div class="diagram-main">
                    <div class="flowchart-container">
                        <div id="flowchartDisplay">
                            <div class="loading">Click "Load Diagram" to display the flowchart</div>
                        </div>
                        <!-- Compact Zoom overlay -->

                        <div class="zoom-overlay " id="zoomOverlay">
                            <button class="btn btn-sm btn-outline-secondary" onclick="zoomOut()"
                                title="Zoom out">-</button>
                            <div class="zoom-level"> <span id="zoomLevelLabel">100%</span> </div>
                            <button class="btn btn-sm btn-outline-secondary" onclick="zoomIn()"
                                title="Zoom in">+</button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="zoomReset()"
                                title="Reset zoom to 100%">100%</button>
                        </div>
                    </div>
                </div>
                <aside class="info-panel" id="infoPanel" aria-live="polite">
                    <div class="info-panel-header">
                        <div>
                            <div id="infoTitle" class="info-title">Diagram Details</div>
                            <div id="infoSubtitle" class="info-subtitle"></div>
                        </div>
                    </div>
                    <div id="infoPanelBody" class="info-section"></div>
                </aside>
            </div>
        </div>

        <!-- Configuration Tab Content -->
        <div id="configurationTab" class="main-tab-content">
            <div class="yaml-controls">
                <button class="btn btn-sm btn-outline-secondary" onclick="loadYamlConfig()">üì• Load YAML</button>
                <button class="btn btn-sm btn-outline-secondary" onclick="saveYamlConfig()">üíæ Save YAML</button>
                <button class="btn btn-sm btn-outline-secondary" onclick="validateYaml()">‚úÖ Validate</button>
                <button class="btn btn-sm btn-outline-primary" onclick="applyYamlChanges()">üîÑ Apply Changes</button>
            </div>

            <div class="yaml-container">
                <h3>YAML Configuration</h3>
                <textarea id="yamlEditor" class="yaml-editor" placeholder="Loading YAML configuration..."></textarea>
                <div id="yamlStatus" class="yaml-status" style="display: none;"></div>
            </div>
        </div>



        <!-- Node Editor Modal -->
        <div id="nodeEditor" class="node-editor">
            <h3 class="editor-header">‚úèÔ∏è Edit Node</h3>

            <div class="accordion" id="nodeEditorAccordion">
                <!-- Basic -->
                <div class="accordion-item">
                    <h2 class="accordion-header" id="headingBasic">
                        <button class="accordion-button" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseBasic" aria-expanded="true" aria-controls="collapseBasic">üìù
                            Basic</button>
                    </h2>
                    <div id="collapseBasic" class="accordion-collapse collapse show" aria-labelledby="headingBasic">
                        <div class="accordion-body">
                            <div class="editor-group">
                                <label for="nodeName">Name:</label>
                                <input type="text" id="nodeName" placeholder="Enter node name">
                            </div>
                            <div class="editor-group">
                                <label for="nodeType">Type & Shape:</label>
                                <select id="nodeType" onchange="updateShapePreview()">
                                    <option value="process">üì¶ Process (Rectangle)</option>
                                    <option value="start">üü¢ Start (Circle)</option>
                                    <option value="end">üî¥ End (Circle)</option>
                                    <option value="decision">üíé Decision (Diamond)</option>
                                    <option value="data">üìä Data (Hexagon)</option>
                                    <option value="connector">üîó Connector (Circle)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Style -->
                <div class="accordion-item">
                    <h2 class="accordion-header" id="headingStyle">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseStyle" aria-expanded="false" aria-controls="collapseStyle">üé®
                            Style</button>
                    </h2>
                    <div id="collapseStyle" class="accordion-collapse collapse" aria-labelledby="headingStyle">
                        <div class="accordion-body">
                            <div class="editor-group">
                                <label>Fill Color:</label>
                                <div class="color-grid" id="fillColorGrid">
                                    <div class="color-option" style="background: #2ecc71" data-color="#2ecc71"></div>
                                    <div class="color-option" style="background: #3498db" data-color="#3498db"></div>
                                    <div class="color-option" style="background: #9b59b6" data-color="#9b59b6"></div>
                                    <div class="color-option" style="background: #f39c12" data-color="#f39c12"></div>
                                    <div class="color-option" style="background: #e74c3c" data-color="#e74c3c"></div>
                                    <div class="color-option" style="background: #1abc9c" data-color="#1abc9c"></div>
                                    <div class="color-option" style="background: #34495e" data-color="#34495e"></div>
                                    <div class="color-option" style="background: #95a5a6" data-color="#95a5a6"></div>
                                    <div class="color-option" style="background: #16a085" data-color="#16a085"></div>
                                    <div class="color-option" style="background: #8e44ad" data-color="#8e44ad"></div>
                                    <div class="color-option" style="background: #d35400" data-color="#d35400"></div>
                                    <div class="color-option" style="background: #c0392b" data-color="#c0392b"></div>
                                    <div class="color-option" style="background: #27ae60" data-color="#27ae60"></div>
                                    <div class="color-option" style="background: #2980b9" data-color="#2980b9"></div>
                                    <div class="color-option" style="background: #8e44ad" data-color="#8e44ad"></div>
                                    <div class="color-option" style="background: #f1c40f" data-color="#f1c40f"></div>
                                </div>
                            </div>
                            <div class="editor-group">
                                <label>Custom Color:</label>
                                <div style="display:flex; align-items:center; gap:10px; flex-wrap: wrap;">
                                    <input type="color" id="customColorInput"
                                        style="width:40px; height:32px; padding:0; border:none; background:transparent;" />
                                    <input type="text" id="customHexInput" placeholder="#RRGGBB"
                                        style="width:110px; padding:6px 8px;" />
                                    <button class="btn btn-sm btn-outline-secondary" id="addFavoriteColorBtn"
                                        type="button">‚≠ê Add to
                                        Favorites</button>
                                    <input type="hidden" id="selectedColorValue" />
                                </div>
                            </div>
                            <div class="editor-group">
                                <label>Favorites:</label>
                                <div id="favoriteColors" class="color-grid"></div>
                            </div>
                            <div class="editor-group">
                                <label for="nodeRotation">Rotation:</label>
                                <input type="range" id="nodeRotation" min="0" max="360" step="15" value="0"
                                    oninput="updateRotationPreview()">
                                <span id="rotationValue">0¬∞</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Text -->
                <div class="accordion-item">
                    <h2 class="accordion-header" id="headingText">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseText" aria-expanded="false" aria-controls="collapseText">üìç
                            Text</button>
                    </h2>
                    <div id="collapseText" class="accordion-collapse collapse" aria-labelledby="headingText">
                        <div class="accordion-body">
                            <div class="editor-group">
                                <label>Text Position:</label>
                                <div class="text-position-grid">
                                    <button type="button" class="text-position-btn" data-h="flex-start"
                                        data-v="flex-start" title="Top Left">‚ÜñÔ∏è</button>
                                    <button type="button" class="text-position-btn" data-h="center" data-v="flex-start"
                                        title="Top Center">‚¨ÜÔ∏è</button>
                                    <button type="button" class="text-position-btn" data-h="flex-end"
                                        data-v="flex-start" title="Top Right">‚ÜóÔ∏è</button>
                                    <button type="button" class="text-position-btn" data-h="flex-start" data-v="center"
                                        title="Middle Left">‚¨ÖÔ∏è</button>
                                    <button type="button" class="text-position-btn" data-h="center" data-v="center"
                                        title="Middle Center" data-default="true">üéØ</button>
                                    <button type="button" class="text-position-btn" data-h="flex-end" data-v="center"
                                        title="Middle Right">‚û°Ô∏è</button>
                                    <button type="button" class="text-position-btn" data-h="flex-start"
                                        data-v="flex-end" title="Bottom Left">‚ÜôÔ∏è</button>
                                    <button type="button" class="text-position-btn" data-h="center" data-v="flex-end"
                                        title="Bottom Center">‚¨áÔ∏è</button>
                                    <button type="button" class="text-position-btn" data-h="flex-end" data-v="flex-end"
                                        title="Bottom Right">‚ÜòÔ∏è</button>
                                </div>
                            </div>
                            <div class="editor-group">
                                <label for="textAlign">Text Alignment:</label>
                                <select id="textAlign">
                                    <option value="left">‚Üê Left</option>
                                    <option value="center" selected>‚¨å Center</option>
                                    <option value="right">‚Üí Right</option>
                                    <option value="justify">‚ñ¢ Justify</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Size -->
                <div class="accordion-item">
                    <h2 class="accordion-header" id="headingSize">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                            data-bs-target="#collapseSize" aria-expanded="false" aria-controls="collapseSize">üìè
                            Size</button>
                    </h2>
                    <div id="collapseSize" class="accordion-collapse collapse" aria-labelledby="headingSize">
                        <div class="accordion-body">
                            <div class="compact-row">
                                <div class="editor-group">
                                    <label for="nodeWidth">Width (px):</label>
                                    <input type="number" id="nodeWidth" min="50" max="300" step="10" value="100">
                                </div>
                                <div class="editor-group">
                                    <label for="nodeHeight">Height (px):</label>
                                    <input type="number" id="nodeHeight" min="30" max="200" step="10" value="50">
                                </div>
                            </div>
                            <div class="editor-group">
                                <label>Quick Sizes:</label>
                                <div class="d-flex gap-1 mt-1">
                                    <button type="button" class="btn btn-sm btn-outline-secondary"
                                        onclick="setSize(80, 40)">Small</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary"
                                        onclick="setSize(100, 50)">Medium</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary"
                                        onclick="setSize(140, 70)">Large</button>
                                    <button type="button" class="btn btn-sm btn-outline-secondary"
                                        onclick="setSize(100, 100)">Square</button>
                                </div>
                            </div>
                            <div class="editor-group">
                                <label>Auto-Resize:</label>
                                <div style="font-size: 10px; color: #7f8c8d; margin-top: 3px;">Text now auto-sizes the
                                    node while you type</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="editor-buttons">
                <button class="btn btn-danger" onclick="confirmDeleteCurrentNode()">Delete</button>
            </div>
        </div>

        <!-- Edge Editor Modal -->
        <div id="edgeEditor" class="node-editor" style="display:none;">
            <h3 class="editor-header">üîó Edit Connector</h3>
            <div class="editor-content">
                <div class="editor-group">
                    <label for="edgeName">Label:</label>
                    <input type="text" id="edgeName" placeholder="e.g. calls, publishes" />
                </div>
                <div class="compact-row">
                    <div class="editor-group">
                        <label for="edgeTechnology">Technology:</label>
                        <select id="edgeTechnology">
                            <option value="">‚Äî None ‚Äî</option>
                            <option value="rest">REST</option>
                            <option value="ws">WebSocket</option>
                            <option value="grpc">gRPC</option>
                        </select>
                    </div>

                    <div class="editor-group">
                        <label for="edgeWidth">Width (px):</label>
                        <input type="number" id="edgeWidth" min="1" max="10" step="1" value="2" />
                    </div>
                </div>
                <div class="compact-row">
                    <div class="editor-group">
                        <label for="edgeStroke">Stroke Color:</label>
                        <input type="color" id="edgeStroke" value="#34495e" />
                    </div>
                    <div class="editor-group">
                        <label for="edgeDash">Dash Pattern:</label>
                        <input type="text" id="edgeDash" placeholder="e.g. 4,2 for dashed" />
                    </div>
                </div>
                <div style="font-size: 11px; color:#7f8c8d;">Tip: Double-click a connector to open this editor. Click a
                    connector then press Delete to remove.</div>
            </div>
            <div class="editor-buttons">
                <button class="btn btn-danger" onclick="deleteEdgeFromEditor()">Delete</button>
            </div>
        </div>

    </div>

    <!-- Bootstrap JS bundle (for any future Bootstrap components we might use) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>

    <!-- New Diagram Modal -->
    <div id="newDiagramModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üÜï New Diagram</div>
            <div class="modal-body">
                <div class="editor-group">
                    <label for="newDiagramId">ID (file name):</label>
                    <input type="text" id="newDiagramId" placeholder="e.g. my_new_diagram" />
                </div>
                <div class="editor-group">
                    <label for="newDiagramName">Name:</label>
                    <input type="text" id="newDiagramName" placeholder="Diagram name" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeNewDiagramModal()">Cancel</button>
                <button class="btn-save" onclick="createNewDiagram()">Create</button>
            </div>
        </div>
    </div>

    <!-- Open Diagram Modal -->
    <div id="openDiagramModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üìÇ Open Diagram</div>
            <div class="modal-body">
                <div id="openDiagramList">Loading‚Ä¶</div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeOpenDiagramModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Save As Modal -->
    <div id="saveAsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üíæ Save As</div>
            <div class="modal-body">
                <div class="editor-group">
                    <label for="saveAsId">New ID (file name):</label>
                    <input type="text" id="saveAsId" placeholder="e.g. my_new_copy" />
                </div>
                <div class="editor-group">
                    <label for="saveAsName">Name:</label>
                    <input type="text" id="saveAsName" placeholder="Diagram name" />
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeSaveAsModal()">Cancel</button>
                <button class="btn-save" onclick="performSaveAs()">Save</button>
            </div>
        </div>
    </div>

    <!-- In-canvas Empty State -->
    <template id="emptyStateTemplate">
        <div class="empty-state">
            <div class="empty-state-card">
                <div class="empty-state-icon">üìä</div>
                <div class="empty-state-title">Welcome to FlowGen</div>
                <div class="empty-state-desc">Open an existing diagram or create a new one to get started.</div>
                <div class="empty-state-actions">
                    <button class="btn-outline" onclick="openOpenDiagramModal()">üìÇ Open</button>
                    <button class="btn-solid" onclick="openNewDiagramModal()">üÜï New Diagram</button>
                </div>
            </div>
        </div>
    </template>

    <script>
        let currentDiagram = null;
        let editMode = true;
        // Track whether we are showing a static SVG render (true) or interactive editor (false)
        let isRenderMode = false;
        // Zoom state
        let zoomScale = 1.0; // 100%
        const ZOOM_MIN = 0.25, ZOOM_MAX = 2.5, ZOOM_STEP = 0.1;
        // Restore persisted zoom if available
        try {
            const savedZoom = parseFloat(localStorage.getItem('flowgen.zoomScale'));
            if (!Number.isNaN(savedZoom)) {
                zoomScale = Math.min(Math.max(savedZoom, ZOOM_MIN), ZOOM_MAX);
            }
        } catch (_) { }
        let draggedNode = null;
        let nodeOffset = { x: 0, y: 0 };
        let dragUpdateTimer = null;
        let isUpdatingConnections = false;
        let hasUnsavedChanges = false;
        let editingNode = null;
        let editingNodeElement = null;
        // Node editor docking state
        let editorDocked = false;

        // Grid and Layout Settings
        let gridEnabled = false;
        // Runtime-only flag to remember if we forced the grid on due to Edit Mode
        let gridForcedByEdit = false;
        let snapToGrid = false;
        let gridSize = 25;
        let gridSvg = null;
        // Grid visual customization
        let gridColor = '#bdc3c7';
        let gridOpacity = 0.3;
        let selectedNodeElement = null;
        let selectedEdgeId = null;
        // Edge creation state: { sourceNodeId, sourceSide, startX, startY, previewLine }
        let edgeCreation = null;

        // Last opened diagram persistence
        const LAST_DIAGRAM_KEY = 'flowgen.lastDiagramId';
        function setLastOpenedDiagramId(id) {
            try { localStorage.setItem(LAST_DIAGRAM_KEY, id || ''); } catch (_) { }
        }

        // ======= Navbar handlers =======
        function toggleNavDropdown(event, id) {
            event.stopPropagation();
            const dd = document.getElementById(id);
            if (!dd) return;
            const isOpen = dd.classList.contains('open');
            document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
            if (!isOpen) dd.classList.add('open');
        }
        document.addEventListener('click', () => {
            document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                document.querySelectorAll('.nav-dropdown').forEach(el => el.classList.remove('open'));
            }
        });

        // Keep navbar grid controls in sync with app settings
        function populateNavbarGridControls() {
            const snapEl = document.getElementById('navGridSnap');
            const sizeEl = document.getElementById('navGridSize');
            const colorEl = document.getElementById('navGridColor');
            const opacityEl = document.getElementById('navGridOpacity');
            if (snapEl) snapEl.checked = !!appSettings.snapToGrid;
            if (sizeEl) sizeEl.value = appSettings.gridSize;
            if (colorEl) colorEl.value = appSettings.gridColor || '#bdc3c7';
            if (opacityEl) opacityEl.value = appSettings.gridOpacity ?? 0.3;
        }
        function applyNavbarGridChange() {
            const snapEl = document.getElementById('navGridSnap');
            const sizeEl = document.getElementById('navGridSize');
            const colorEl = document.getElementById('navGridColor');
            const opacityEl = document.getElementById('navGridOpacity');
            if (snapEl) appSettings.snapToGrid = !!snapEl.checked;
            if (sizeEl) appSettings.gridSize = Math.max(5, Math.min(200, parseInt(sizeEl.value || '25', 10)));
            if (colorEl) appSettings.gridColor = colorEl.value || '#bdc3c7';
            if (opacityEl) appSettings.gridOpacity = Math.max(0, Math.min(1, parseFloat(opacityEl.value || '0.3')));
            saveAppSettingsSilent();
            applySettings(true);
            populateRibbonGridControls();
        }

        // Quick add from navbar using its dropdown selection
        function quickAddFromNavbar() {
            const navSel = document.getElementById('navInsertType');
            const insertSel = document.getElementById('insertNodeType');
            if (insertSel && navSel) insertSel.value = navSel.value;
            quickAddNode();
            // close dropdown after action
            const dd = document.getElementById('navInsertDd');
            if (dd) dd.classList.remove('open');
        }

        function openSaveAsModal() {
            const idEl = document.getElementById('saveAsId');
            const nameEl = document.getElementById('saveAsName');
            if (currentDiagram) {
                idEl.value = `${currentDiagram.id || 'diagram'}_copy`;
                nameEl.value = `${currentDiagram.name || 'Diagram'} (copy)`;
            } else {
                idEl.value = '';
                nameEl.value = '';
            }
            document.getElementById('saveAsModal').style.display = 'flex';
        }
        function closeSaveAsModal() { document.getElementById('saveAsModal').style.display = 'none'; }

        async function performSaveAs() {
            const newId = (document.getElementById('saveAsId').value || '').trim();
            const newName = (document.getElementById('saveAsName').value || '').trim();
            if (!newId) { showMessage('Please enter a new ID', 'error'); return; }
            if (!currentDiagram) { showMessage('No diagram to save', 'error'); return; }
            const copy = JSON.parse(JSON.stringify(getDiagramForSave(currentDiagram)));
            copy.id = newId;
            copy.name = newName || copy.name || newId;
            try {
                const res = await fetch('http://localhost:3001/api/v1/diagrams', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(copy)
                });
                if (!res.ok) { const err = await res.text(); throw new Error(err || 'Save As failed'); }
                closeSaveAsModal();
                const created = await res.json();
                currentDiagram = normalizeDiagramNumbers(created);
                setLastOpenedDiagramId(created.id);
                renderFlowchart(currentDiagram);
                updateConnections();
                updateDiagramInfoBox();
                hasUnsavedChanges = false; const sb = document.getElementById('saveButton'); if (sb) sb.classList.remove('show');
                showMessage('Saved a copy', 'success');
            } catch (e) {
                showMessage(`Save As failed: ${e.message}`, 'error');
            }
        }

        function closeDiagram() {
            currentDiagram = null;
            try { localStorage.removeItem(LAST_DIAGRAM_KEY); } catch (_) { }
            const display = document.getElementById('flowchartDisplay');
            const tpl = document.getElementById('emptyStateTemplate');
            if (display && tpl) {
                display.innerHTML = '';
                display.appendChild(tpl.content.cloneNode(true));
            }
            updateDiagramInfoBox();
            clearInfoPanelBody();
            // Ensure node editor is closed if docked
            if (editorDocked) closeNodeEditor();
            const sb = document.getElementById('saveButton'); if (sb) sb.classList.remove('show');
        }
        function getLastOpenedDiagramId() {
            try { return localStorage.getItem(LAST_DIAGRAM_KEY) || ''; } catch (_) { return ''; }
        }

        // Always-on Edit Mode flag
        const ALWAYS_EDIT_MODE = true;
        function activateRibbonTab(name) {
            document.querySelectorAll('.ribbon-tab-btn').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.querySelector(`.ribbon-tab-btn[data-tab="${name}"]`);
            if (activeBtn) activeBtn.classList.add('active');
            document.querySelectorAll('.ribbon-tab-pane').forEach(p => p.style.display = 'none');
            const pane = document.getElementById(`ribbon-tab-${name}`);
            if (pane) pane.style.display = 'block';
        }

        // New: switch main app sections via ribbon tabs
        function switchMainSection(section) {
            // Show section content (diagram and configuration are content areas)
            ['diagram', 'configuration'].forEach(name => {
                const el = document.getElementById(name + 'Tab');
                if (el) el.style.display = (name === section ? 'block' : 'none');
            });
            // Show/hide main action groups; View group stays visible for toggling
            const fileGroup = document.getElementById('fileRibbonGroup');
            const layoutGroup = document.getElementById('layoutRibbonGroup');
            const viewGroup = document.getElementById('viewRibbonGroup');
            // Keep File group (with Save) visible for both Diagram and Raw Data views
            if (fileGroup) fileGroup.style.display = 'block';
            // Layout actions are only relevant in the Diagram view
            if (layoutGroup) layoutGroup.style.display = (section === 'diagram' ? 'block' : 'none');
            if (viewGroup) viewGroup.style.display = 'block';

            // Sync View button active states
            updateViewButtons(section);
            // Lazy-load YAML when switching to raw view
            if (section === 'configuration') {
                loadYamlConfig();
            }
        }

        // View switcher maps to top-level sections and updates button state
        function switchView(view) {
            if (view === 'diagram') {
                // Ensure we're in the diagram section with interactive editor
                switchMainSection('diagram');
                if (isRenderMode) {
                    renderEditable();
                } else {
                    // If nothing is rendered yet, ensure editor is visible
                    if (currentDiagram) {
                        renderFlowchart(currentDiagram);
                        updateConnections();
                        updateGridSettings();
                    }
                }
                updateViewButtons('diagram');
            } else if (view === 'render') {
                // Render static SVG in the diagram area
                switchMainSection('diagram');
                renderSVG();
                updateViewButtons('diagram');
            } else if (view === 'raw') {
                // Switch to YAML editor
                switchMainSection('configuration');
                updateViewButtons('configuration');
            }
        }

        function updateViewButtons(section) {
            const diagBtn = document.getElementById('viewDiagramBtn');
            const renderBtn = document.getElementById('viewRenderBtn');
            const rawBtn = document.getElementById('viewRawBtn');
            const navDiag = document.getElementById('navViewDiagram');
            const navRender = document.getElementById('navViewRender');
            const navRaw = document.getElementById('navViewRaw');
            if (diagBtn && renderBtn && rawBtn) {
                const inDiagramSection = section === 'diagram';
                const inRaw = section === 'configuration';
                diagBtn.classList.toggle('active', inDiagramSection && !isRenderMode);
                renderBtn.classList.toggle('active', inDiagramSection && isRenderMode);
                rawBtn.classList.toggle('active', inRaw);
            }
            // Sync navbar links
            if (navDiag && navRender && navRaw) {
                const inDiagramSection = section === 'diagram';
                const inRaw = section === 'configuration';
                navDiag.classList.toggle('active', inDiagramSection && !isRenderMode);
                navRender.classList.toggle('active', inDiagramSection && isRenderMode);
                navRaw.classList.toggle('active', inRaw);
            }
        }

        // ======= Slide-out Info Panel controls =======
        let infoPanelHover = false;
        let infoPanelCloseTimer = null;
        function applyInfoPanelState() {
            const panel = document.getElementById('infoPanel');
            const layout = document.querySelector('.diagram-layout');
            if (!panel) return;
            const tempOpen = panel.classList.contains('temp-open');
            const mode = (appSettings.infoPanelMode || 'auto');
            const isOpen = mode === 'locked' ? true : tempOpen;
            panel.classList.toggle('collapsed', !isOpen);
            panel.setAttribute('aria-hidden', String(!isOpen));
            if (layout) layout.classList.toggle('no-info-gap', !isOpen);
            // No handle/toggle element; state is purely visual and via navbar mode
        }
        function openInfoPanelTemp() {
            const panel = document.getElementById('infoPanel');
            if (!panel) return;
            if ((appSettings.infoPanelMode || 'auto') === 'locked') {
                // Already open in locked mode; nothing to do
            } else {
                panel.classList.add('temp-open');
            }
            applyInfoPanelState();
        }
        function maybeCloseInfoPanelTemp() {
            const panel = document.getElementById('infoPanel');
            if (!panel) return;
            if (editorDocked) return;
            if ((appSettings.infoPanelMode || 'auto') === 'locked') return;
            // Only close if not hovering a node or the panel
            if (!hoveredNodeEl && !infoPanelHover) {
                panel.classList.remove('temp-open');
                applyInfoPanelState();
            }
        }
        // toggleInfoPanel() removed with toggle handle
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize info panel state on load
            applyInfoPanelState();
            // Track hover to avoid collapsing while interacting with the panel
            const panel = document.getElementById('infoPanel');
            if (panel) {
                panel.addEventListener('mouseenter', () => { infoPanelHover = true; if (infoPanelCloseTimer) { clearTimeout(infoPanelCloseTimer); infoPanelCloseTimer = null; } });
                panel.addEventListener('mouseleave', () => {
                    infoPanelHover = false;
                    if (infoPanelCloseTimer) clearTimeout(infoPanelCloseTimer);
                    infoPanelCloseTimer = setTimeout(() => { maybeCloseInfoPanelTemp(); }, 150);
                });
            }

            // Keep connectors aligned on viewport changes and container scroll
            const display = document.getElementById('flowchartDisplay');
            if (display) {
                display.addEventListener('scroll', () => {
                    // Debounce minimal ‚Äî connectors are quick to redraw
                    try { updateConnections(); } catch (_) { }
                });
            }
            window.addEventListener('resize', () => {
                try { updateConnections(); } catch (_) { }
            });
        });
        function setSelectedNode(nodeEl) {
            if (selectedNodeElement === nodeEl) return;
            selectedNodeElement = nodeEl;
        }


        // Old switchMainTab removed; ribbon now controls sections via switchMainSection

        // YAML Configuration functions
        function getActiveDiagramId() {
            return (currentDiagram && currentDiagram.id) ? currentDiagram.id : 'my_process_flow';
        }
        async function loadYamlConfig() {
            const yamlEditor = document.getElementById('yamlEditor');
            const yamlStatus = document.getElementById('yamlStatus');

            try {
                yamlEditor.value = 'Loading YAML configuration...';
                yamlStatus.style.display = 'none';

                const response = await fetch(`http://localhost:3001/api/v1/diagrams/${getActiveDiagramId()}/yaml`);
                if (response.ok) {
                    const yamlText = await response.text();
                    yamlEditor.value = yamlText;
                    showYamlStatus('YAML configuration loaded successfully', 'success');
                } else {
                    throw new Error(`Failed to load YAML: ${response.status}`);
                }
            } catch (error) {
                console.error('Error loading YAML:', error);
                yamlEditor.value = '# Error loading YAML configuration\n# Please check if the backend server is running';
                showYamlStatus(`Error loading YAML: ${error.message}`, 'error');
            }
        }

        async function saveYamlConfig() {
            const yamlEditor = document.getElementById('yamlEditor');
            const yamlContent = yamlEditor.value;

            try {
                const response = await fetch(`http://localhost:3001/api/v1/diagrams/${getActiveDiagramId()}/yaml`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: yamlContent
                });

                if (response.ok) {
                    showYamlStatus('YAML configuration saved successfully', 'success');
                } else {
                    throw new Error(`Failed to save YAML: ${response.status}`);
                }
            } catch (error) {
                console.error('Error saving YAML:', error);
                showYamlStatus(`Error saving YAML: ${error.message}`, 'error');
            }
        }

        function validateYaml() {
            const yamlEditor = document.getElementById('yamlEditor');
            const yamlContent = yamlEditor.value;

            try {
                // Basic YAML validation - check for common syntax issues
                const lines = yamlContent.split('\n');
                let hasErrors = false;
                let errorMessage = '';

                lines.forEach((line, index) => {
                    // Check for tabs (YAML should use spaces)
                    if (line.includes('\t')) {
                        hasErrors = true;
                        errorMessage = `Line ${index + 1}: YAML should use spaces, not tabs`;
                        return;
                    }

                    // Check for basic syntax issues
                    if (line.trim().length > 0 && !line.trim().startsWith('#')) {
                        const colonIndex = line.indexOf(':');
                        if (colonIndex > 0) {
                            const afterColon = line.substring(colonIndex + 1);
                            if (afterColon.length > 0 && !afterColon.startsWith(' ')) {
                                hasErrors = true;
                                errorMessage = `Line ${index + 1}: Space required after colon`;
                                return;
                            }
                        }
                    }
                });

                if (hasErrors) {
                    showYamlStatus(`YAML validation failed: ${errorMessage}`, 'error');
                } else {
                    showYamlStatus('YAML validation passed - syntax looks good', 'success');
                }
            } catch (error) {
                showYamlStatus(`YAML validation error: ${error.message}`, 'error');
            }
        }

        async function applyYamlChanges() {
            // First save the YAML
            await saveYamlConfig();

            // Then reload the diagram to reflect changes
            await loadDiagram();
            updateDiagramInfoBox();

            // Switch back to diagram tab to see changes
            switchMainSection('diagram');

            showMessage('YAML changes applied and diagram reloaded', 'success');
        }

        function showYamlStatus(message, type) {
            const yamlStatus = document.getElementById('yamlStatus');
            yamlStatus.textContent = message;
            yamlStatus.className = `yaml-status ${type}`;
            yamlStatus.style.display = 'block';

            // Auto-hide after 5 seconds
            setTimeout(() => {
                yamlStatus.style.display = 'none';
            }, 5000);
        }

        async function loadDiagram() {
            const display = document.getElementById('flowchartDisplay');
            display.innerHTML = '<div class="loading">Loading diagram...</div>';

            try {

                const response = await fetch('http://localhost:3001/api/v1/diagrams');
                const data = await response.json();


                if (data.diagrams && data.diagrams.length > 0) {
                    currentDiagram = normalizeDiagramNumbers(data.diagrams[0]); // Use first diagram and normalize

                    renderFlowchart(currentDiagram);
                    updateDiagramInfoBox();
                } else {
                    display.innerHTML = '<div class="loading">No diagrams found</div>';
                    currentDiagram = null;
                    updateDiagramInfoBox();
                }
            } catch (error) {
                console.error('Error loading diagram:', error);
                display.innerHTML = `<div style="color: red;">Error loading diagram: ${error.message}</div>`;
                currentDiagram = null;
                updateDiagramInfoBox();
            }
        }

        // ======= New/Open Diagram =======
        function openNewDiagramModal() {
            document.getElementById('newDiagramId').value = '';
            document.getElementById('newDiagramName').value = '';
            document.getElementById('newDiagramModal').style.display = 'flex';
        }
        function closeNewDiagramModal() { document.getElementById('newDiagramModal').style.display = 'none'; }

        async function createNewDiagram() {
            const id = (document.getElementById('newDiagramId').value || '').trim();
            const name = (document.getElementById('newDiagramName').value || '').trim();
            if (!id) { showMessage('Please enter an ID for the diagram', 'error'); return; }
            const payload = {
                id, name: name || id,
                version: '1.0.0',
                nodes: [], edges: [],
                layout: { direction: 'top-bottom', spacing: { node: 50, rank: 100 } }
            };
            try {
                const res = await fetch('http://localhost:3001/api/v1/diagrams', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                });
                if (!res.ok) { const err = await res.text(); throw new Error(err || 'Failed to create'); }
                closeNewDiagramModal();
                // Load newly created diagram explicitly
                const created = await res.json();
                currentDiagram = created;
                setLastOpenedDiagramId(created.id);
                renderFlowchart(currentDiagram);
                updateConnections();
                updateDiagramInfoBox();
                showMessage('New diagram created', 'success');
            } catch (e) {
                showMessage(`Create failed: ${e.message}`, 'error');
            }
        }

        function openOpenDiagramModal() {
            const modal = document.getElementById('openDiagramModal');
            const list = document.getElementById('openDiagramList');
            list.innerHTML = 'Loading‚Ä¶';
            modal.style.display = 'flex';
            fetch('http://localhost:3001/api/v1/diagrams')
                .then(r => r.json())
                .then(data => {
                    const diagrams = data.diagrams || [];
                    if (!diagrams.length) { list.innerHTML = '<div>No diagrams found</div>'; return; }
                    const ul = document.createElement('ul'); ul.style.listStyle = 'none'; ul.style.padding = '0';
                    diagrams.forEach(d => {
                        const li = document.createElement('li'); li.style.padding = '6px 0';
                        const a = document.createElement('a'); a.href = '#'; a.textContent = `${d.name} (${d.id})`;
                        a.onclick = (ev) => { ev.preventDefault(); selectDiagram(d.id); };
                        li.appendChild(a); ul.appendChild(li);
                    });
                    list.replaceChildren(ul);
                })
                .catch(err => { list.innerHTML = `<div style="color:red;">Error: ${err.message}</div>`; });
        }
        function closeOpenDiagramModal() { document.getElementById('openDiagramModal').style.display = 'none'; }

        async function selectDiagram(id) {
            try {
                const res = await fetch(`http://localhost:3001/api/v1/diagrams/${id}`);
                if (!res.ok) throw new Error('Failed to load diagram');
                const diag = await res.json();
                currentDiagram = normalizeDiagramNumbers(diag);
                setLastOpenedDiagramId(diag.id || id);
                renderFlowchart(currentDiagram);
                updateConnections();
                closeOpenDiagramModal();
                showMessage(`Opened diagram: ${diag.name}`, 'success');
                updateDiagramInfoBox();
            } catch (e) {
                showMessage(`Open failed: ${e.message}`, 'error');
            }
        }

        function toggleEditMode() {
            if (ALWAYS_EDIT_MODE) {
                showMessage('Edit Mode is always on', 'info');
                return;
            }
            editMode = !editMode;
            const btn = document.getElementById('editModeBtn');
            const nodes = document.querySelectorAll('.node');

            if (editMode) {
                if (btn) { btn.textContent = 'üîí View Mode'; btn.style.background = '#e74c3c'; }
                nodes.forEach(node => {
                    node.style.cursor = 'move';
                    enableDragging(node);
                });
                // Do not force grid visible while in edit mode anymore
                showMessage('Edit Mode: Drag to move, Double-click to edit, Right-click for options. Delete nodes via the editor.', 'info');
            } else {
                if (btn) { btn.textContent = '‚úèÔ∏è Edit Mode'; btn.style.background = '#3498db'; }
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    disableDragging(node);
                });
                // No special grid forcing while leaving edit mode
                closeNodeEditor(); // Close editor when exiting edit mode
                showMessage('View Mode: Click nodes for info', 'info');
            }
        }

        function enableDragging(nodeEl) {
            nodeEl.addEventListener('mousedown', handleMouseDown);
            nodeEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        }

        function disableDragging(nodeEl) {
            nodeEl.removeEventListener('mousedown', handleMouseDown);
            nodeEl.removeEventListener('touchstart', handleTouchStart);
        }

        function handleMouseDown(e) {
            if (!editMode) return;
            e.preventDefault();
            e.stopPropagation(); // Prevent conflicts with other handlers
            startDrag(e.target.closest('.node'), e.clientX, e.clientY);
        }

        function handleTouchStart(e) {
            if (!editMode) return;
            e.preventDefault();
            const touch = e.touches[0];
            startDrag(e.target.closest('.node'), touch.clientX, touch.clientY);
        }

        function startDrag(element, clientX, clientY) {
            if (!element || !element.classList.contains('node')) return;

            draggedNode = element;
            draggedNode.classList.add('dragging');

            // Remember original position to detect actual movement
            draggedNode.dataset.origLeft = String(parseInt(draggedNode.style.left) || 0);
            draggedNode.dataset.origTop = String(parseInt(draggedNode.style.top) || 0);

            const rect = draggedNode.getBoundingClientRect();

            nodeOffset.x = clientX - rect.left;
            nodeOffset.y = clientY - rect.top;

            // Add global event listeners
            document.addEventListener('mousemove', handleMouseMove, { passive: false });
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);

            // Disable text selection during drag
            document.body.style.userSelect = 'none';
        }

        function handleMouseMove(e) {
            if (!draggedNode && !edgeCreation) return;
            e.preventDefault();
            e.stopPropagation();
            if (draggedNode) updateNodePosition(e.clientX, e.clientY);
            if (edgeCreation) updateEdgeCreationPreview(e.clientX, e.clientY);
        }

        function handleTouchMove(e) {
            if (!draggedNode && !edgeCreation) return;
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            if (draggedNode) updateNodePosition(touch.clientX, touch.clientY);
            if (edgeCreation) updateEdgeCreationPreview(touch.clientX, touch.clientY);
        }

        function updateNodePosition(clientX, clientY) {
            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();

            // Account for container scroll when converting to stage/content coordinates
            let newX = ((clientX - displayRect.left) + displayEl.scrollLeft - nodeOffset.x) / zoomScale;
            let newY = ((clientY - displayRect.top) + displayEl.scrollTop - nodeOffset.y) / zoomScale;

            // Apply snap-to-grid (diamonds by center) with tolerance for smoother dragging
            if (snapToGrid && draggedNode) {
                const snapped = snapNodePosition(draggedNode, newX, newY, true);
                newX = snapped.x;
                newY = snapped.y;
            }

            // Constrain within container
            const maxX = ((displayRect.width + displayEl.scrollWidth - displayEl.clientWidth) / zoomScale) - draggedNode.offsetWidth;
            const maxY = ((displayRect.height + displayEl.scrollHeight - displayEl.clientHeight) / zoomScale) - draggedNode.offsetHeight;

            const constrainedX = Math.max(0, Math.min(newX, maxX));
            const constrainedY = Math.max(0, Math.min(newY, maxY));

            draggedNode.style.left = constrainedX + 'px';
            draggedNode.style.top = constrainedY + 'px';

            // Update connection point labels in real-time during drag
            // Labels removed; info panel updates elsewhere

            // Update connections in real-time during drag for better visual feedback
            // Cancel any pending update
            if (dragUpdateTimer) {
                clearTimeout(dragUpdateTimer);
                dragUpdateTimer = null;
            }

            // Update immediately if not already updating
            if (!isUpdatingConnections) {
                updateConnections();
            }
        }

        function handleMouseUp(e) {
            finishDrag();
            if (edgeCreation) finishEdgeCreation(e);
        }

        function handleTouchEnd(e) {
            finishDrag();
            if (edgeCreation) finishEdgeCreation(e.changedTouches && e.changedTouches[0]);
        }

        function finishDrag() {
            if (!draggedNode) return;
            // Work with a stable reference; we may null out draggedNode later
            const dn = draggedNode;

            dn.classList.remove('dragging');

            // Apply final snap-to-grid if enabled (diamonds by center)
            if (snapToGrid) {
                // Use style-based coordinates (unaffected by rotation) to avoid jumpy behavior
                const currentX = parseInt(dn.style.left) || 0;
                const currentY = parseInt(dn.style.top) || 0;
                const snapped = snapNodePosition(dn, currentX, currentY, false);
                dn.style.left = snapped.x + 'px';
                dn.style.top = snapped.y + 'px';
            }

            // Update the diagram data
            updateDiagramData();

            // On-canvas labels removed; info panel will update via hover/zoom hooks

            // Update connections one final time
            updateConnections();

            // Clean up
            if (dragUpdateTimer) {
                clearTimeout(dragUpdateTimer);
                dragUpdateTimer = null;
            }
            // Do not null yet; we still need to compare orig vs new below

            // Remove global event listeners
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);

            // Re-enable text selection
            document.body.style.userSelect = '';

            // If position actually changed, mark dirty and autosave
            const origLeft = parseInt(dn.dataset.origLeft || '0');
            const origTop = parseInt(dn.dataset.origTop || '0');
            const newLeft = parseInt(dn.style.left) || 0;
            const newTop = parseInt(dn.style.top) || 0;
            // Cleanup stored originals
            delete dn.dataset.origLeft;
            delete dn.dataset.origTop;

            if (origLeft !== newLeft || origTop !== newTop) {
                hasUnsavedChanges = true;
                const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                scheduleAutoSave();
                // Immediate silent autosave for position changes
                saveDiagram(true);
            }
            // Now that we're done, clear the global
            draggedNode = null;
        }

        function updateDiagramData() {
            if (!currentDiagram) return;

            const nodes = document.querySelectorAll('.node');
            const display = document.getElementById('flowchartDisplay');

            nodes.forEach((nodeEl, index) => {
                const nodeId = nodeEl.dataset.nodeId;
                const node = currentDiagram.nodes.find(n => n.id === nodeId);

                if (node) {
                    // Convert back to original coordinate system
                    const rect = nodeEl.getBoundingClientRect();
                    const displayRect = display.getBoundingClientRect();

                    node.position.x = parseInt(nodeEl.style.left) + 50; // Add back padding offset
                    node.position.y = parseInt(nodeEl.style.top) + 50;
                }
            });
        }

        function updateConnections() {
            if (!currentDiagram || !currentDiagram.edges) return;

            // Prevent concurrent updates that could cause multiple lines
            if (isUpdatingConnections) return;
            isUpdatingConnections = true;

            const display = document.getElementById('flowchartDisplay');
            if (!display) { isUpdatingConnections = false; return; }
            const stage = document.getElementById('diagramStage') || display;

            try {
                // Ensure we have exactly one connections-layer SVG and one edges-layer group
                let svg = stage.querySelector('svg.connections-layer');
                if (!svg) {
                    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.className = 'connections-layer';
                    svg.style.position = 'absolute';
                    svg.style.top = '0';
                    svg.style.left = '0';
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.zIndex = '1';
                    svg.style.pointerEvents = 'auto';
                    stage.appendChild(svg);
                }
                let edgesGroup = svg.querySelector('g.edges-layer');
                if (!edgesGroup) {
                    edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    edgesGroup.setAttribute('class', 'edges-layer');
                    svg.appendChild(edgesGroup);
                }

                // Clear only our drawn edges, preserve previews/other overlays
                edgesGroup.querySelectorAll('line.connection-line, polygon.connection-arrowhead, text.connection-label, rect.connection-label-bg').forEach(el => el.remove());

                // Rebuild connections with new positions
                const nodePositions = {};
                const nodes = document.querySelectorAll('.node');



                nodes.forEach(nodeEl => {
                    const nodeId = nodeEl.dataset.nodeId;
                    if (!nodeId) return; // Skip nodes without IDs

                    // Get position from element's style (more reliable than getBoundingClientRect)
                    const x = parseInt(nodeEl.style.left) || 0;
                    const y = parseInt(nodeEl.style.top) || 0;
                    const width = nodeEl.offsetWidth;
                    const height = nodeEl.offsetHeight;



                    // Validate coordinates - skip if invalid
                    if (isNaN(x) || isNaN(y) || width === 0 || height === 0) {

                        return;
                    }

                    // Find the node data to get the type
                    const nodeData = currentDiagram.nodes.find(n => n.id === nodeId);
                    const nodeType = nodeData ? nodeData.type : 'process';

                    nodePositions[nodeId] = {
                        id: nodeId,  // Add the node ID so calculateConnectionPoints can find the DOM element
                        x: x,
                        y: y,
                        centerX: x + width / 2,
                        centerY: y + height / 2,
                        width: width,
                        height: height,
                        type: nodeType
                    };
                });



                // Redraw edges with validation
                currentDiagram.edges.forEach(edge => {
                    // Validate edge data
                    if (!edge.from || !edge.to || edge.from === edge.to) return;
                    if (!edge.from.trim() || !edge.to.trim()) return; // Skip empty IDs



                    const fromNode = nodePositions[edge.from];
                    const toNode = nodePositions[edge.to];

                    if (fromNode && toNode) {
                        // Draw into the dedicated edges group
                        drawEdge(edgesGroup, fromNode, toNode, edge);
                    }
                });
                // Done
            } finally {
                // Release the update lock even if something throws
                isUpdatingConnections = false;
                if (hoveredNodeEl) updateInfoPanelForNode(hoveredNodeEl);
            }
        }

        // Autosave configuration
        let autosaveEnabled = true;
        let autosaveDelay = 1500; // ms
        let autosaveTimer = null;

        function scheduleAutoSave() {
            if (!autosaveEnabled) return;
            if (!hasUnsavedChanges) return;
            try { clearTimeout(autosaveTimer); } catch (_) { }
            autosaveTimer = setTimeout(() => {
                // Silent autosave to avoid UI noise
                saveDiagram(true);
            }, autosaveDelay);
        }

        async function saveDiagram(silent = false, force = false) {
            if (!currentDiagram) return;
            if (!hasUnsavedChanges && !force) return;

            try {
                if (!silent) showMessage('Saving diagram...', 'info');

                const payload = getDiagramForSave(currentDiagram);
                const response = await fetch(`http://localhost:3001/api/v1/diagrams/${currentDiagram.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                    // Ensure background saves outlive navigation (refresh/close)
                    keepalive: true
                });

                if (response.ok) {
                    hasUnsavedChanges = false;
                    const sb = document.getElementById('saveButton');
                    if (sb) sb.classList.remove('show');
                    if (!silent) showMessage('Diagram saved successfully!', 'success');
                    if (!silent) {
                        // Re-fetch latest diagram from backend to reflect any canonicalization/normalization
                        try {
                            const res2 = await fetch(`http://localhost:3001/api/v1/diagrams/${currentDiagram.id}`);
                            if (res2.ok) {
                                const fresh = await res2.json();
                                currentDiagram = normalizeDiagramNumbers(fresh);
                                renderFlowchart(currentDiagram);
                                updateConnections();
                                updateDiagramInfoBox();
                            } else {
                                // Fallback to updating info only
                                updateDiagramInfoBox();
                            }
                        } catch (_) {
                            updateDiagramInfoBox();
                        }
                        // If currently viewing Raw Data, keep YAML in sync after save
                        const isRawActive = document.getElementById('configurationTab')?.style.display === 'block';
                        if (isRawActive) {
                            try { await loadYamlConfig(); } catch (_) { }
                        }
                    } else {
                        // Silent saves: avoid re-fetch to prevent jitter; refresh summary only
                        updateDiagramInfoBox();
                        // If Raw Data view is open, refresh YAML so users immediately see persisted changes
                        try {
                            const isRawActive = document.getElementById('configurationTab')?.style.display === 'block';
                            if (isRawActive) { await loadYamlConfig(); }
                        } catch (_) { }
                    }
                } else {
                    let msg = 'Save failed';
                    try { const error = await response.json(); msg = `Save failed: ${error.error}`; } catch (_) { }
                    if (!silent) showMessage(msg, 'error');
                    else {
                        console.error(msg);
                        // Surface silent autosave failures so users know persistence didn‚Äôt occur
                        showMessage(msg, 'error');
                    }
                }
            } catch (error) {
                const msg = `Save error: ${error.message}`;
                if (!silent) showMessage(msg, 'error');
                else {
                    console.error(msg);
                    // Surface silent autosave failures
                    showMessage(msg, 'error');
                }
            } finally {
                try { clearTimeout(autosaveTimer); } catch (_) { }
                autosaveTimer = null;
            }
        }

        function showMessage(text, type) {
            // Create/reuse a bottom-right toast container
            let container = document.getElementById('toastContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toastContainer';
                Object.assign(container.style, {
                    position: 'fixed',
                    right: '20px',
                    bottom: '20px',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '8px',
                    zIndex: '1002',
                    maxWidth: '360px',
                    pointerEvents: 'none' // allow clicks to pass through except on toasts
                });
                document.body.appendChild(container);
            }

            const msg = document.createElement('div');
            msg.className = 'message';
            msg.textContent = text;
            Object.assign(msg.style, {
                padding: '10px 14px',
                borderRadius: '6px',
                color: '#fff',
                fontWeight: '600',
                fontSize: '13px',
                boxShadow: '0 6px 16px rgba(0,0,0,0.18)',
                maxWidth: '100%',
                pointerEvents: 'auto',
                opacity: '0',
                transform: 'translateY(6px)',
                transition: 'opacity 120ms ease, transform 160ms ease'
            });

            switch (type) {
                case 'success':
                    msg.style.background = '#27ae60';
                    break;
                case 'error':
                    msg.style.background = '#e74c3c';
                    break;
                case 'info':
                default:
                    msg.style.background = '#3498db';
            }

            container.appendChild(msg);
            // trigger transition
            requestAnimationFrame(() => {
                msg.style.opacity = '1';
                msg.style.transform = 'translateY(0)';
            });

            // Auto-remove after 3 seconds with fade-out
            setTimeout(() => {
                msg.style.opacity = '0';
                msg.style.transform = 'translateY(6px)';
                setTimeout(() => { if (msg.parentNode) msg.remove(); }, 180);
            }, 3000);
        }

        // Update the ribbon Diagram Info box with current diagram details
        function updateDiagramInfoBox() {
            const box = document.getElementById('diagramInfoBox');
            if (!box) return;
            const d = window.currentDiagram;
            if (!d) {
                box.innerHTML = '<div style="font-size:12px;color:#7f8c8d;">No diagram loaded</div>';
                return;
            }
            const name = d.name || 'Unnamed Diagram';
            const id = d.id ? ` <span style="color:#95a5a6;">(${d.id})</span>` : '';
            const nodes = Array.isArray(d.nodes) ? d.nodes.length : 0;
            const edges = Array.isArray(d.edges) ? d.edges.length : 0;
            const layout = (d.layout && d.layout.direction) ? d.layout.direction : 'top-bottom';
            const version = d.version ? `v${d.version}` : '';
            const filePath = d.FilePath || d.filePath || '';
            const baseName = filePath ? (filePath.split(/[\\/]/).pop() || '') : '';
            box.innerHTML = `
                <div style="font-weight:600;font-size:13px;color:#2c3e50;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;" title="${name}${filePath ? ` ‚Äî ${filePath}` : ''}">${name}${id} ${version ? `<span style='color:#95a5a6;'>${version}</span>` : ''}</div>
                <div style="font-size:12px;color:#2c3e50;">
                    <strong>Nodes:</strong> ${nodes} ¬∑ <strong>Edges:</strong> ${edges}<br/>
                    <strong>Layout:</strong> ${layout}${baseName ? ` ¬∑ <span title='${filePath}'>${baseName}</span>` : ''}
                </div>
            `;
        }

        // ======= Right-side Info Panel (hover details) =======
        let hoveredNodeEl = null;
        function setInfoPanelBody(html) {
            const body = document.getElementById('infoPanelBody');
            if (body) body.innerHTML = html;
        }
        function setInfoPanelHeader(title, subtitle = '') {
            const t = document.getElementById('infoTitle');
            const s = document.getElementById('infoSubtitle');
            if (t) t.textContent = title || '';
            if (s) s.textContent = subtitle || '';
        }
        function renderDiagramSummaryInPanel() {
            const d = window.currentDiagram;
            if (!d) {
                setInfoPanelHeader('Info');
                setInfoPanelBody('<div class="info-section">No diagram loaded. Use File ‚Üí Open or New to get started.</div>');
                return;
            }
            const name = d.name || 'Unnamed Diagram';
            const id = d.id || '';
            const nodes = Array.isArray(d.nodes) ? d.nodes.length : 0;
            const edges = Array.isArray(d.edges) ? d.edges.length : 0;
            const layout = (d.layout && d.layout.direction) ? d.layout.direction : 'top-bottom';
            setInfoPanelHeader('Info', `${name}${id ? ` ¬∑ ${id}` : ''}`);
            setInfoPanelBody(`
                <div class="info-section">
                    <div><strong>Overview</strong></div>
                    <ul class="info-list">
                        <li>Nodes: <code>${nodes}</code> ¬∑ Edges: <code>${edges}</code></li>
                        <li>Layout: <code>${layout}</code></li>
                    </ul>
                </div>
            `);
        }
        function clearInfoPanelBody() {
            renderDiagramSummaryInPanel();
        }
        function dockNodeEditor() {
            // If edge editor is currently docked, undock it first
            try { undockEdgeEditor(); } catch (_) { }
            const panelBody = document.getElementById('infoPanelBody');
            const editor = document.getElementById('nodeEditor');
            if (!panelBody || !editor) return;
            // Replace panel content with the editor element
            panelBody.innerHTML = '';
            panelBody.appendChild(editor);
            editor.classList.add('docked');
            editorDocked = true;
            // Use 'Info' as the header, with name ¬∑ id as subtitle
            const nm = editingNode?.name || editingNode?.id || '';
            const id = editingNode?.id || '';
            setInfoPanelHeader('Info', nm && id && nm !== id ? `${nm} ¬∑ ${id}` : nm || id || '');
            // Add a small editing badge to the title for visibility
            try {
                const titleEl = document.getElementById('infoTitle');
                if (titleEl && !titleEl.querySelector('[data-role="editing-badge"]')) {
                    const badge = document.createElement('span');
                    badge.className = 'badge bg-success ms-2';
                    badge.setAttribute('data-role', 'editing-badge');
                    badge.textContent = 'Editing';
                    titleEl.appendChild(badge);
                }
            } catch (_) { }
            // Initialize Bootstrap Accordion persistence when docked
            initBootstrapAccordionPersistence();
        }
        function undockNodeEditor() {
            const editor = document.getElementById('nodeEditor');
            if (!editor) return;
            editor.classList.remove('docked');
            editorDocked = false;
            // Nothing to cleanup for Bootstrap Accordion
            // Move the editor back to the root (right before closing body) to keep DOM tidy
            const appRoot = document.querySelector('#infoPanel')?.parentElement || document.body;
            appRoot.appendChild(editor);
        }

        // Edge editor docking into Info Panel
        function dockEdgeEditor() {
            // If node editor is currently docked, undock it first
            try { undockNodeEditor(); } catch (_) { }
            const panelBody = document.getElementById('infoPanelBody');
            const editor = document.getElementById('edgeEditor');
            if (!panelBody || !editor) return;
            panelBody.innerHTML = '';
            panelBody.appendChild(editor);
            editor.classList.add('docked');
            editorDocked = true;
            // Header: Info + connector summary subtitle
            const modal = document.getElementById('edgeEditor');
            const edgeId = modal?.dataset?.edgeId || '';
            const edge = (currentDiagram?.edges || []).find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
            const label = edge?.name || '';
            const subtitle = edge ? `Connector ¬∑ ${edge.from} ‚Üí ${edge.to}${label ? ` ¬∑ ${label}` : ''}` : 'Connector';
            setInfoPanelHeader('Info', subtitle);
            // Add Editing badge
            try {
                const titleEl = document.getElementById('infoTitle');
                if (titleEl && !titleEl.querySelector('[data-role="editing-badge"]')) {
                    const badge = document.createElement('span');
                    badge.className = 'badge bg-success ms-2';
                    badge.setAttribute('data-role', 'editing-badge');
                    badge.textContent = 'Editing';
                    titleEl.appendChild(badge);
                }
            } catch (_) { }
        }
        function undockEdgeEditor() {
            const editor = document.getElementById('edgeEditor');
            if (!editor) return;
            editor.classList.remove('docked');
            editorDocked = false;
            const appRoot = document.querySelector('#infoPanel')?.parentElement || document.body;
            appRoot.appendChild(editor);
        }

        // Persist accordion state across sessions
        const EDITOR_ACCORDION_KEY = 'flowgen.editorAccordion';
        function loadAccordionState() {
            try {
                const raw = localStorage.getItem(EDITOR_ACCORDION_KEY);
                if (!raw) return {};
                return JSON.parse(raw) || {};
            } catch (_) { return {}; }
        }
        function saveAccordionState(state) {
            try { localStorage.setItem(EDITOR_ACCORDION_KEY, JSON.stringify(state || {})); } catch (_) { }
        }

        // Bootstrap Accordion: persist open/closed sections for the Node Editor when docked
        function initBootstrapAccordionPersistence() {
            const acc = document.getElementById('nodeEditorAccordion');
            if (!acc) return;
            const KEY = 'flowgen.nodeEditorAccordionState.v1';

            function loadState() {
                try { return JSON.parse(localStorage.getItem(KEY) || '{}'); } catch (_) { return {}; }
            }
            function saveState(s) {
                try { localStorage.setItem(KEY, JSON.stringify(s || {})); } catch (_) { }
            }

            // Apply saved state (default: Basic open, others closed)
            const saved = loadState();
            acc.querySelectorAll('.accordion-collapse[id]').forEach((panel) => {
                const id = panel.id;
                const shouldOpen = (saved[id] != null) ? !!saved[id] : (id === 'collapseBasic');
                panel.classList.toggle('show', shouldOpen);
                const btn = acc.querySelector(`button[data-bs-target="#${id}"]`);
                if (btn) btn.setAttribute('aria-expanded', String(shouldOpen));
            });

            // Listen to Bootstrap collapse events to persist changes
            acc.querySelectorAll('.accordion-collapse[id]').forEach((panel) => {
                panel.addEventListener('shown.bs.collapse', () => {
                    const s = loadState();
                    s[panel.id] = true;
                    saveState(s);
                });
                panel.addEventListener('hidden.bs.collapse', () => {
                    const s = loadState();
                    s[panel.id] = false;
                    saveState(s);
                });
            });
        }

        // Legacy manual docked headings removed; Bootstrap Accordion is used directly.
        function computeConnectionPointCenter(cpEl) {
            const display = document.getElementById('flowchartDisplay');
            if (!display || !cpEl) return { x: 0, y: 0 };
            const displayRect = display.getBoundingClientRect();
            const rect = cpEl.getBoundingClientRect();
            // Convert viewport-relative center into content coordinates by adding scroll offset
            const cx = (((rect.left + rect.width / 2) - displayRect.left) + display.scrollLeft) / zoomScale;
            const cy = (((rect.top + rect.height / 2) - displayRect.top) + display.scrollTop) / zoomScale;
            return { x: Math.round(cx), y: Math.round(cy) };
        }
        function updateInfoPanelForNode(nodeEl) {
            // When the editor is docked, do not overwrite the panel with hover info
            if (editorDocked) return;
            if (!nodeEl) { clearInfoPanelBody(); return; }
            const nodeId = nodeEl.dataset.nodeId || '';
            const node = (window.currentDiagram?.nodes || []).find(n => (n.id || '') === nodeId);
            const name = node?.name || nodeId || 'Node';
            const type = node?.type || 'process';
            const left = parseInt(nodeEl.style.left) || 0;
            const top = parseInt(nodeEl.style.top) || 0;
            const width = nodeEl.offsetWidth;
            const height = nodeEl.offsetHeight;
            const cps = Array.from(nodeEl.querySelectorAll('.connection-point'));
            const items = cps.map(cp => {
                const side = cp.dataset.side || '';
                const pt = computeConnectionPointCenter(cp);
                return `<li><code>${side}</code> ‚Üí (<code>${pt.x}</code>, <code>${pt.y}</code>)</li>`;
            }).join('');
            // Gather additional properties
            const position = node?.position ? { x: node.position.x, y: node.position.y } : { x: left + 50, y: top + 50 };
            const dimensions = node?.dimensions ? { w: node.dimensions.width, h: node.dimensions.height } : { w: width, h: height };
            const rotation = node?.rotation ?? 0;
            const textAlign = node?.textAlign || 'center';
            const textPos = node?.textPosition || { horizontal: 'center', vertical: 'center' };
            const manualSize = !!node?.manualSize;
            const style = node?.style || {};
            const fill = style.fill || '';
            const stroke = style.stroke || '';
            const strokeWidth = style.strokeWidth ?? 2;
            const strokeDash = style.strokeDasharray || '';
            const integrations = node?.integrations || {};
            const jira = integrations.jira ? `${integrations.jira.projectKey}-${integrations.jira.issueKey}` : '';
            const drillDown = node?.drillDown || '';
            const metadata = node?.metadata || {};

            // Build categorized connectors (edges) for this node
            const allEdges = Array.isArray(window.currentDiagram?.edges) ? window.currentDiagram.edges : [];
            const incoming = allEdges.filter(e => (e.to || '') === nodeId);
            const outgoing = allEdges.filter(e => (e.from || '') === nodeId);
            const nodesArr = Array.isArray(window.currentDiagram?.nodes) ? window.currentDiagram.nodes : [];
            const byId = (id) => nodesArr.find(n => (n.id || '') === id);
            const fmt = (v) => (v == null || v === '') ? '‚Äî' : String(v);
            const outgoingList = outgoing.map(e => {
                const to = byId(e.to);
                const toName = to?.name || e.to || '';
                const label = (e.name && e.name.trim()) ? ` ¬∑ Label: <code>${e.name}</code>` : '';
                const tech = (e.metadata && e.metadata.technology) ? ` ¬∑ Tech: <code>${fmt(e.metadata.technology)}</code>` : '';
                return `<li>to <code>${toName}</code> (<code>${e.to}</code>)${label}${tech}</li>`;
            }).join('') || '<li>None</li>';
            const incomingList = incoming.map(e => {
                const from = byId(e.from);
                const fromName = from?.name || e.from || '';
                const label = (e.name && e.name.trim()) ? ` ¬∑ Label: <code>${e.name}</code>` : '';
                const tech = (e.metadata && e.metadata.technology) ? ` ¬∑ Tech: <code>${fmt(e.metadata.technology)}</code>` : '';
                return `<li>from <code>${fromName}</code> (<code>${e.from}</code>)${label}${tech}</li>`;
            }).join('') || '<li>None</li>';

            const html = `
                <div class="info-section">Type: <code>${type}</code></div>
                <div class="info-section">
                    <div><strong>Text</strong></div>
                    <ul class="info-list">
                        <li>Displayed: <code>${name}</code></li>
                    </ul>
                </div>
                <div class="info-section">
                    <div><strong>Layout</strong></div>
                    <ul class="info-list">
                        <li>Canvas Pos: (<code>${left}</code>, <code>${top}</code>) ¬∑ Size: <code>${width}√ó${height}</code></li>
                        <li>Diagram Pos: (<code>${position.x}</code>, <code>${position.y}</code>) ¬∑ Dimensions: <code>${dimensions.w}√ó${dimensions.h}</code></li>
                        <li>Rotation: <code>${rotation}¬∞</code> ¬∑ Manual Size: <code>${manualSize}</code></li>
                    </ul>
                </div>
                <div class="info-section">
                    <div><strong>Text Layout</strong></div>
                    <ul class="info-list">
                        <li>Align: <code>${textAlign}</code></li>
                        <li>Position: h=<code>${textPos.horizontal}</code>, v=<code>${textPos.vertical}</code></li>
                    </ul>
                </div>
                <div class="info-section">
                    <div><strong>Style</strong></div>
                    <ul class="info-list">
                        <li>Fill: <code>${fill || '‚Äî'}</code></li>
                        <li>Stroke: <code>${stroke || '‚Äî'}</code> ¬∑ Width: <code>${strokeWidth}</code> ¬∑ Dash: <code>${strokeDash || '‚Äî'}</code></li>
                    </ul>
                </div>
                <div class="info-section">
                    <div><strong>Integrations</strong></div>
                    <ul class="info-list">
                        <li>Jira: <code>${jira || '‚Äî'}</code></li>
                        <li>Drill-down: <code>${drillDown || '‚Äî'}</code></li>
                    </ul>
                </div>
                <div class="info-section">
                    <div><strong>Connectors</strong></div>
                    <div style="color:#6b7280; font-size:12px; margin:2px 0 6px;">Associated edges grouped by direction</div>
                    <div style="font-weight:600; margin-bottom:4px;">Outgoing (${outgoing.length})</div>
                    <ul class="info-list">${outgoingList}</ul>
                    <div style="font-weight:600; margin:8px 0 4px;">Incoming (${incoming.length})</div>
                    <ul class="info-list">${incomingList}</ul>
                </div>
                <div class="info-section">
                    <div><strong>Ports (canvas)</strong></div>
                    <ul class="info-list">${items || '<li>None</li>'}</ul>
                </div>
            `;
            setInfoPanelHeader('Info', `${name} ¬∑ ${nodeId}`);
            setInfoPanelBody(html);
        }

        // ============ GRID AND LAYOUT FUNCTIONS ============

        // Edge selection helpers
        function clearEdgeSelection() {
            selectedEdgeId = null;
            document.querySelectorAll('.connection-line.selected, .connection-arrowhead.selected, .connection-label-bg.selected')
                .forEach(el => el.classList.remove('selected'));
        }

        function selectEdge(edgeId) {
            clearEdgeSelection();
            selectedEdgeId = edgeId;
            const display = document.getElementById('flowchartDisplay');
            const line = display.querySelector(`line.connection-line[data-edge-id="${edgeId}"]`);
            const arrow = display.querySelector(`polygon.connection-arrowhead[data-edge-id="${edgeId}"]`);
            const bg = display.querySelector(`rect.connection-label-bg[data-edge-id="${edgeId}"]`);
            if (line) line.classList.add('selected');
            if (arrow) arrow.classList.add('selected');
            if (bg) bg.classList.add('selected');
        }

        async function deleteSelectedEdge() {
            if (!selectedEdgeId || !currentDiagram?.edges) return;
            const idx = currentDiagram.edges.findIndex(e => (e.id || `${e.from}-${e.to}`) === selectedEdgeId);
            if (idx >= 0) {
                currentDiagram.edges.splice(idx, 1);
                clearEdgeSelection();
                updateConnections();
                hasUnsavedChanges = true;
                document.getElementById('saveButton').classList.add('show');
                scheduleAutoSave();
                // Immediate autosave on connector delete (force save)
                await saveDiagram(true, true);
                showMessage('Connector removed', 'success');
                updateDiagramInfoBox();
            }
        }

        function openEdgeEditor(edgeId) {
            const edge = currentDiagram?.edges?.find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
            if (!edge) return;
            const modal = document.getElementById('edgeEditor');
            modal.dataset.edgeId = edgeId;
            document.getElementById('edgeName').value = edge.name || '';
            const meta = edge.metadata || {};
            document.getElementById('edgeTechnology').value = meta.technology || '';

            const style = edge.style || {};
            document.getElementById('edgeStroke').value = style.stroke || '#34495e';
            document.getElementById('edgeWidth').value = style.strokeWidth || 2;
            document.getElementById('edgeDash').value = style.strokeDasharray || '';
            // Auto-open panel if in auto mode and currently collapsed
            const panel = document.getElementById('infoPanel');
            if (panel && panel.classList.contains('collapsed')) {
                if ((appSettings.infoPanelMode || 'auto') === 'auto') {
                    panel.classList.add('temp-open');
                }
                applyInfoPanelState();
                if ((appSettings.infoPanelMode || 'auto') === 'auto') panel.dataset.autoOpened = 'true';
            }
            // Dock inside Info Panel
            dockEdgeEditor();
            modal.style.display = 'block';
        }

        function closeEdgeEditor() {
            const modal = document.getElementById('edgeEditor');
            modal.style.display = 'none';
            modal.dataset.edgeId = '';
            // Undock and restore panel
            undockEdgeEditor();
            renderDiagramSummaryInPanel();
            // Remove editing badge if present
            try {
                const titleEl = document.getElementById('infoTitle');
                titleEl?.querySelector('[data-role="editing-badge"]')?.remove();
            } catch (_) { }
            // If we auto-opened the panel for editing, collapse it back (auto mode only)
            const panel = document.getElementById('infoPanel');
            if (panel && panel.dataset.autoOpened === 'true' && (appSettings.infoPanelMode || 'auto') === 'auto') {
                panel.classList.remove('temp-open');
                delete panel.dataset.autoOpened;
                applyInfoPanelState();
            }
        }

        function saveEdgeChanges() {
            const modal = document.getElementById('edgeEditor');
            const edgeId = modal.dataset.edgeId;
            const edge = currentDiagram?.edges?.find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
            if (!edge) return;
            edge.name = document.getElementById('edgeName').value;
            edge.metadata = edge.metadata || {};
            edge.metadata.technology = document.getElementById('edgeTechnology').value || undefined;

            edge.style = edge.style || {};
            edge.style.stroke = document.getElementById('edgeStroke').value || '#34495e';
            const w = parseFloat(document.getElementById('edgeWidth').value);
            edge.style.strokeWidth = isNaN(w) ? 2 : w;
            const dash = (document.getElementById('edgeDash').value || '').trim();
            edge.style.strokeDasharray = dash || undefined;
            hasUnsavedChanges = true;
            const sbDel = document.getElementById('saveButton'); if (sbDel) sbDel.classList.add('show');
            scheduleAutoSave();
            // Immediate silent autosave for editor-based edge updates
            saveDiagram(true);
            closeEdgeEditor();
            updateConnections();
            showMessage('Connector updated', 'success');
        }

        function deleteEdgeFromEditor() {
            const modal = document.getElementById('edgeEditor');
            const edgeId = modal.dataset.edgeId;
            closeEdgeEditor();
            selectedEdgeId = edgeId;
            deleteSelectedEdge();
        }

        // Edge creation interactions
        function startEdgeCreation(connectionPointEl, clientX, clientY) {
            if (!editMode) return;
            const nodeEl = connectionPointEl.closest('.node');
            if (!nodeEl) return;
            const nodeId = nodeEl.dataset.nodeId;
            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();
            const ptRect = connectionPointEl.getBoundingClientRect();
            // Include container scroll when converting to stage/content coordinates
            const startX = (((ptRect.left + ptRect.width / 2) - displayRect.left) + displayEl.scrollLeft) / zoomScale;
            const startY = (((ptRect.top + ptRect.height / 2) - displayRect.top) + displayEl.scrollTop) / zoomScale;
            // Ensure a connections SVG exists (create if missing)
            const stage = document.getElementById('diagramStage') || document.getElementById('flowchartDisplay');
            let svg = stage.querySelector('svg.connections-layer');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.className = 'connections-layer';
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.zIndex = '1';
                svg.style.pointerEvents = 'auto';
                stage.appendChild(svg);
                const edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                edgesGroup.setAttribute('class', 'edges-layer');
                svg.appendChild(edgesGroup);
            }
            const preview = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            preview.setAttribute('x1', startX);
            preview.setAttribute('y1', startY);
            preview.setAttribute('x2', startX);
            preview.setAttribute('y2', startY);
            preview.setAttribute('stroke', '#7f8c8d');
            preview.setAttribute('stroke-width', '2');
            preview.setAttribute('stroke-dasharray', '4,2');
            preview.setAttribute('class', 'connection-preview');
            // Important: don't block pointer events so drops register on nodes/points beneath
            preview.style.pointerEvents = 'none';
            svg.appendChild(preview);
            // Temporarily disable pointer events on the whole SVG during drag so hit-testing finds nodes beneath
            const prevPointerEvents = svg.style.pointerEvents;
            svg.style.pointerEvents = 'none';
            edgeCreation = {
                sourceNodeId: nodeId,
                sourceSide: connectionPointEl.dataset.side,
                startX, startY,
                previewLine: preview,
                svgEl: svg,
                prevPointerEvents
            };
            // Global listeners for drag
            document.addEventListener('mousemove', handleMouseMove, { passive: false });
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
        }

        function updateEdgeCreationPreview(clientX, clientY) {
            if (!edgeCreation) return;
            const displayEl = document.getElementById('flowchartDisplay');
            const displayRect = displayEl.getBoundingClientRect();
            // Include scroll offsets to align with content coordinates
            const x2 = ((clientX - displayRect.left) + displayEl.scrollLeft) / zoomScale;
            const y2 = ((clientY - displayRect.top) + displayEl.scrollTop) / zoomScale;
            const line = edgeCreation.previewLine;
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);

            // Highlight potential drop target under cursor
            const stack = (document.elementsFromPoint ? document.elementsFromPoint(clientX, clientY) : [document.elementFromPoint(clientX, clientY)]).filter(Boolean);
            // Clear previous highlight
            document.querySelectorAll('#flowchartDisplay .node.drop-target').forEach(n => n.classList.remove('drop-target'));
            let targetNode = null;
            for (const el of stack) {
                // Skip overlays
                if (el.matches && (el.matches('svg.connections-layer') || el.matches('svg.grid-overlay'))) continue;
                const cp = el.closest && el.closest('.connection-point');
                if (cp && cp.closest) { targetNode = cp.closest('.node'); }
                if (!targetNode && el.closest) targetNode = el.closest('.node');
                if (targetNode) break;
            }
            if (targetNode) targetNode.classList.add('drop-target');
        }

        function cancelEdgeCreation() {
            if (!edgeCreation) return;
            try { edgeCreation.previewLine?.remove(); } catch (_) { }
            // Restore SVG pointer events if we changed them
            try { if (edgeCreation.svgEl) edgeCreation.svgEl.style.pointerEvents = edgeCreation.prevPointerEvents || 'auto'; } catch (_) { }
            edgeCreation = null;
            // Clear any target highlight
            document.querySelectorAll('#flowchartDisplay .node.drop-target').forEach(n => n.classList.remove('drop-target'));
            // Remove global listeners added during drag
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
        }

        function finishEdgeCreation(eventLike) {
            if (!edgeCreation) return;
            // Determine if the end is over a valid connection point of another node
            const stack = (document.elementsFromPoint ? document.elementsFromPoint(eventLike.clientX, eventLike.clientY) : [document.elementFromPoint(eventLike.clientX, eventLike.clientY)]).filter(Boolean);
            // Accept either a connection point or any part of a node for the drop
            let targetNodeEl = null;
            for (const el of stack) {
                if (el.matches && (el.matches('svg.connections-layer') || el.matches('svg.grid-overlay'))) continue;
                const cp = el.closest && el.closest('.connection-point');
                if (cp && cp.closest) targetNodeEl = cp.closest('.node');
                if (!targetNodeEl && el.closest) targetNodeEl = el.closest('.node');
                if (targetNodeEl) break;
            }
            const targetNodeId = targetNodeEl ? targetNodeEl.dataset.nodeId : null;
            const sourceNodeId = edgeCreation.sourceNodeId;
            // Remove preview
            cancelEdgeCreation();
            // Ensure highlight cleared
            document.querySelectorAll('#flowchartDisplay .node.drop-target').forEach(n => n.classList.remove('drop-target'));
            if (!targetNodeId || targetNodeId === sourceNodeId) return;
            // Create new edge
            currentDiagram.edges = currentDiagram.edges || [];
            const newEdge = {
                id: `${sourceNodeId}-${targetNodeId}-${Date.now()}`,
                from: sourceNodeId,
                to: targetNodeId,
                name: '',
                style: { stroke: '#34495e', strokeWidth: 2 },
                metadata: {}
            };
            currentDiagram.edges.push(newEdge);
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            scheduleAutoSave();
            // Immediate autosave on connector add (drag-connect)
            saveDiagram(true);
            updateConnections();
            updateDiagramInfoBox();
            // Optionally open editor
            openEdgeEditor(newEdge.id);
        }

        // === Resize handles ===
        function addResizeHandles(nodeEl, node) {
            // Remove existing handles/edges to avoid duplicates
            nodeEl.querySelectorAll('.resize-handle, .resize-edge').forEach(h => h.remove());
            const typesSquare = new Set(['decision', 'start', 'end', 'connector']);

            function makeHandle(cls) {
                const h = document.createElement('div');
                h.className = `resize-handle ${cls}`;
                nodeEl.appendChild(h);
                return h;
            }

            function makeEdge(cls) {
                const e = document.createElement('div');
                e.className = `resize-edge ${cls}`;
                nodeEl.appendChild(e);
                return e;
            }

            // Decide which handles to show to avoid overlapping with connection points
            // Rule:
            //  - Decision (diamond): connection points sit on corners ‚Üí hide corner handle (SE), show side handles (E, S)
            //  - Others (rectangles, circles, hexagon, etc.): connection points sit on side midpoints ‚Üí hide side handles (E, S), show corner handle (SE)
            const isDecision = node?.type === 'decision';
            const showE = !!isDecision;
            const showS = !!isDecision;
            const showSE = !isDecision; // only show corner for non-diamond shapes

            const created = [];
            if (showE) created.push(makeHandle('resize-e'));
            if (showS) created.push(makeHandle('resize-s'));
            if (showSE) created.push(makeHandle('resize-se'));
            // Full-length hover/click areas for intuitive resizing near sides (only when showing that side)
            if (showE) created.push(makeEdge('e'));
            if (showS) created.push(makeEdge('s'));

            const displayRect = () => document.getElementById('flowchartDisplay').getBoundingClientRect();

            function startResize(e, dir) {
                if (!editMode) return;
                e.preventDefault(); e.stopPropagation();
                // Prevent hover scale and bring node to a stable state during resize
                nodeEl.classList.add('resizing');
                // No autosave while resizing (only on release)
                let resizeSaveTimer = null;
                const rect = nodeEl.getBoundingClientRect();
                const startX = ('clientX' in e) ? e.clientX : e.touches[0].clientX;
                const startY = ('clientY' in e) ? e.clientY : e.touches[0].clientY;
                const startW = rect.width;
                const startH = rect.height;
                const isSquare = typesSquare.has(node.type);

                function onMove(ev) {
                    const cx = ('clientX' in ev) ? ev.clientX : ev.touches[0].clientX;
                    const cy = ('clientY' in ev) ? ev.clientY : ev.touches[0].clientY;
                    const z = (zoomScale || 1);
                    const minW = 40; // minimum width for usability
                    const minH = 30; // minimum height for usability
                    const deadzone = 0.5; // px tolerance to avoid accidental jumps

                    // Deltas in element space
                    let dW = dir.includes('e') ? (cx - startX) / z : 0;
                    let dH = dir.includes('s') ? (cy - startY) / z : 0;
                    if (Math.abs(dW) < deadzone) dW = 0;
                    if (Math.abs(dH) < deadzone) dH = 0;

                    // Raw sizes before snapping
                    const rawW = startW + dW;
                    const rawH = startH + dH;

                    let newW = dir.includes('e') ? Math.max(minW, rawW) : startW;
                    let newH = dir.includes('s') ? Math.max(minH, rawH) : startH;

                    if (isSquare) {
                        // Base size on dragged axis to allow shrinking
                        const minSize = Math.max(minW, minH);
                        const startSize = Math.max(startW, startH);
                        let rawSize = (dir === 'e') ? rawW : (dir === 's') ? rawH : Math.max(rawW, rawH);
                        let dSize = rawSize - startSize;
                        if (snapToGrid) {
                            const gs = Math.max(5, gridSize);
                            if (dSize > 0) rawSize = Math.ceil(rawSize / gs) * gs; // growing ‚Üí snap up
                            else if (dSize < 0) rawSize = Math.floor(rawSize / gs) * gs; // shrinking ‚Üí snap down
                            else rawSize = Math.round(rawSize / gs) * gs; // no movement ‚Üí nearest
                        }
                        const size = Math.max(minSize, rawSize);
                        newW = size;
                        newH = size;
                    } else if (snapToGrid) {
                        // Non-square: snap each axis based on movement direction to avoid immediate grow
                        const gs = Math.max(5, gridSize);
                        if (dir.includes('e')) {
                            const delta = rawW - startW;
                            if (delta > 0) newW = Math.ceil(rawW / gs) * gs; // growing ‚Üí snap up
                            else if (delta < 0) newW = Math.floor(rawW / gs) * gs; // shrinking ‚Üí snap down
                            else newW = Math.round(rawW / gs) * gs;
                            newW = Math.max(minW, newW);
                        }
                        if (dir.includes('s')) {
                            const delta = rawH - startH;
                            if (delta > 0) newH = Math.ceil(rawH / gs) * gs;
                            else if (delta < 0) newH = Math.floor(rawH / gs) * gs;
                            else newH = Math.round(rawH / gs) * gs;
                            newH = Math.max(minH, newH);
                        }
                    }

                    nodeEl.style.width = `${newW}px`;
                    nodeEl.style.height = `${newH}px`;
                    // Update connections live
                    updateConnections();

                    // Persist live size to model so mid-drag autosaves reflect current dimensions
                    const n = (currentDiagram?.nodes || []).find(n0 => n0.id === nodeEl.dataset.nodeId);
                    if (n) {
                        n.dimensions = n.dimensions || { width: Math.round(newW), height: Math.round(newH) };
                        n.dimensions.width = Math.round(newW);
                        n.dimensions.height = Math.round(newH);
                        n.manualSize = true;
                    }
                    hasUnsavedChanges = true;
                }
                function onUp(ev) {
                    // Exit resizing state
                    nodeEl.classList.remove('resizing');
                    window.removeEventListener('mousemove', onMove);
                    window.removeEventListener('mouseup', onUp);
                    window.removeEventListener('touchmove', onMove);
                    window.removeEventListener('touchend', onUp);
                    if (resizeSaveTimer) { try { clearTimeout(resizeSaveTimer); } catch (_) { } resizeSaveTimer = null; }
                    // Persist size back to diagram
                    const w = nodeEl.offsetWidth;
                    const h = nodeEl.offsetHeight;
                    const n = (currentDiagram?.nodes || []).find(n0 => n0.id === nodeEl.dataset.nodeId);
                    if (n) {
                        n.dimensions = n.dimensions || { width: w, height: h };
                        n.dimensions.width = w;
                        n.dimensions.height = h;
                        // For decision (diamond) and circles, record manualSize to prevent auto-resize overrides
                        n.manualSize = true;
                    }
                    hasUnsavedChanges = true;
                    const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                    scheduleAutoSave();
                    // Immediate silent autosave for size changes
                    saveDiagram(true);
                }
                window.addEventListener('mousemove', onMove, { passive: false });
                window.addEventListener('mouseup', onUp);
                window.addEventListener('touchmove', onMove, { passive: false });
                window.addEventListener('touchend', onUp);
            }

            created.forEach((h) => {
                const dir = h.classList.contains('resize-se') ? 'se'
                    : (h.classList.contains('resize-e') || h.classList.contains('e')) ? 'e'
                        : (h.classList.contains('resize-s') || h.classList.contains('s')) ? 's'
                            : 'se';
                h.addEventListener('mousedown', (e) => startResize(e, dir));
                h.addEventListener('touchstart', (e) => startResize(e, dir), { passive: false });
            });
        }

        function toggleGrid() {
            // Prevent disabling grid while in edit mode
            if (editMode && gridEnabled) {
                showMessage('Grid stays ON while editing', 'info');
                return;
            }
            gridEnabled = !gridEnabled;
            if (gridEnabled) {
                showGrid();
            } else {
                hideGrid();
            }
            // Keep snapping aligned with grid visibility
            snapToGrid = gridEnabled;
            updateGridSettings();
            // Persist setting
            appSettings.gridEnabled = gridEnabled;
            appSettings.snapToGrid = snapToGrid;
            saveAppSettingsSilent();
        }

        // Keep grid/snap settings in sync and reapply grid if needed
        function updateGridSettings() {
            // Ensure snap matches grid state
            snapToGrid = gridEnabled;
            // If grid should be visible but missing (e.g., after re-render), recreate it
            const hasGrid = !!document.querySelector('#flowchartDisplay svg.grid-overlay');
            if (gridEnabled && !hasGrid) {
                showGrid();
            }
            if (!gridEnabled && hasGrid) {
                hideGrid();
            }
        }

        function showGrid() {
            const container = document.getElementById('diagramStage') || document.getElementById('flowchartDisplay');

            // Remove existing grid
            if (gridSvg) {
                gridSvg.remove();
            }

            // Create grid SVG
            gridSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            gridSvg.className = 'grid-overlay';
            gridSvg.style.position = 'absolute';
            gridSvg.style.top = '0';
            gridSvg.style.left = '0';
            gridSvg.style.width = '100%';
            gridSvg.style.height = '100%';
            gridSvg.style.pointerEvents = 'none';
            gridSvg.style.zIndex = '1';

            // Create grid pattern
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.id = 'grid-pattern';
            pattern.setAttribute('width', gridSize);
            pattern.setAttribute('height', gridSize);
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${gridSize} 0 L 0 0 0 ${gridSize}`);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', gridColor || '#bdc3c7');
            path.setAttribute('stroke-width', '1');
            path.setAttribute('opacity', String(gridOpacity ?? 0.3));

            pattern.appendChild(path);
            defs.appendChild(pattern);
            gridSvg.appendChild(defs);

            // Create grid rectangle
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', '100%');
            rect.setAttribute('height', '100%');
            rect.setAttribute('fill', 'url(#grid-pattern)');

            gridSvg.appendChild(rect);
            container.appendChild(gridSvg);
        }

        function hideGrid() {
            if (gridSvg) {
                gridSvg.remove();
                gridSvg = null;
            }
        }

        function snapToGridPosition(x, y) {
            if (!snapToGrid) return { x, y };

            const snappedX = Math.round(x / gridSize) * gridSize;
            const snappedY = Math.round(y / gridSize) * gridSize;

            return { x: snappedX, y: snappedY };
        }

        // Snap a node based on its type; diamonds snap by center
        function snapNodePosition(nodeEl, x, y, useTolerance = false) {
            if (!snapToGrid || !nodeEl) return { x, y };
            const nodeId = nodeEl.dataset.nodeId;
            const node = currentDiagram?.nodes?.find(n => n.id === nodeId);
            const type = node?.type || 'process';
            const width = nodeEl.offsetWidth;
            const height = nodeEl.offsetHeight;
            const tolerance = useTolerance ? 5 : 0;

            if (type === 'decision') {
                // Snap diamond center to the grid
                const centerX = x + width / 2;
                const centerY = y + height / 2;
                const gridCX = Math.round(centerX / gridSize) * gridSize;
                const gridCY = Math.round(centerY / gridSize) * gridSize;
                const snappedCX = Math.abs(centerX - gridCX) < tolerance ? gridCX : centerX;
                const snappedCY = Math.abs(centerY - gridCY) < tolerance ? gridCY : centerY;
                return {
                    x: Math.round(snappedCX - width / 2),
                    y: Math.round(snappedCY - height / 2),
                };
            }

            // Default: snap top-left corner
            const gridX = Math.round(x / gridSize) * gridSize;
            const gridY = Math.round(y / gridSize) * gridSize;
            return {
                x: Math.abs(x - gridX) < tolerance ? gridX : x,
                y: Math.abs(y - gridY) < tolerance ? gridY : y,
            };
        }

        function openNodeEditor(node, nodeElement) {
            editingNode = node;
            editingNodeElement = nodeElement;

            // Auto-open panel if in auto mode and currently collapsed
            const panel = document.getElementById('infoPanel');
            if (panel && panel.classList.contains('collapsed')) {
                if ((appSettings.infoPanelMode || 'auto') === 'auto') {
                    panel.classList.add('temp-open');
                }
                applyInfoPanelState();
                if ((appSettings.infoPanelMode || 'auto') === 'auto') panel.dataset.autoOpened = 'true';
            }

            // Ensure editor is docked inside the Info Panel
            dockNodeEditor();

            // Populate form with current values
            document.getElementById('nodeName').value = node.name || '';
            document.getElementById('nodeType').value = node.type || 'process';
            document.getElementById('nodeRotation').value = node.rotation || 0;
            document.getElementById('rotationValue').textContent = (node.rotation || 0) + '¬∞';
            document.getElementById('nodeWidth').value = node.dimensions?.width || 100;
            document.getElementById('nodeHeight').value = node.dimensions?.height || 50;
            document.getElementById('textAlign').value = node.textAlign || 'center';

            // Set text position buttons
            const textPos = node.textPosition || { horizontal: 'center', vertical: 'center' };
            document.querySelectorAll('.text-position-btn').forEach(btn => {
                btn.classList.remove('selected');
                const btnH = btn.dataset.h;
                const btnV = btn.dataset.v;
                if (btnH === textPos.horizontal && btnV === textPos.vertical) {
                    btn.classList.add('selected');
                }
            });

            // If no position is selected, default to center
            if (!document.querySelector('.text-position-btn.selected')) {
                document.querySelector('.text-position-btn[data-default="true"]').classList.add('selected');
            }

            // Initialize color picker selection and favorites
            renderFavoriteColors();
            const currentColor = node.style?.fill || getNodeTypeColor(node.type);
            setSelectedColor(currentColor);
            // Bind palette clicks (favorites are bound in renderFavoriteColors)
            document.querySelectorAll('#fillColorGrid .color-option').forEach(option => {
                option.onclick = () => {
                    const color = option.dataset.color;
                    if (color) setSelectedColor(color);
                };
            });

            // Add text position button handlers
            document.querySelectorAll('.text-position-btn').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.text-position-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                };
            });

            // Show the editor (docked)
            const ed = document.getElementById('nodeEditor');
            ed.style.display = 'block';

            // Enforce square inputs for decision nodes during editing
            const typeEl = document.getElementById('nodeType');
            const wEl = document.getElementById('nodeWidth');
            const hEl = document.getElementById('nodeHeight');

            function applySquareLockForDecision() {
                if (typeEl.value === 'decision') {
                    // sync values immediately
                    const size = Math.max(parseInt(wEl.value || '0', 10) || 0, parseInt(hEl.value || '0', 10) || 0);
                    const finalSize = size > 0 ? size : (editingNode.dimensions?.width || 100);
                    wEl.value = finalSize;
                    hEl.value = finalSize;
                    // bind mirroring
                    wEl.oninput = () => { hEl.value = wEl.value; };
                    hEl.oninput = () => { wEl.value = hEl.value; };
                } else {
                    // remove mirroring
                    wEl.oninput = null;
                    hEl.oninput = null;
                }
            }

            // Bind type change to toggle the lock (and keep existing onchange behavior)
            if (!typeEl._squareLockListener) {
                typeEl._squareLockListener = () => applySquareLockForDecision();
                typeEl.addEventListener('change', typeEl._squareLockListener);
            }
            // Apply initial lock state
            applySquareLockForDecision();
        }

        function closeNodeEditor() {
            const ed = document.getElementById('nodeEditor');
            // Hide and undock
            ed.style.display = 'none';
            undockNodeEditor();
            editingNode = null;
            editingNodeElement = null;
            // Restore info panel default content
            renderDiagramSummaryInPanel();
            // Remove editing badge if present
            try {
                const titleEl = document.getElementById('infoTitle');
                titleEl?.querySelector('[data-role="editing-badge"]')?.remove();
            } catch (_) { }

            // If we auto-opened the panel for editing, collapse it back (auto mode only)
            const panel = document.getElementById('infoPanel');
            if (panel && panel.dataset.autoOpened === 'true' && (appSettings.infoPanelMode || 'auto') === 'auto') {
                panel.classList.remove('temp-open');
                delete panel.dataset.autoOpened;
                applyInfoPanelState();
            }
        }

        async function confirmDeleteCurrentNode() {
            if (!editingNode || !editingNodeElement) return;
            if (confirm('Delete this node and its connections?')) {
                await deleteNode(editingNode, editingNodeElement);
            }
        }

        function saveNodeChanges() {
            if (!editingNode || !editingNodeElement) return;

            // Get form values
            const newName = document.getElementById('nodeName').value;
            const newType = document.getElementById('nodeType').value;
            const newRotation = parseInt(document.getElementById('nodeRotation').value);
            let newWidth = parseInt(document.getElementById('nodeWidth').value);
            let newHeight = parseInt(document.getElementById('nodeHeight').value);
            // Diamonds must be square: force equal dimensions
            if (newType === 'decision') {
                const size = Math.max(newWidth || 0, newHeight || 0);
                newWidth = size; newHeight = size;
            }
            const newTextAlign = document.getElementById('textAlign').value;
            // Determine selected color preference
            const selectedValueEl = document.getElementById('selectedColorValue');
            const sv = selectedValueEl ? (selectedValueEl.value || '') : '';
            let newColor = (sv && /^#([0-9A-Fa-f]{6})$/.test(sv)) ? sv : null;
            if (!newColor) {
                const selectedColor = document.querySelector('#fillColorGrid .color-option.selected, #favoriteColors .color-option.selected');
                newColor = selectedColor ? selectedColor.dataset.color : getNodeTypeColor(newType);
            }

            // Get text position
            const selectedPosition = document.querySelector('.text-position-btn.selected');
            const textPosition = selectedPosition ? {
                horizontal: selectedPosition.dataset.h,
                vertical: selectedPosition.dataset.v
            } : { horizontal: 'center', vertical: 'center' };

            // Check if name changed (for auto-resize)
            const nameChanged = editingNode.name !== newName;
            const typeChanged = editingNode.type !== newType;

            // Update the node data
            editingNode.name = newName;
            editingNode.type = newType;
            editingNode.rotation = newRotation;
            editingNode.textPosition = textPosition;
            editingNode.textAlign = newTextAlign;
            editingNode.dimensions = editingNode.dimensions || {};

            // Determine if user changed dimensions in this edit
            const oldWidth = editingNode.dimensions.width || 100;
            const oldHeight = editingNode.dimensions.height || 50;
            const sizeChanged = (oldWidth !== newWidth || oldHeight !== newHeight);

            // Always apply requested dimensions from the editor
            editingNode.dimensions.width = newWidth;
            editingNode.dimensions.height = newHeight;
            // Diamonds must remain square
            if (newType === 'decision') {
                const size = Math.max(newWidth || 0, newHeight || 0);
                editingNode.dimensions.width = size;
                editingNode.dimensions.height = size;
            }
            // If size changed, mark as manual so future renders won't auto-resize over it
            if (sizeChanged) {
                editingNode.manualSize = true;
            }

            editingNode.style = editingNode.style || {};
            editingNode.style.fill = newColor;

            // Update the visual element
            updateNodeVisual(editingNode, editingNodeElement);

            // Update connections
            updateConnections();

            // Mark as changed
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            scheduleAutoSave();
            // Immediate silent autosave for editor-based node updates
            saveDiagram(true);

            // Close editor
            closeNodeEditor();

            showMessage('Node updated successfully!', 'success');
        }

        function updateNodeVisual(node, nodeElement) {
            // Auto-resize for text content if not manually overridden
            if (!node.manualSize) {
                autoResizeNode(node, nodeElement);
            }

            // Update dimensions
            nodeElement.style.width = (node.dimensions?.width || 100) + 'px';
            nodeElement.style.height = (node.dimensions?.height || 50) + 'px';

            // Update colors
            const style = node.style || {};
            nodeElement.style.backgroundColor = style.fill || getNodeTypeColor(node.type);

            // Ensure CSS classes reflect current type (used by affordance styling)
            if ((node.type || '').toLowerCase() === 'decision') {
                nodeElement.classList.add('decision-node');
            } else {
                nodeElement.classList.remove('decision-node');
            }

            // Get or create text element
            let textEl = nodeElement.querySelector('.node-text');
            if (!textEl) {
                textEl = document.createElement('div');
                textEl.className = 'node-text';
                nodeElement.appendChild(textEl);
            }

            // Update text content
            textEl.textContent = node.name;

            // Apply text positioning
            const textPos = node.textPosition || { horizontal: 'center', vertical: 'center' };
            const textAlign = node.textAlign || 'center';

            textEl.style.alignItems = textPos.vertical;
            textEl.style.justifyContent = textPos.horizontal;
            textEl.style.textAlign = textAlign;

            // Update shape based on type and reset transforms
            nodeElement.style.transform = '';
            nodeElement.style.borderRadius = '';
            nodeElement.style.clipPath = '';
            textEl.style.transform = '';
            // Reset border and remove any prior hex overlay
            nodeElement.style.border = '';
            const prevOverlay = nodeElement.querySelector('.shape-border-overlay');
            if (prevOverlay) prevOverlay.remove();

            if (node.type === 'decision') {
                // Diamond shape for decisions - ensure square dimensions
                if (!node.manualSize) {
                    const size = Math.max(node.dimensions?.width || 100, node.dimensions?.height || 100);
                    node.dimensions = node.dimensions || {};
                    node.dimensions.width = size;
                    node.dimensions.height = size;
                    nodeElement.style.width = size + 'px';
                    nodeElement.style.height = size + 'px';
                }

                nodeElement.style.transform = `rotate(45deg)`;
                if (node.rotation) {
                    nodeElement.style.transform += ` rotate(${node.rotation}deg)`;
                }
                nodeElement.style.transformOrigin = 'center';
                textEl.style.transform = 'rotate(-45deg)';
            } else if (node.type === 'start' || node.type === 'end' || node.type === 'connector') {
                // Ellipse for start/end
                nodeElement.style.borderRadius = '50%';
                if (node.rotation) {
                    nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                }
            } else if (node.type === 'data') {
                // Hexagon for data
                nodeElement.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                if (node.rotation) {
                    nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                }
                // Overlay border for hexagon
                const borderColor = (style.stroke || '#333');
                const overlay = document.createElement('div');
                overlay.className = 'shape-border-overlay';
                Object.assign(overlay.style, {
                    position: 'absolute', top: '0', left: '0', right: '0', bottom: '0',
                    pointerEvents: 'none',
                    clipPath: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
                    boxShadow: `inset 0 0 0 2px ${borderColor}`
                });
                nodeElement.appendChild(overlay);
            } else {
                // Rectangle for process nodes
                nodeElement.style.borderRadius = '8px';
                if (node.rotation) {
                    nodeElement.style.transform = `rotate(${node.rotation}deg)`;
                }
            }

            // Apply standard border to non-hexagon shapes
            if (node.type !== 'data') {
                const borderColor = (style.stroke || '#333');
                nodeElement.style.border = `2px solid ${borderColor}`;
            }
            // Ensure resize handles reflect the current shape and avoid overlapping connection points
            try { addResizeHandles(nodeElement, node); } catch (_) { /* no-op if not yet in DOM */ }
        }

        function autoResizeNode(node, nodeElement) {

            // Establish layout constants: paddings and border widths
            // Defaults match styles/app.css (.node has padding:10px, border:2px; .node-text has padding:10px)
            let nodePadding = 10; // each side
            let textPadding = 10; // each side
            let borderWidth = 2; // each side for non-hexagon shapes
            const t = (node.type || '').toLowerCase();
            if (t === 'data') borderWidth = 0; // hex uses overlay, not the element border

            // If we have a nodeElement, try to read actual computed styles
            if (nodeElement) {
                try {
                    const csNode = getComputedStyle(nodeElement);
                    const nPadTop = parseFloat(csNode.paddingTop) || nodePadding;
                    const nPadLeft = parseFloat(csNode.paddingLeft) || nodePadding;
                    nodePadding = Math.round((nPadTop + nPadLeft) / 2);
                    const b = parseFloat(csNode.borderLeftWidth) || borderWidth;
                    borderWidth = b;
                    const textEl = nodeElement.querySelector('.node-text');
                    if (textEl) {
                        const csText = getComputedStyle(textEl);
                        const tPadTop = parseFloat(csText.paddingTop) || textPadding;
                        const tPadLeft = parseFloat(csText.paddingLeft) || textPadding;
                        textPadding = Math.round((tPadTop + tPadLeft) / 2);
                    }
                } catch (_) { /* fallback to defaults */ }
            }

            // Build measurer that mirrors .node-text box (border-box with its own padding only)
            let measurer = document.getElementById('text-measurer');
            if (!measurer) {
                measurer = document.createElement('div');
                measurer.id = 'text-measurer';
                document.body.appendChild(measurer);
            }
            Object.assign(measurer.style, {
                position: 'fixed', left: '-9999px', top: '-9999px', visibility: 'hidden',
                display: 'inline-block', boxSizing: 'border-box',
                padding: textPadding + 'px',
                whiteSpace: 'normal', wordBreak: 'break-word', overflowWrap: 'break-word',
                margin: '0', border: '0',
                fontWeight: '700',
                fontSize: '0.8rem', // mirror .node font-size
                fontFamily: 'inherit', lineHeight: '1.25'
            });
            measurer.textContent = node.name;

            // Compute text box dimensions: prefer natural width below cap, otherwise wrap at cap
            const MAX_TEXT_WIDTH = 220; // cap for wrapping to avoid overly wide nodes
            // First, natural size (no explicit width)
            measurer.style.width = 'auto';
            measurer.style.display = 'inline-block';
            const naturalRect = measurer.getBoundingClientRect();
            let textBoxW = Math.ceil(naturalRect.width);
            let textBoxH = Math.ceil(naturalRect.height);
            if (textBoxW > MAX_TEXT_WIDTH) {
                measurer.style.display = 'block';
                measurer.style.width = MAX_TEXT_WIDTH + 'px';
                textBoxW = MAX_TEXT_WIDTH;
                textBoxH = Math.ceil(measurer.scrollHeight);
            }

            // Now convert text box (which equals .node-text border-box) to node dimensions
            const totalPad = 2 * (nodePadding + borderWidth); // amount added to content box per dimension

            let width, height;
            if (t === 'decision') {
                // For diamonds (rotated square), choose total side S so that:
                // 1) content box width/height (node.contentBox) accommodate text box exactly
                //    node.contentBoxWidth = S - 2*(nodePadding + borderWidth) >= textBoxW
                // 2) axis-aligned rectangle fits within rotated square (inscribed square side S/‚àö2)
                //    textBoxW, textBoxH <= S/‚àö2
                const need1 = textBoxW + totalPad; // ensures content box is wide enough
                const need2 = Math.SQRT2 * Math.max(textBoxW, textBoxH); // ensures inscribed square is large enough
                const S = Math.max(need1, need2, 72); // apply a reasonable minimum
                width = Math.ceil(S);
                height = Math.ceil(S);
            } else if (t === 'start' || t === 'end' || t === 'connector') {
                // Circles: choose diameter D
                // Constraints:
                // 1) content box width accommodates text box => D >= textBoxW + totalPad
                // 2) rectangle (text box) must fit in circle => D >= hypot(textBoxW, textBoxH)
                const needWidth = textBoxW + totalPad;
                const needCircle = Math.hypot(textBoxW, textBoxH);
                const D = Math.max(needWidth, needCircle, 48);
                width = height = Math.ceil(D);
            } else if (t === 'data') {
                // Hexagon: approximate as rectangle plus a small inset to avoid clip; keep tight
                const inset = 6; // small visual margin
                width = Math.max(80, Math.ceil(textBoxW + totalPad + inset));
                height = Math.max(40, Math.ceil(textBoxH + totalPad + inset));
            } else {
                // Rectangles: tight fit to text box + paddings
                width = Math.max(80, Math.ceil(textBoxW + totalPad));
                height = Math.max(40, Math.ceil(textBoxH + totalPad));
            }

            node.dimensions = node.dimensions || {};
            node.dimensions.width = width;
            node.dimensions.height = height;
        }

        function updateShapePreview() {
            // Could add visual preview of shape here
            const nodeType = document.getElementById('nodeType').value;
        }

        function updateRotationPreview() {
            const rotation = document.getElementById('nodeRotation').value;
            document.getElementById('rotationValue').textContent = rotation + '¬∞';
        }

        // Add keyboard shortcuts (and extended ones)
        document.addEventListener('keydown', (e) => {
            if (!editMode) return;
            if (e.key === 'Escape') {
                closeNodeEditor();
                closeEdgeEditor();
                cancelEdgeCreation();
                // Cancel click-to-connect mode
                clickConnectState = null;
                hoveredNodeEl = null;
                // Leave info panel content as-is; do not clear on Esc
            } else if (e.key === 'Delete' && selectedEdgeId) {
                deleteSelectedEdge();
            } else if ((e.key === 'c' || e.key === 'C')) {
                // Arm click-to-connect from the currently selected node element
                const src = selectedNodeElement;
                if (src) {
                    clickConnectState = { sourceNodeId: src.dataset.nodeId };
                    showMessage('Click a target node to connect', 'info');
                    hoveredNodeEl = src;
                    updateInfoPanelForNode(src);
                } else {
                    showMessage('Select a source node first, then press C', 'info');
                }
            }
            // Global app shortcuts (Cmd/Ctrl)
            const cmd = e.metaKey || e.ctrlKey;
            if (cmd && !e.shiftKey && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                saveDiagram(false);
            } else if (cmd && e.shiftKey && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                openSaveAsModal();
            } else if (cmd && (e.key === 'o' || e.key === 'O')) {
                e.preventDefault();
                openOpenDiagramModal();
            } else if (cmd && (e.key === 'n' || e.key === 'N')) {
                e.preventDefault();
                openNewDiagramModal();
            }
        });

        // Click-to-connect state
        let clickConnectState = null;

        async function deleteNode(node, nodeElement) {
            if (!currentDiagram) return;

            // Remove from diagram data
            const nodeIndex = currentDiagram.nodes.findIndex(n => n.id === node.id);
            if (nodeIndex > -1) {
                currentDiagram.nodes.splice(nodeIndex, 1);
            }

            // Remove edges connected to this node
            currentDiagram.edges = currentDiagram.edges.filter(edge =>
                edge.from !== node.id && edge.to !== node.id
            );

            // Remove visual element
            nodeElement.remove();
            if (selectedNodeElement === nodeElement) selectedNodeElement = null;

            // Update connections
            updateConnections();

            // Mark as changed
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            scheduleAutoSave();
            // Immediate autosave on delete (force even if flags not set yet)
            await saveDiagram(true, true);

            closeNodeEditor();
            showMessage('Node deleted successfully!', 'success');
            updateDiagramInfoBox();
        }

        // Tabs removed: Bootstrap Accordion is used for categories

        function setSize(width, height) {
            const type = (document.getElementById('nodeType') || {}).value;
            if (type === 'decision') {
                const size = Math.max(width, height);
                document.getElementById('nodeWidth').value = size;
                document.getElementById('nodeHeight').value = size;
            } else {
                document.getElementById('nodeWidth').value = width;
                document.getElementById('nodeHeight').value = height;
            }
        }

        function autoResizeCurrentNode() {
            if (!editingNode || !editingNodeElement) return;

            // Get current name from the form
            const currentName = document.getElementById('nodeName').value;
            const currentType = document.getElementById('nodeType').value;

            // Temporarily update node for measurement
            const tempNode = { ...editingNode, name: currentName, type: currentType };
            autoResizeNode(tempNode, null);

            // Update the form inputs
            document.getElementById('nodeWidth').value = tempNode.dimensions.width;
            document.getElementById('nodeHeight').value = tempNode.dimensions.height;

            // Apply the new dimensions to the actual node
            editingNode.dimensions = editingNode.dimensions || {};
            editingNode.dimensions.width = tempNode.dimensions.width;
            editingNode.dimensions.height = tempNode.dimensions.height;

            // Clear manual size flag so it will auto-resize in the future
            editingNode.manualSize = false;

            // Update the visual element immediately
            updateNodeVisual(editingNode, editingNodeElement);

            // Update connections
            updateConnections();

            // Mark as changed
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            scheduleAutoSave();

            // Immediate silent autosave for auto-size changes
            saveDiagram(true);

            showMessage('Node auto-resized to fit text!', 'success');
        }

        function renderFlowchart(diagram) {

            const display = document.getElementById('flowchartDisplay');


            display.innerHTML = '';
            // Clear any previous selection
            selectedNodeElement = null;
            display.style.position = 'relative';
            display.style.height = `100%`; // CSS parent (.diagram-layout) controls the height
            display.style.overflow = 'auto';

            // Create a stage wrapper so we can scale contents together
            const stage = document.createElement('div');
            stage.id = 'diagramStage';
            stage.style.position = 'absolute';
            stage.style.inset = '0';
            stage.style.transformOrigin = '0 0';
            stage.style.zIndex = '1';
            display.appendChild(stage);

            // Re-apply grid overlay if enabled (rendering cleared the container)
            if (gridEnabled) {
                showGrid();
            }

            if (!diagram || !diagram.nodes) {
                console.error('Invalid diagram data:', diagram);
                display.innerHTML = '<div style="color: red;">Invalid diagram data</div>';
                return;
            }



            // Find bounds
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            diagram.nodes.forEach(node => {
                minX = Math.min(minX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxX = Math.max(maxX, node.position.x + (node.dimensions?.width || 100));
                maxY = Math.max(maxY, node.position.y + (node.dimensions?.height || 50));
            });



            const padding = 50;
            const containerWidth = maxX - minX + 2 * padding;
            const containerHeight = maxY - minY + 2 * padding;

            // Create or reuse SVG for connections
            let svg = stage.querySelector('svg.connections-layer');

            // Remove any duplicate connections SVGs first (but keep grid SVG)
            const connectionsSvgs = display.querySelectorAll('svg.connections-layer');
            if (connectionsSvgs.length > 1) {

                // Keep the first one, remove the rest
                for (let i = 1; i < connectionsSvgs.length; i++) {
                    connectionsSvgs[i].remove();
                }
                svg = connectionsSvgs[0]; // Use the first one
            }

            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.className = 'connections-layer';
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.zIndex = '1';
                svg.style.pointerEvents = 'auto';
                stage.appendChild(svg);
            }

            // Ensure a dedicated edges group exists and clear it
            let edgesGroup = svg.querySelector('g.edges-layer');
            if (!edgesGroup) {
                edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                edgesGroup.setAttribute('class', 'edges-layer');
                svg.appendChild(edgesGroup);
            } else {
                const allEdgeGroups = svg.querySelectorAll('g.edges-layer');
                if (allEdgeGroups.length > 1) {
                    for (let i = 1; i < allEdgeGroups.length; i++) allEdgeGroups[i].remove();
                    edgesGroup = allEdgeGroups[0];
                }
            }
            // Remove any stray edge elements directly under the SVG (not in edges group)
            const strayAtRoot = Array.from(svg.children).filter(el =>
                el.tagName && ['LINE', 'POLYGON', 'TEXT', 'RECT', 'PATH', 'CIRCLE', 'ELLIPSE'].includes(el.tagName) &&
                el.getAttribute('class') !== 'edges-layer'
            );
            if (strayAtRoot.length) {

                strayAtRoot.forEach(el => el.remove());
            }

            edgesGroup.replaceChildren();




            // Ensure all nodes have IDs (generate if missing)
            diagram.nodes.forEach((node, index) => {
                if (!node.id || !node.id.trim()) {
                    node.id = node.type || `node_${index}`;
                }
                if (!node.name || !node.name.trim()) {
                    node.name = `${node.type || 'Node'} ${index + 1}`;
                }
            });

            // Also update edges to match the node IDs we just created
            if (diagram.edges) {
                diagram.edges.forEach(edge => {
                    // Try to find nodes by the edge's from/to values
                    const fromNode = diagram.nodes.find(n => n.type === edge.from || n.id === edge.from);
                    const toNode = diagram.nodes.find(n => n.type === edge.to || n.id === edge.to);
                    if (fromNode) edge.from = fromNode.id;
                    if (toNode) edge.to = toNode.id;
                });
            }

            // Create a map of node positions for edge drawing
            const nodePositions = {};
            const validNodes = diagram.nodes.filter(node => node.id && node.id.trim());


            diagram.nodes.filter(node => node.id && node.id.trim()).forEach(node => {
                const x = node.position.x - minX + padding;
                const y = node.position.y - minY + padding;
                const width = node.dimensions?.width || 100;
                const height = node.dimensions?.height || 50;
                nodePositions[node.id] = {
                    id: node.id,  // Add the node ID so calculateConnectionPoints can find the DOM element
                    x: x,
                    y: y,
                    centerX: x + width / 2,
                    centerY: y + height / 2,
                    width: width,
                    height: height,
                    type: node.type || 'process'
                };
            });

            // Create nodes first (edges will be drawn after all nodes are in the DOM)
            const nodesToRender = diagram.nodes.filter(node => node.id && node.id.trim());


            diagram.nodes.filter(node => node.id && node.id.trim()).forEach((node, index) => {

                // Auto-size only if dimensions are missing
                if (!node.dimensions || !node.dimensions.width || !node.dimensions.height) {
                    autoResizeNode(node, null);
                }

                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                if ((node.type || '').toLowerCase() === 'decision') {
                    nodeEl.classList.add('decision-node');
                }
                nodeEl.dataset.nodeId = node.id; // Store node ID for updates

                // Create text container
                const textEl = document.createElement('div');
                textEl.className = 'node-text';
                textEl.textContent = node.name || `Node ${index + 1}`;

                // Apply text positioning
                const textPos = node.textPosition || { horizontal: 'center', vertical: 'center' };
                const textAlign = node.textAlign || 'center';

                textEl.style.alignItems = textPos.vertical;
                textEl.style.justifyContent = textPos.horizontal;
                textEl.style.textAlign = textAlign;

                nodeEl.appendChild(textEl);

                // Inline label editing on click (true inline, contentEditable)
                textEl.addEventListener('click', (ev) => {
                    if (!editMode || !appSettings.inlineLabelEditingEnabled) return;
                    ev.stopPropagation();
                    // If already editing, ignore
                    if (textEl.isContentEditable) return;
                    // Pause dragging and enter editing state
                    disableDragging(nodeEl);
                    nodeEl.classList.add('editing');
                    // Enable contentEditable on the text element
                    textEl.contentEditable = 'true';
                    textEl.spellcheck = false;
                    // Ensure the side panel with the Node Editor is visible while live editing
                    try { setSelectedNode(nodeEl); openNodeEditor(node, nodeEl); } catch (_) { /* non-fatal */ }
                    // Remember original state for cancel
                    const original = {
                        text: node.name || '',
                        w: node.dimensions?.width,
                        h: node.dimensions?.height
                    };
                    // Focus and move caret to end
                    const range = document.createRange();
                    const sel = window.getSelection();
                    range.selectNodeContents(textEl);
                    range.collapse(false); // end
                    sel.removeAllRanges();
                    sel.addRange(range);
                    textEl.focus();

                    function commit(save) {
                        // Exit editing state and disable contentEditable
                        textEl.contentEditable = 'false';
                        nodeEl.classList.remove('editing');
                        enableDragging(nodeEl);
                        const val = (textEl.textContent || '').trim();
                        if (!save) {
                            // Revert text and size
                            textEl.textContent = original.text;
                            if (original.w && original.h) {
                                node.dimensions = node.dimensions || {};
                                node.dimensions.width = original.w;
                                node.dimensions.height = original.h;
                                nodeEl.style.width = original.w + 'px';
                                nodeEl.style.height = original.h + 'px';
                                updateConnections();
                            }
                            return;
                        }
                        if (val === (node.name || '')) return;
                        // Update node data and auto-resize
                        node.name = val;
                        node.manualSize = false;
                        autoResizeNode(node, nodeEl);
                        // Apply new size
                        nodeEl.style.width = node.dimensions.width + 'px';
                        nodeEl.style.height = node.dimensions.height + 'px';
                        updateConnections();
                        // Mark changed and autosave
                        hasUnsavedChanges = true;
                        const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                        scheduleAutoSave();
                        saveDiagram(true);
                    }

                    // Live auto-size as user types
                    const onInput = () => {
                        const temp = { ...node, name: (textEl.textContent || ''), manualSize: false };
                        autoResizeNode(temp, nodeEl);
                        nodeEl.style.width = temp.dimensions.width + 'px';
                        nodeEl.style.height = temp.dimensions.height + 'px';
                        updateConnections();
                    };
                    textEl.addEventListener('input', onInput);
                    textEl.addEventListener('keyup', onInput);
                    textEl.addEventListener('paste', () => setTimeout(onInput, 0));
                    textEl.addEventListener('compositionend', onInput);

                    const onKey = (e) => {
                        if (e.key === 'Enter') { e.preventDefault(); commit(true); cleanup(); }
                        else if (e.key === 'Escape') { e.preventDefault(); commit(false); cleanup(); }
                    };
                    textEl.addEventListener('keydown', onKey);

                    const onBlur = () => { commit(true); cleanup(); };
                    textEl.addEventListener('blur', onBlur, { once: true });

                    function cleanup() {
                        textEl.removeEventListener('input', onInput);
                        textEl.removeEventListener('keyup', onInput);
                        textEl.removeEventListener('paste', onInput);
                        textEl.removeEventListener('compositionend', onInput);
                        textEl.removeEventListener('keydown', onKey);
                    }
                });

                // Mini toolbar (Shape | X) shown on hover in edit mode (feature-gated)
                let toolbar = null;
                if (appSettings.onCanvasToolbarEnabled) {
                    toolbar = document.createElement('div');
                    toolbar.className = 'node-toolbar';
                    toolbar.innerHTML = `
                    <button type="button" class="tb-btn" data-action="shape" title="Change shape">‚ñ≤ <span>shape</span></button>
                    <button type="button" class="tb-btn delete" data-action="delete" title="Delete step">‚úï</button>
                    <div class="shape-popover">
                        <div class="shape-option" data-shape="process" title="Process">
                            <div style="width:24px;height:16px;border:2px solid #374151;border-radius:4px;"></div>
                            <div class="shape-label">proc</div>
                        </div>
                        <div class="shape-option" data-shape="decision" title="Decision">
                            <div style="width:20px;height:20px;transform:rotate(45deg);border:2px solid #374151;"></div>
                            <div class="shape-label">decision</div>
                        </div>
                        <div class="shape-option" data-shape="start" title="Start">
                            <div style="width:20px;height:20px;border-radius:999px;border:2px solid #374151;"></div>
                            <div class="shape-label">start</div>
                        </div>
                        <div class="shape-option" data-shape="end" title="End">
                            <div style="width:20px;height:20px;border-radius:999px;border:2px solid #374151;"></div>
                            <div class="shape-label">end</div>
                        </div>
                        <div class="shape-option" data-shape="data" title="Data">
                            <div style="width:24px;height:18px;clip-path:polygon(25% 0%,75% 0%,100% 50%,75% 100%,25% 100%,0 50%);border:2px solid #374151;"></div>
                            <div class="shape-label">data</div>
                        </div>
                    </div>`;
                    nodeEl.appendChild(toolbar);

                    const shapeBtn = toolbar.querySelector('[data-action="shape"]');
                    const deleteBtn = toolbar.querySelector('[data-action="delete"]');
                    const popover = toolbar.querySelector('.shape-popover');
                    function togglePopover(show) {
                        if (show) popover.classList.add('open'); else popover.classList.remove('open');
                    }
                    shapeBtn.addEventListener('click', (e) => {
                        if (!editMode) return;
                        e.stopPropagation();
                        togglePopover(!popover.classList.contains('open'));
                    });
                    // Popover closing handled by a single global document listener (see below)
                    // Handle shape selection
                    popover.querySelectorAll('.shape-option').forEach(opt => {
                        opt.addEventListener('click', (e) => {
                            if (!editMode) return;
                            e.stopPropagation();
                            const newType = opt.getAttribute('data-shape');
                            if (!newType || newType === node.type) { togglePopover(false); return; }
                            node.type = newType;
                            // Clear manual size to allow auto-sizing to adjust to new shape
                            node.manualSize = false;
                            autoResizeNode(node, null);
                            // Re-render just this node visually using existing util
                            updateNodeVisual(node, nodeEl);
                            // Rebuild resize handles to reflect new shape and avoid overlap
                            addResizeHandles(nodeEl, node);
                            updateConnections();
                            togglePopover(false);
                            hasUnsavedChanges = true;
                            const sb = document.getElementById('saveButton'); if (sb) sb.classList.add('show');
                            scheduleAutoSave();
                            saveDiagram(true);
                        });
                    });
                    // Delete button
                    deleteBtn.addEventListener('click', (e) => {
                        if (!editMode) return;
                        e.stopPropagation();
                        // quick confirm
                        if (!confirm('Delete this step and its connectors?')) return;
                        deleteNode(node, nodeEl);
                    });
                }

                // In-canvas delete button removed; deletion is handled in Node Editor

                // Add connection points on each side (different positioning for different shapes)
                let connectionPoints;
                if (node.type === 'decision') {
                    // Diamond is a square rotated 45¬∞. Place connectors at the unrotated square's corners
                    // so that after rotation they land exactly on the diamond's vertices.
                    // Corner ‚Üî side mapping after 45¬∞ rotation:
                    //  - top-left  -> top vertex
                    //  - top-right -> right vertex
                    //  - bottom-right -> bottom vertex
                    //  - bottom-left -> left vertex
                    connectionPoints = [
                        { side: 'top', x: '0%', y: '0%', transform: 'translate(-50%, -50%)' },
                        { side: 'right', x: '100%', y: '0%', transform: 'translate(-50%, -50%)' },
                        { side: 'bottom', x: '100%', y: '100%', transform: 'translate(-50%, -50%)' },
                        { side: 'left', x: '0%', y: '100%', transform: 'translate(-50%, -50%)' }
                    ];
                } else if (node.type === 'start' || node.type === 'end') {
                    // Circular shapes - connection points at the actual edge of the circle
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: 'translate(-50%, -50%)' },
                        { side: 'right', x: '100%', y: '50%', transform: 'translate(-50%, -50%)' },
                        { side: 'bottom', x: '50%', y: '100%', transform: 'translate(-50%, -50%)' },
                        { side: 'left', x: '0%', y: '50%', transform: 'translate(-50%, -50%)' }
                    ];
                } else if (node.type === 'data') {
                    // Hexagon shapes - inset points slightly to avoid clip-path cutting them off
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '6%', transform: 'translate(-50%, -50%)' },
                        { side: 'right', x: '94%', y: '50%', transform: 'translate(-50%, -50%)' },
                        { side: 'bottom', x: '50%', y: '94%', transform: 'translate(-50%, -50%)' },
                        { side: 'left', x: '6%', y: '50%', transform: 'translate(-50%, -50%)' }
                    ];
                } else {
                    // Rectangular shapes - connection points at middle of each side
                    connectionPoints = [
                        { side: 'top', x: '50%', y: '0%', transform: 'translate(-50%, -50%)' },
                        { side: 'right', x: '100%', y: '50%', transform: 'translate(-50%, -50%)' },
                        { side: 'bottom', x: '50%', y: '100%', transform: 'translate(-50%, -50%)' },
                        { side: 'left', x: '0%', y: '50%', transform: 'translate(-50%, -50%)' }
                    ];
                }

                connectionPoints.forEach(point => {
                    const connectionPoint = document.createElement('div');
                    connectionPoint.className = 'connection-point';
                    connectionPoint.dataset.side = point.side;
                    connectionPoint.dataset.nodeId = node.id;
                    connectionPoint.style.position = 'absolute';
                    connectionPoint.style.left = point.x;
                    connectionPoint.style.top = point.y;
                    connectionPoint.style.transform = point.transform;
                    connectionPoint.style.width = '12px';
                    connectionPoint.style.height = '12px';
                    connectionPoint.style.backgroundColor = 'rgba(52, 152, 219, 0.6)';
                    connectionPoint.style.border = '1px solid rgba(255, 255, 255, 0.7)';
                    connectionPoint.style.borderRadius = '50%';
                    connectionPoint.style.zIndex = '15';
                    connectionPoint.style.cursor = 'crosshair';
                    connectionPoint.style.transition = 'opacity 0.2s, transform 0.2s';

                    // Add hover effects (bolder on hover)
                    connectionPoint.addEventListener('mouseenter', () => {
                        connectionPoint.style.transform = point.transform + ' scale(1.12)';
                        connectionPoint.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.9), 0 2px 8px rgba(0,0,0,0.2)';
                        connectionPoint.style.backgroundColor = 'rgba(41, 128, 185, 0.95)';
                        connectionPoint.style.borderColor = 'rgba(255,255,255,1)';
                    });

                    connectionPoint.addEventListener('mouseleave', () => {
                        connectionPoint.style.transform = point.transform + ' scale(1)';
                        connectionPoint.style.boxShadow = '';
                        connectionPoint.style.backgroundColor = 'rgba(52, 152, 219, 0.6)';
                        connectionPoint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
                    });

                    // Begin connection on mousedown/touch
                    connectionPoint.addEventListener('mousedown', (evt) => {
                        if (!editMode) return;
                        evt.preventDefault(); evt.stopPropagation();
                        startEdgeCreation(connectionPoint, evt.clientX, evt.clientY);
                    });
                    connectionPoint.addEventListener('touchstart', (evt) => {
                        if (!editMode) return;
                        const t = evt.touches[0];
                        evt.preventDefault(); evt.stopPropagation();
                        startEdgeCreation(connectionPoint, t.clientX, t.clientY);
                    }, { passive: false });

                    // Double-click to auto-add a connected step on this side
                    connectionPoint.addEventListener('dblclick', (evt) => {
                        if (!editMode) return;
                        evt.preventDefault(); evt.stopPropagation();
                        const srcId = nodeEl.dataset.nodeId;
                        addStepFromNode(srcId, point.side);
                    });

                    nodeEl.appendChild(connectionPoint);
                    // No on-canvas labels; shown in Info Panel instead
                });

                // Position relative to container
                const x = node.position.x - minX + padding;
                const y = node.position.y - minY + padding;

                nodeEl.style.left = x + 'px';
                nodeEl.style.top = y + 'px';
                nodeEl.style.width = (node.dimensions?.width || 100) + 'px';
                nodeEl.style.height = (node.dimensions?.height || 50) + 'px';
                nodeEl.style.zIndex = '10';

                // Apply styling
                const style = node.style || {};
                nodeEl.style.backgroundColor = style.fill || getNodeTypeColor(node.type);
                // Add dark borders like Render view
                const borderColor = (style.stroke || '#333');
                // Reset any previous borders/overlays
                nodeEl.style.border = '';
                const existingOverlay = nodeEl.querySelector('.shape-border-overlay');
                if (existingOverlay) existingOverlay.remove();

                // Add special styling for different node types
                if (node.type === 'decision') {
                    nodeEl.style.transform = `rotate(45deg)`;
                    if (node.rotation) {
                        nodeEl.style.transform += ` rotate(${node.rotation}deg)`;
                    }
                    nodeEl.style.transformOrigin = 'center';
                    textEl.style.transform = 'rotate(-45deg)';
                } else if (node.type === 'start' || node.type === 'end') {
                    nodeEl.style.borderRadius = '50%';
                    if (node.rotation) {
                        nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    }
                } else if (node.type === 'data') {
                    nodeEl.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                    if (node.rotation) {
                        nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    }
                    // Use an overlay to draw a clean border around the hexagon
                    const overlay = document.createElement('div');
                    overlay.className = 'shape-border-overlay';
                    Object.assign(overlay.style, {
                        position: 'absolute', top: '0', left: '0', right: '0', bottom: '0',
                        pointerEvents: 'none',
                        clipPath: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
                        boxShadow: `inset 0 0 0 2px ${borderColor}`
                    });
                    nodeEl.appendChild(overlay);
                } else {
                    // Rectangle/process
                    if (node.rotation) {
                        nodeEl.style.transform = `rotate(${node.rotation}deg)`;
                    }
                }

                // Apply border to non-hexagon shapes
                if (node.type !== 'data') {
                    nodeEl.style.border = `2px solid ${borderColor}`;
                }

                // Add click handler (info when not in edit mode, drag when in edit mode)
                let dragStarted = false;
                let mouseDownTime = 0;

                nodeEl.addEventListener('mousedown', (e) => {
                    mouseDownTime = Date.now();
                    dragStarted = false;
                    if (editMode) setSelectedNode(nodeEl);
                    hoveredNodeEl = nodeEl; // track for info updates during drag
                    updateInfoPanelForNode(nodeEl);
                    // Alt/Option + drag from node body starts a connector from the nearest side
                    if (editMode && e.altKey && !e.target.closest('.connection-point')) {
                        e.preventDefault();
                        // Determine nearest side to cursor
                        const rect = nodeEl.getBoundingClientRect();
                        const cx = e.clientX - rect.left;
                        const cy = e.clientY - rect.top;
                        const sides = [
                            { side: 'top', d: Math.abs(cy) },
                            { side: 'bottom', d: Math.abs(rect.height - cy) },
                            { side: 'left', d: Math.abs(cx) },
                            { side: 'right', d: Math.abs(rect.width - cx) }
                        ];
                        sides.sort((a, b) => a.d - b.d);
                        const nearest = sides[0].side;
                        // Find the corresponding connection point element
                        const cp = nodeEl.querySelector(`.connection-point[data-side="${nearest}"]`);
                        if (cp) {
                            startEdgeCreation(cp, e.clientX, e.clientY);
                        }
                    }
                });

                nodeEl.addEventListener('mousemove', (e) => {
                    if (mouseDownTime > 0 && Date.now() - mouseDownTime > 100) {
                        dragStarted = true;
                    }
                    // live update while hovering
                    if (hoveredNodeEl === nodeEl) updateInfoPanelForNode(nodeEl);
                });

                nodeEl.onclick = (e) => {
                    // Only trigger click if it wasn't a drag operation
                    if (!dragStarted) {
                        if (editMode) {
                            // Click-to-connect flow takes precedence
                            if (clickConnectState && clickConnectState.sourceNodeId) {
                                const srcId = clickConnectState.sourceNodeId;
                                const dstId = node.id;
                                clickConnectState = null;
                                if (srcId && dstId && srcId !== dstId) {
                                    currentDiagram.edges = currentDiagram.edges || [];
                                    const newEdge = {
                                        id: `${srcId}-${dstId}-${Date.now()}`,
                                        from: srcId,
                                        to: dstId,
                                        name: '',
                                        style: { stroke: '#34495e', strokeWidth: 2 },
                                        metadata: {}
                                    };
                                    currentDiagram.edges.push(newEdge);
                                    hasUnsavedChanges = true;
                                    document.getElementById('saveButton').classList.add('show');
                                    scheduleAutoSave();
                                    // Immediate autosave on connector add (click-to-connect)
                                    saveDiagram(true);
                                    updateConnections();
                                    updateDiagramInfoBox();
                                    openEdgeEditor(newEdge.id);
                                    dragStarted = false; mouseDownTime = 0; return;
                                }
                            }
                            // Default single-click in edit mode: open Node Editor in the side panel
                            try { setSelectedNode(nodeEl); openNodeEditor(node, nodeEl); } catch (_) { }
                        } else {
                            // View mode: show summary info
                            showNodeInfo(node);
                        }
                    }
                    dragStarted = false;
                    mouseDownTime = 0;
                };

                nodeEl.addEventListener('mouseenter', () => {
                    hoveredNodeEl = nodeEl;
                    updateInfoPanelForNode(nodeEl);
                    openInfoPanelTemp();
                    if (infoPanelCloseTimer) { clearTimeout(infoPanelCloseTimer); infoPanelCloseTimer = null; }
                });
                nodeEl.addEventListener('mouseleave', () => {
                    // Do not clear the info panel on mouse leave; keep last shown info
                    if (hoveredNodeEl === nodeEl) { hoveredNodeEl = null; }
                    if (infoPanelCloseTimer) clearTimeout(infoPanelCloseTimer);
                    infoPanelCloseTimer = setTimeout(() => { maybeCloseInfoPanelTemp(); }, 150);
                });

                // Add double-click handler for editing
                nodeEl.ondblclick = (e) => {
                    if (editMode) {
                        e.stopPropagation();
                        setSelectedNode(nodeEl);
                        openNodeEditor(node, nodeEl);
                    }
                };

                // Add right-click context menu
                nodeEl.oncontextmenu = (e) => {
                    if (editMode) {
                        e.preventDefault();
                        setSelectedNode(nodeEl);
                        openNodeEditor(node, nodeEl);
                    }
                };

                // Add visual indicators for enterprise features
                if (node.integrations?.jira || node.drillDown) {
                    const indicators = document.createElement('div');
                    indicators.style.position = 'absolute';
                    indicators.style.top = '5px';
                    indicators.style.right = '5px';
                    indicators.style.fontSize = '10px';
                    indicators.style.zIndex = '1';

                    if (node.integrations?.jira) {
                        const jiraIcon = document.createElement('span');
                        jiraIcon.textContent = 'üîó';
                        jiraIcon.title = `Jira: ${node.integrations.jira.projectKey}-${node.integrations.jira.issueKey}`;
                        indicators.appendChild(jiraIcon);
                    }

                    if (node.drillDown) {
                        const drillIcon = document.createElement('span');
                        drillIcon.textContent = 'üìã';
                        drillIcon.title = `Drill-down: ${node.drillDown}`;
                        indicators.appendChild(drillIcon);
                    }

                    nodeEl.appendChild(indicators);
                }

                // Enable dragging for all nodes
                enableDragging(nodeEl);

                // Add resize handles (east, south, southeast)
                addResizeHandles(nodeEl, node);

                stage.appendChild(nodeEl);
            });

            // Draw edges after all nodes are created and added to the DOM
            // Use setTimeout to ensure DOM is fully updated
            setTimeout(() => {
                if (diagram.edges) {
                    diagram.edges.filter(edge => edge.from && edge.to && edge.from.trim() && edge.to.trim()).forEach(edge => {
                        const fromNode = nodePositions[edge.from];
                        const toNode = nodePositions[edge.to];

                        if (fromNode && toNode) {
                            drawEdge(edgesGroup, fromNode, toNode, edge);
                        }
                    });
                }
            }, 10); // Small delay to ensure DOM is ready

            // Apply current zoom to the stage and update the info box
            applyZoom();
            updateDiagramInfoBox();
            if (hoveredNodeEl) updateInfoPanelForNode(hoveredNodeEl);
        }

        function applyZoom() {
            const stage = document.getElementById('diagramStage');
            if (stage) {
                stage.style.transformOrigin = '0 0';
                stage.style.transform = `scale(${zoomScale})`;
            }
            const grid = document.querySelector('#flowchartDisplay svg.grid-overlay');
            if (grid) grid.style.transform = `scale(${zoomScale})`;
            if (grid) grid.style.transformOrigin = '0 0';
            const label = document.getElementById('zoomLevelLabel');
            if (label) label.textContent = `${Math.round(zoomScale * 100)}%`;
            try { localStorage.setItem('flowgen.zoomScale', String(zoomScale)); } catch (_) { }
            // Recompute connectors after zoom so old lines and labels are cleared and redrawn
            // Note: updateConnections() safely clears the edges layer before drawing
            updateConnections();
            // Update info panel positions if hovering
            if (hoveredNodeEl) updateInfoPanelForNode(hoveredNodeEl);
        }

        function zoomIn() { zoomScale = Math.min(ZOOM_MAX, +(zoomScale + ZOOM_STEP).toFixed(2)); applyZoom(); }
        function zoomOut() { zoomScale = Math.max(ZOOM_MIN, +(zoomScale - ZOOM_STEP).toFixed(2)); applyZoom(); }
        // Warn if navigating away with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
        function zoomReset() { zoomScale = 1.0; applyZoom(); }

        // ============ ALIGNMENT FUNCTIONS ============
        function clusterValues(sortedValues, tolerance) {
            // Input must be sorted array of numbers
            const groups = [];
            let current = [];
            for (let i = 0; i < sortedValues.length; i++) {
                const v = sortedValues[i];
                if (current.length === 0) {
                    current.push(v);
                } else {
                    const last = current[current.length - 1];
                    if (Math.abs(v - last) <= tolerance) {
                        current.push(v);
                    } else {
                        groups.push(current);
                        current = [v];
                    }
                }
            }
            if (current.length) groups.push(current);
            // Return group centers (mean) and original group arrays
            return groups.map(g => ({
                values: g,
                center: g.reduce((a, b) => a + b, 0) / g.length
            }));
        }

        function normalizeCenters(centers, spacingHint) {
            // centers: sorted numeric array; return normalized equally spaced centers preserving count
            if (centers.length <= 1) return centers.slice();
            const minC = centers[0];
            const maxC = centers[centers.length - 1];
            let spacing = spacingHint;
            if (!spacing) {
                // average delta
                let sum = 0;
                let cnt = 0;
                for (let i = 1; i < centers.length; i++) { sum += (centers[i] - centers[i - 1]); cnt++; }
                spacing = cnt ? (sum / cnt) : (gridSize * 3);
            }
            // Snap spacing to grid to make it look consistent
            spacing = Math.max(gridSize, Math.round(spacing / gridSize) * gridSize);
            const norm = [Math.round(minC / gridSize) * gridSize];
            for (let i = 1; i < centers.length; i++) norm.push(norm[i - 1] + spacing);
            return norm;
        }

        function alignDiagram() {
            const display = document.getElementById('flowchartDisplay');
            const nodes = Array.from(display.querySelectorAll('.node'));
            if (!nodes.length) return;

            // Gather node metrics
            const metrics = nodes.map(nodeEl => {
                const x = parseInt(nodeEl.style.left) || 0;
                const y = parseInt(nodeEl.style.top) || 0;
                const w = nodeEl.offsetWidth;
                const h = nodeEl.offsetHeight;
                const cx = x + w / 2;
                const cy = y + h / 2;
                return { nodeEl, x, y, w, h, cx, cy };
            });

            // Tolerance for clustering (use ~gridSize)
            const tol = Math.max(10, gridSize);

            // Cluster Y (rows) by centerY
            const sortedCY = metrics.map(m => m.cy).sort((a, b) => a - b);
            const yGroups = clusterValues(sortedCY, tol);
            let yCenters = yGroups.map(g => g.center).sort((a, b) => a - b);
            if (yCenters.length > 1) {
                // Normalize spacing for consistent rows
                yCenters = normalizeCenters(yCenters);
            }

            // Cluster X (columns) by centerX
            const sortedCX = metrics.map(m => m.cx).sort((a, b) => a - b);
            const xGroups = clusterValues(sortedCX, tol);
            let xCenters = xGroups.map(g => g.center).sort((a, b) => a - b);
            if (xCenters.length > 1) {
                // Normalize spacing for consistent columns
                xCenters = normalizeCenters(xCenters);
            }

            // For mapping: assign each node to nearest row and column center
            function nearest(arr, value) {
                let best = arr[0];
                let bestD = Math.abs(value - best);
                for (let i = 1; i < arr.length; i++) {
                    const d = Math.abs(value - arr[i]);
                    if (d < bestD) { best = arr[i]; bestD = d; }
                }
                return best;
            }

            // Move nodes to aligned centers
            const displayRect = display.getBoundingClientRect();
            metrics.forEach(m => {
                const targetCY = yCenters.length ? nearest(yCenters, m.cy) : m.cy;
                const targetCX = xCenters.length ? nearest(xCenters, m.cx) : m.cx;
                let targetX = Math.round(targetCX - m.w / 2);
                let targetY = Math.round(targetCY - m.h / 2);

                // Snap to grid using shape-aware snapping
                const snapped = snapNodePosition(m.nodeEl, targetX, targetY, false);
                targetX = snapped.x; targetY = snapped.y;

                // Constrain within container
                const maxX = displayRect.width - m.w;
                const maxY = displayRect.height - m.h;
                targetX = Math.max(0, Math.min(targetX, maxX));
                targetY = Math.max(0, Math.min(targetY, maxY));

                m.nodeEl.style.left = targetX + 'px';
                m.nodeEl.style.top = targetY + 'px';
            });

            // Persist and redraw
            updateDiagramData();
            updateConnections();
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            showMessage('Diagram aligned', 'success');
        }

        // ============ APPLICATION SETTINGS (Persistent) ============
        const defaultAppSettings = {
            gridEnabled: false,
            snapToGrid: false,
            gridSize: 25,
            gridColor: '#bdc3c7',
            gridOpacity: 0.3,
            // Info panel: 'auto' (open on hover) or 'locked' (always open)
            infoPanelMode: 'auto',
            // Feature flags: enable inline editing only, keep toolbar off
            inlineLabelEditingEnabled: true,
            onCanvasToolbarEnabled: false
        };
        let appSettings = { ...defaultAppSettings };

        function loadAppSettings() {
            try {
                const raw = localStorage.getItem('flowgen.settings');
                if (raw) {
                    const parsed = JSON.parse(raw);
                    appSettings = { ...defaultAppSettings, ...parsed };
                } else {
                    appSettings = { ...defaultAppSettings };
                }
            } catch (_) {
                appSettings = { ...defaultAppSettings };
            }
            applySettings(false); // apply without forcing redraw
            // Also apply non-grid UI based on settings
            try { populateNavbarInfoPanelMode(); } catch (_) { }
        }

        function saveAppSettings() {
            // Persist current form values, then apply
            collectSettingsFromForm(appSettings);
            saveAppSettingsSilent();
            applySettings(true); // apply and refresh grid
            showMessage('Settings saved', 'success');
        }

        function saveAppSettingsSilent() {
            try {
                localStorage.setItem('flowgen.settings', JSON.stringify(appSettings));
            } catch (_) { /* ignore */ }
        }

        function resetAppSettings() {
            appSettings = { ...defaultAppSettings };
            saveAppSettingsSilent();
            populateSettingsForm();
            applySettings(true);
            showMessage('Settings reset to defaults', 'success');
        }

        function populateSettingsForm() {
            const gridEnabledEl = document.getElementById('settingsGridEnabled');
            const snapEl = document.getElementById('settingsSnapToGrid');
            const sizeEl = document.getElementById('settingsGridSize');
            const colorEl = document.getElementById('settingsGridColor');
            const opacityEl = document.getElementById('settingsGridOpacity');

            if (gridEnabledEl) gridEnabledEl.checked = !!appSettings.gridEnabled;
            if (snapEl) snapEl.checked = !!appSettings.snapToGrid;
            if (sizeEl) sizeEl.value = appSettings.gridSize;
            if (colorEl) colorEl.value = appSettings.gridColor || '#bdc3c7';
            if (opacityEl) opacityEl.value = appSettings.gridOpacity ?? 0.3;
        }

        // Keep ribbon grid controls in sync with app settings
        function populateRibbonGridControls() {
            const snapEl = document.getElementById('ribbonSnapToGrid');
            const sizeEl = document.getElementById('ribbonGridSize');
            const colorEl = document.getElementById('ribbonGridColor');
            const opacityEl = document.getElementById('ribbonGridOpacity');
            if (snapEl) snapEl.checked = !!appSettings.snapToGrid;
            if (sizeEl) sizeEl.value = appSettings.gridSize;
            if (colorEl) colorEl.value = appSettings.gridColor || '#bdc3c7';
            if (opacityEl) opacityEl.value = appSettings.gridOpacity ?? 0.3;
        }

        function applyRibbonGridChange() {
            // Mirror ribbon controls to appSettings and apply immediately
            const snapEl = document.getElementById('ribbonSnapToGrid');
            const sizeEl = document.getElementById('ribbonGridSize');
            const colorEl = document.getElementById('ribbonGridColor');
            const opacityEl = document.getElementById('ribbonGridOpacity');

            if (snapEl) appSettings.snapToGrid = !!snapEl.checked;
            if (sizeEl) appSettings.gridSize = Math.max(5, Math.min(200, parseInt(sizeEl.value || '25', 10)));
            if (colorEl) appSettings.gridColor = colorEl.value || '#bdc3c7';
            if (opacityEl) appSettings.gridOpacity = Math.max(0, Math.min(1, parseFloat(opacityEl.value || '0.3')));

            // Keep runtime vars aligned and redraw grid
            saveAppSettingsSilent();
            applySettings(true);
            // Keep settings form (in Settings tab) in sync too
            populateSettingsForm();
        }

        // ===== Navbar: Info Panel Mode =====
        function populateNavbarInfoPanelMode() {
            const auto = document.getElementById('navInfoModeAuto');
            const locked = document.getElementById('navInfoModeLocked');
            const mode = appSettings.infoPanelMode || 'auto';
            if (auto) auto.checked = (mode === 'auto');
            if (locked) locked.checked = (mode === 'locked');
        }
        function onNavbarInfoPanelModeChange(e) {
            const val = e && e.target ? e.target.value : 'auto';
            appSettings.infoPanelMode = (val === 'locked') ? 'locked' : 'auto';
            saveAppSettingsSilent();
            // When switching to locked, ensure panel is open; when switching to auto, collapse unless editing/hovering
            const panel = document.getElementById('infoPanel');
            if (panel) {
                if (appSettings.infoPanelMode === 'locked') {
                    panel.classList.add('temp-open');
                } else {
                    if (!editorDocked && !hoveredNodeEl && !infoPanelHover) {
                        panel.classList.remove('temp-open');
                    }
                }
            }
            applyInfoPanelState();
        }

        // Dropdown open/close logic for Grid
        function toggleGridDropdown(event) {
            event.stopPropagation();
            const dd = document.getElementById('gridDropdown');
            if (!dd) return;
            dd.classList.toggle('open');
        }
        // Close dropdown on outside click or Escape; also close any shape popovers (if feature enabled)
        document.addEventListener('click', (e) => {
            const dd = document.getElementById('gridDropdown');
            if (dd && !dd.contains(e.target)) dd.classList.remove('open');
            // Close all shape popovers if clicking outside
            if (appSettings && appSettings.onCanvasToolbarEnabled) {
                document.querySelectorAll('.shape-popover.open').forEach(pop => {
                    const shapeBtn = pop.parentElement?.querySelector('[data-action="shape"]');
                    if (!pop.contains(e.target) && e.target !== shapeBtn) {
                        pop.classList.remove('open');
                    }
                });
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const dd = document.getElementById('gridDropdown');
                if (dd) dd.classList.remove('open');
                // Escape closes the docked node editor if open
                if (editorDocked) {
                    e.stopPropagation();
                    closeNodeEditor();
                }
                // Escape closes any open shape popovers
                if (appSettings && appSettings.onCanvasToolbarEnabled) {
                    document.querySelectorAll('.shape-popover.open').forEach(pop => pop.classList.remove('open'));
                }
            }
        });

        // Grid button UI removed

        function applySettings(refreshGrid) {
            gridEnabled = !!appSettings.gridEnabled;
            snapToGrid = !!appSettings.snapToGrid;
            gridSize = parseInt(appSettings.gridSize || 25, 10);
            gridColor = appSettings.gridColor || '#bdc3c7';
            gridOpacity = (appSettings.gridOpacity ?? 0.3);

            // grid button UI removed

            if (refreshGrid) {
                // Recreate the grid with new settings; do not force in edit mode
                if (gridEnabled) { showGrid(); } else { hideGrid(); }
                updateConnections();
            }

            // Whenever settings are applied, reflect them into ribbon controls
            populateRibbonGridControls();
        }

        function collectSettingsFromForm(target) {
            const gridEnabledEl = document.getElementById('settingsGridEnabled');
            const snapEl = document.getElementById('settingsSnapToGrid');
            const sizeEl = document.getElementById('settingsGridSize');
            const colorEl = document.getElementById('settingsGridColor');
            const opacityEl = document.getElementById('settingsGridOpacity');

            if (gridEnabledEl) target.gridEnabled = !!gridEnabledEl.checked;
            if (snapEl) target.snapToGrid = !!snapEl.checked;
            if (sizeEl) target.gridSize = Math.max(5, Math.min(200, parseInt(sizeEl.value || '25', 10)));
            if (colorEl) target.gridColor = colorEl.value || '#bdc3c7';
            if (opacityEl) target.gridOpacity = Math.max(0, Math.min(1, parseFloat(opacityEl.value || '0.3')));
        }

        // Apply Now: apply current form values without saving to localStorage
        function applyAppSettings() {
            const temp = { ...appSettings };
            collectSettingsFromForm(temp);
            appSettings = temp;
            saveAppSettingsSilent(); // persist immediately on change
            applySettings(true);
        }

        // Initialize settings on load
        document.addEventListener('DOMContentLoaded', () => {
            loadAppSettings();
            populateRibbonGridControls();
            populateNavbarGridControls();
            populateNavbarInfoPanelMode();
            // Force grid and snapping off by default (override any older saved setting)
            appSettings.gridEnabled = false;
            appSettings.snapToGrid = false;
            saveAppSettingsSilent();
            applySettings(true);
            // Grid is not auto-shown; only render if explicitly enabled (kept for completeness)
            if (gridEnabled) { showGrid(); }
            // grid button UI removed
            // Initialize color picker controls and favorites container
            try { initColorPickerControls(); renderFavoriteColors(); } catch (_) { }
            // Initialize info panel with a diagram summary
            renderDiagramSummaryInPanel();
            // If locked mode, mark as open immediately
            if ((appSettings.infoPanelMode || 'auto') === 'locked') {
                const panel = document.getElementById('infoPanel');
                if (panel) panel.classList.add('temp-open');
            }
            // Ensure visual state reflects mode
            applyInfoPanelState();
        });

        // Removed the Add Step (+) overlay in favor of double-clicking connection points

        function addStepFromNode(sourceNodeId, side, newType) {
            if (!currentDiagram) return;
            const source = currentDiagram.nodes.find(n => n.id === sourceNodeId);
            if (!source) return;

            // Create a new node (default process)
            const newId = `${sourceNodeId}_step_${Date.now()}`;
            const defaultW = 120, defaultH = 60;
            const gap = Math.max(40, gridSize * 2);

            // Compute new node position relative to source node position in the DOM coordinates
            const sourceEl = document.querySelector(`[data-node-id="${sourceNodeId}"]`);
            const x = parseInt(sourceEl.style.left) || 0;
            const y = parseInt(sourceEl.style.top) || 0;
            const w = sourceEl.offsetWidth;
            const h = sourceEl.offsetHeight;
            let newLeft = x, newTop = y;
            switch (side) {
                case 'top': newLeft = x; newTop = y - gap - defaultH; break;
                case 'bottom': newLeft = x; newTop = y + h + gap; break;
                case 'left': newLeft = x - gap - defaultW; newTop = y; break;
                case 'right': newLeft = x + w + gap; newTop = y; break;
                default: newLeft = x + w + gap; newTop = y; break;
            }
            // Snap new position
            const snapped = snapToGrid ? snapToGridPosition(newLeft, newTop) : { x: newLeft, y: newTop };

            const display = document.getElementById('flowchartDisplay');
            const displayRect = display.getBoundingClientRect();
            // Convert DOM position back to diagram coordinates (+padding offset)
            const diagramX = snapped.x + 50;
            const diagramY = snapped.y + 50;

            const t = newType || 'process';
            const newNode = {
                id: newId,
                name: 'New Step',
                type: t,
                position: { x: diagramX, y: diagramY },
                dimensions: { width: defaultW, height: defaultH },
                style: { fill: getNodeTypeColor(t) }
            };
            currentDiagram.nodes.push(newNode);

            // Create an edge from source to new node (direction depends on side: default from source to new)
            currentDiagram.edges = currentDiagram.edges || [];
            const edge = {
                id: `${sourceNodeId}-${newId}-${Date.now()}`,
                from: sourceNodeId,
                to: newId,
                name: '',
                style: { stroke: '#34495e', strokeWidth: 2 },
                metadata: {}
            };
            currentDiagram.edges.push(edge);

            // Re-render
            renderFlowchart(currentDiagram);
            updateConnections();
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            // Autosave when adding a connected step (creates a connector)
            scheduleAutoSave();
            saveDiagram(true);
            updateDiagramInfoBox();

            // Open node editor for the new step so the user can name it/configure
            const newNodeEl = document.querySelector(`[data-node-id="${newId}"]`);
            if (newNodeEl) {
                openNodeEditor(newNode, newNodeEl);
            }
        }

        // Quick Add from ribbon: adds a new node near the center if diagram is empty,
        // or adds to the right of the last selected node (if any), else near top-left.
        function quickAddNode() {
            const typeSel = document.getElementById('insertNodeType');
            const t = typeSel ? (typeSel.value || 'process') : 'process';
            if (!currentDiagram) {
                // Create a new empty diagram shell if none exists yet
                currentDiagram = { id: 'untitled', name: 'Untitled', version: '1.0.0', nodes: [], edges: [], layout: { direction: 'top-bottom' } };
            }
            const display = document.getElementById('flowchartDisplay');
            const stage = document.getElementById('diagramStage');
            const centerX = 200, centerY = 120;
            const pos = { x: centerX + 50, y: centerY + 50 };
            const id = `${t}_${Date.now()}`;
            const dims = t === 'decision' || t === 'start' || t === 'end' || t === 'connector' ? { width: 100, height: 100 } : { width: 120, height: 60 };
            const node = { id, name: 'New Step', type: t, position: pos, dimensions: dims, style: { fill: getNodeTypeColor(t) } };
            currentDiagram.nodes.push(node);
            renderFlowchart(currentDiagram);
            updateConnections();
            hasUnsavedChanges = true;
            document.getElementById('saveButton').classList.add('show');
            updateDiagramInfoBox();
            // Immediate silent autosave for quick add
            saveDiagram(true);
            const el = document.querySelector(`[data-node-id="${id}"]`);
            if (el) openNodeEditor(node, el);
        }

        // Double-click canvas to add a node at clicked location (respect selected type)
        document.addEventListener('DOMContentLoaded', () => {
            const display = document.getElementById('flowchartDisplay');
            display.addEventListener('dblclick', (e) => {
                // Ignore if double-clicking an existing node or UI element
                if (e.target.closest('.node') || e.target.closest('.ribbon') || e.target.closest('.modal')) return;
                const typeSel = document.getElementById('insertNodeType');
                const t = typeSel ? (typeSel.value || 'process') : 'process';
                if (!currentDiagram) currentDiagram = { id: 'untitled', name: 'Untitled', version: '1.0.0', nodes: [], edges: [], layout: { direction: 'top-bottom' } };
                const rect = display.getBoundingClientRect();
                const x = (e.clientX - rect.left) / (zoomScale || 1);
                const y = (e.clientY - rect.top) / (zoomScale || 1);
                // Convert to diagram coords (+padding)
                const pos = { x: Math.round(x) + 50, y: Math.round(y) + 50 };
                const id = `${t}_${Date.now()}`;
                const dims = t === 'decision' || t === 'start' || t === 'end' || t === 'connector' ? { width: 100, height: 100 } : { width: 120, height: 60 };
                const node = { id, name: 'New Step', type: t, position: pos, dimensions: dims, style: { fill: getNodeTypeColor(t) } };
                currentDiagram.nodes.push(node);
                renderFlowchart(currentDiagram);
                updateConnections();
                hasUnsavedChanges = true;
                document.getElementById('saveButton').classList.add('show');
                scheduleAutoSave();
                // Immediate silent autosave for canvas double-click add
                saveDiagram(true);
                updateDiagramInfoBox();
                const el = document.querySelector(`[data-node-id="${id}"]`);
                if (el) openNodeEditor(node, el);
            });
        });

        function calculateConnectionPoints(fromNode, toNode) {
            // Calculate the angle between the two nodes to determine best connection points
            const dx = toNode.centerX - fromNode.centerX;
            const dy = toNode.centerY - fromNode.centerY;
            const angle = Math.atan2(dy, dx);

            // Function to get actual connection point coordinates from DOM elements
            function getActualConnectionPoint(nodeId, targetAngle) {
                // Find the node element in the DOM
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (!nodeElement) {
                    return null;
                }

                // Collect connection point elements
                const connectionPoints = nodeElement.querySelectorAll('.connection-point');
                if (connectionPoints.length === 0) {
                    return null;
                }

                // Compute node center in stage/content coordinates (include container scroll)
                const displayEl = document.getElementById('flowchartDisplay');
                const displayRect = displayEl.getBoundingClientRect();
                const nodeRect = nodeElement.getBoundingClientRect();
                const nodeCX = (((nodeRect.left + nodeRect.width / 2) - displayRect.left) + displayEl.scrollLeft) / (zoomScale || 1);
                const nodeCY = (((nodeRect.top + nodeRect.height / 2) - displayRect.top) + displayEl.scrollTop) / (zoomScale || 1);

                // Choose the connector whose actual angle from the node center best matches targetAngle
                let best = null;
                let bestDiff = Infinity;
                let bestEl = null;

                connectionPoints.forEach(point => {
                    const pr = point.getBoundingClientRect();
                    const px = (((pr.left + pr.width / 2) - displayRect.left) + displayEl.scrollLeft) / (zoomScale || 1);
                    const py = (((pr.top + pr.height / 2) - displayRect.top) + displayEl.scrollTop) / (zoomScale || 1);
                    const ang = Math.atan2(py - nodeCY, px - nodeCX);
                    const diff = Math.abs(normalizeAngle(targetAngle - ang));
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        best = { x: px, y: py };
                        bestEl = point;
                    }
                });

                if (!best) {
                    return null;
                }

                return { x: best.x, y: best.y, side: bestEl?.dataset?.side };
            }

            // Helper function to normalize angle difference
            function normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }

            // Get connection points for both nodes
            const fromPoint = getActualConnectionPoint(fromNode.id, angle);
            const toPoint = getActualConnectionPoint(toNode.id, angle + Math.PI); // Opposite direction

            // Fallback to center points if connection points not found
            if (!fromPoint || !toPoint) {

                return {
                    from: { x: fromNode.centerX, y: fromNode.centerY },
                    to: { x: toNode.centerX, y: toNode.centerY }
                };
            }

            return {
                from: { x: fromPoint.x, y: fromPoint.y },
                to: { x: toPoint.x, y: toPoint.y }
            };
        }

        function getEdgeRenderStyle(edge) {
            const user = edge.style || {};
            const tech = (edge.metadata && edge.metadata.technology) || '';
            const defaults = { stroke: '#34495e', strokeWidth: 2, strokeDasharray: undefined };
            if (tech === 'rest') {
                defaults.strokeDasharray = defaults.strokeDasharray || '6,3';
                defaults.stroke = defaults.stroke || '#2c3e50';
            } else if (tech === 'ws') {
                defaults.stroke = '#2980b9';
            } else if (tech === 'grpc') {
                defaults.stroke = '#8e44ad';
                defaults.strokeWidth = 2.5;
            }
            return {
                stroke: user.stroke || defaults.stroke,
                strokeWidth: user.strokeWidth || defaults.strokeWidth,
                strokeDasharray: user.strokeDasharray || defaults.strokeDasharray
            };
        }

        function drawEdge(svg, fromNode, toNode, edge) {
            // Validate input nodes
            if (!fromNode || !toNode || !fromNode.centerX || !fromNode.centerY || !toNode.centerX || !toNode.centerY) {

                return;
            }

            // Calculate optimal connection points on the edges of the shapes
            const connectionPoints = calculateConnectionPoints(fromNode, toNode);
            const x1 = connectionPoints.from.x;
            const y1 = connectionPoints.from.y;
            const x2 = connectionPoints.to.x;
            const y2 = connectionPoints.to.y;

            // Validate connection points
            if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {

                return;
            }

            const style = getEdgeRenderStyle(edge);
            const edgeId = edge.id || `${edge.from}-${edge.to}`;
            // Direct: from shape edge to shape edge
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('class', 'connection-line');
            line.setAttribute('data-edge-id', edgeId);
            line.setAttribute('stroke', style.stroke);
            line.setAttribute('stroke-width', style.strokeWidth);
            if (style.strokeDasharray) line.setAttribute('stroke-dasharray', style.strokeDasharray);
            // Interactivity
            line.style.cursor = 'pointer';
            line.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const id = line.getAttribute('data-edge-id');
                if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                selectEdge(id);
            });
            line.addEventListener('dblclick', (ev) => { ev.stopPropagation(); openEdgeEditor(line.getAttribute('data-edge-id')); });
            svg.appendChild(line);


            // Add arrowhead (adjusted for edge connection)
            const arrowhead = createArrowhead(svg, x1, y1, x2, y2, style.stroke);
            arrowhead.setAttribute('class', 'connection-arrowhead');
            arrowhead.setAttribute('data-edge-id', edgeId);
            arrowhead.setAttribute('pointer-events', 'auto');
            arrowhead.style.cursor = 'pointer';
            arrowhead.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const id = arrowhead.getAttribute('data-edge-id');
                if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                selectEdge(id);
            });
            arrowhead.addEventListener('dblclick', (ev) => { ev.stopPropagation(); openEdgeEditor(arrowhead.getAttribute('data-edge-id')); });
            svg.appendChild(arrowhead);


            // Add edge label if present
            if (edge.name) {
                // Label midpoint on the direct segment
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                // Create and append text first so getBBox measures correctly
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-family', 'Arial');
                text.setAttribute('font-size', '10');
                text.setAttribute('fill', '#2c3e50');
                text.setAttribute('class', 'connection-label');
                text.setAttribute('data-edge-id', edge.id || `${edge.from}-${edge.to}`);
                text.setAttribute('pointer-events', 'none');
                text.textContent = edge.name;
                svg.appendChild(text);

                // Measure text to size rect
                let bbox = null;
                try { bbox = text.getBBox(); } catch (_) { bbox = null; }
                let textW = 0, textH = 0;
                if (bbox && bbox.width > 0 && bbox.height > 0) {
                    textW = bbox.width; textH = bbox.height;
                } else if (typeof text.getComputedTextLength === 'function') {
                    textW = Math.max(10, text.getComputedTextLength());
                    textH = 12; // approximate for 10px font
                } else {
                    textW = Math.max(40, (edge.name || '').length * 6);
                    textH = 12;
                }

                const padX = 6, padY = 4;
                const rectW = textW + padX * 2;
                const rectH = textH + padY * 2;

                // Compute edge basis vectors
                const dx = x2 - x1, dy = y2 - y1;
                const len = Math.max(1, Math.hypot(dx, dy));
                const tx = dx / len, ty = dy / len; // unit tangent
                const nx = -ty, ny = tx; // unit normal

                // If we have a stored relative offset, respect it; else compute a default
                let centerX, centerY, dirX, dirY;
                const stored = edge.metadata && edge.metadata.labelOffset;
                if (stored && typeof stored.along === 'number' && typeof stored.perp === 'number') {
                    const alongPx = stored.along * len;
                    const perpPx = stored.perp * len;
                    centerX = midX + tx * alongPx + nx * perpPx;
                    centerY = midY + ty * alongPx + ny * perpPx;
                    // For nudging if needed, prefer the normal direction of the stored sign
                    const s = Math.sign(stored.perp) || 1;
                    dirX = nx * s; dirY = ny * s;
                } else {
                    // Choose the normal that is farther from both node centers
                    function minDistToNodes(cx, cy) {
                        const d1 = Math.hypot(cx - fromNode.centerX, cy - fromNode.centerY);
                        const d2 = Math.hypot(cx - toNode.centerX, cy - toNode.centerY);
                        return Math.min(d1, d2);
                    }
                    const baseOffset = 10;
                    const cand1 = { cx: midX + nx * baseOffset, cy: midY + ny * baseOffset };
                    const cand2 = { cx: midX + -nx * baseOffset, cy: midY + -ny * baseOffset };
                    const pick1 = minDistToNodes(cand1.cx, cand1.cy);
                    const pick2 = minDistToNodes(cand2.cx, cand2.cy);
                    const useFirst = pick1 >= pick2;
                    centerX = useFirst ? cand1.cx : cand2.cx;
                    centerY = useFirst ? cand1.cy : cand2.cy;
                    dirX = useFirst ? nx : -nx;
                    dirY = useFirst ? ny : -ny;
                }

                // Initial rect position
                let rectX = centerX - rectW / 2;
                let rectY = centerY - rectH / 2;

                // Clamp within container
                const container = document.getElementById('flowchartDisplay');
                const cw = container ? container.clientWidth : 1000;
                const ch = container ? container.clientHeight : 800;
                function clamp() {
                    rectX = Math.max(2, Math.min(rectX, cw - rectW - 2));
                    rectY = Math.max(2, Math.min(rectY, ch - rectH - 2));
                }
                clamp();

                // Avoid overlapping nodes only if no manual offset exists
                const hasManual = !!(edge.metadata && edge.metadata.labelOffset);
                if (!hasManual) {
                    const nodesRects = Array.from(document.querySelectorAll('#flowchartDisplay .node')).map(n => ({
                        x: parseInt(n.style.left) || 0,
                        y: parseInt(n.style.top) || 0,
                        w: n.offsetWidth,
                        h: n.offsetHeight
                    }));
                    const pad = 6;
                    function intersectsNode(x, y, w, h) {
                        for (const r of nodesRects) {
                            const rx = r.x - pad, ry = r.y - pad, rw = r.w + pad * 2, rh = r.h + pad * 2;
                            if (x < rx + rw && x + w > rx && y < ry + rh && y + h > ry) return true;
                        }
                        return false;
                    }
                    let steps = 0;
                    while (intersectsNode(rectX, rectY, rectW, rectH) && steps < 15) {
                        rectX += dirX * 6;
                        rectY += dirY * 6;
                        clamp();
                        steps++;
                    }
                }

                // Create rect and place text centered on it
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', rectX.toString());
                rect.setAttribute('y', rectY.toString());
                rect.setAttribute('width', rectW.toString());
                rect.setAttribute('height', rectH.toString());
                rect.setAttribute('fill', 'white');
                rect.setAttribute('stroke', '#bdc3c7');
                rect.setAttribute('rx', '3');
                rect.setAttribute('class', 'connection-label-bg');
                rect.setAttribute('data-edge-id', edge.id || `${edge.from}-${edge.to}`);
                rect.setAttribute('pointer-events', 'auto');
                rect.style.cursor = 'move';
                let didDrag = false;
                rect.addEventListener('mousedown', (ev) => {
                    if (!editMode) return;
                    ev.preventDefault(); ev.stopPropagation();
                    const startX = ev.clientX, startY = ev.clientY;
                    const startRectX = parseFloat(rect.getAttribute('x'));
                    const startRectY = parseFloat(rect.getAttribute('y'));
                    function onMove(e2) {
                        didDrag = true;
                        const dxm = e2.clientX - startX;
                        const dym = e2.clientY - startY;
                        const nxX = startRectX + dxm;
                        const nyY = startRectY + dym;
                        rect.setAttribute('x', nxX.toString());
                        rect.setAttribute('y', nyY.toString());
                        text.setAttribute('x', (nxX + rectW / 2).toString());
                        text.setAttribute('y', (nyY + rectH / 2).toString());
                    }
                    function onUp(e2) {
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('mouseup', onUp);
                        if (!didDrag) return; // treat as click later
                        // Compute new center and store relative offsets in metadata
                        const nxX = parseFloat(rect.getAttribute('x'));
                        const nyY = parseFloat(rect.getAttribute('y'));
                        const cX = nxX + rectW / 2;
                        const cY = nyY + rectH / 2;
                        const dxc = cX - midX;
                        const dyc = cY - midY;
                        const along = dxc * tx + dyc * ty; // projection onto tangent
                        const perp = dxc * nx + dyc * ny;   // projection onto normal
                        const aRel = along / len;
                        const pRel = perp / len;
                        edge.metadata = edge.metadata || {};
                        edge.metadata.labelOffset = { along: aRel, perp: pRel };
                        hasUnsavedChanges = true;
                        const sb = document.getElementById('saveButton');
                        if (sb) sb.classList.add('show');
                        scheduleAutoSave();
                        // Immediate silent autosave for label position change
                        saveDiagram(true);
                        // Re-render to snap label to stored position
                        updateConnections();
                        didDrag = false;
                    }
                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                });
                rect.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const id = rect.getAttribute('data-edge-id');
                    if (ev.altKey || ev.metaKey) { selectedEdgeId = id; deleteSelectedEdge(); return; }
                    if (didDrag) { didDrag = false; return; }
                    if (editMode) { openInlineEdgeLabelEditor(id); } else { selectEdge(id); }
                });
                rect.addEventListener('dblclick', (ev) => { ev.stopPropagation(); openEdgeEditor(rect.getAttribute('data-edge-id')); });

                // Insert rect behind text and position text
                svg.insertBefore(rect, text);
                text.setAttribute('x', (rectX + rectW / 2).toString());
                text.setAttribute('y', (rectY + rectH / 2).toString());
                text.setAttribute('dominant-baseline', 'middle');
            }
        }

        function createArrowhead(svg, x1, y1, x2, y2, color) {
            // Calculate arrow direction
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 8;
            const arrowAngle = Math.PI / 6;

            // Calculate arrowhead points (positioned at the connection point)
            const endX = x2;
            const endY = y2;

            const arrowX1 = endX - arrowLength * Math.cos(angle - arrowAngle);
            const arrowY1 = endY - arrowLength * Math.sin(angle - arrowAngle);
            const arrowX2 = endX - arrowLength * Math.cos(angle + arrowAngle);
            const arrowY2 = endY - arrowLength * Math.sin(angle + arrowAngle);

            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
            polygon.setAttribute('fill', color);
            polygon.setAttribute('pointer-events', 'auto');

            return polygon;
        }

        function getNodeTypeColor(type) {
            const colors = {
                'start': '#2ecc71',
                'end': '#e74c3c',
                'process': '#3498db',
                'decision': '#f39c12',
                'data': '#9b59b6',
                'connector': '#1abc9c'
            };
            return colors[type] || '#95a5a6';
        }

        // Choose readable text color against a given background
        function getContrastingTextColor(bgColor, light = '#ffffff', dark = '#1f2937') {
            if (!bgColor || typeof bgColor !== 'string') return dark;
            let c = bgColor.trim();
            // Handle rgb/rgba formats quickly: use the YIQ approximation
            let r, g, b;
            if (c.startsWith('rgb')) {
                const nums = c.replace(/rgba?\(([^)]+)\)/i, '$1').split(',').map(n => parseFloat(n.trim()));
                r = nums[0] || 0; g = nums[1] || 0; b = nums[2] || 0;
            } else {
                // Normalize hex #RGB or #RRGGBB
                if (c[0] === '#') c = c.slice(1);
                if (c.length === 3) c = c.split('').map(ch => ch + ch).join('');
                if (c.length !== 6) return dark;
                r = parseInt(c.slice(0, 2), 16);
                g = parseInt(c.slice(2, 4), 16);
                b = parseInt(c.slice(4, 6), 16);
            }
            // YIQ contrast heuristic
            const yiq = (r * 299 + g * 587 + b * 114) / 1000;
            // Prefer dark text for light backgrounds
            return yiq >= 150 ? dark : light;
        }

        // ===== Color Picker & Favorites =====
        const FAVORITE_COLORS_KEY = 'flowgen.favoriteColors';

        function getFavoriteColors() {
            try {
                const raw = localStorage.getItem(FAVORITE_COLORS_KEY);
                const arr = raw ? JSON.parse(raw) : [];
                if (Array.isArray(arr)) return arr.filter(c => typeof c === 'string');
            } catch (_) { }
            return [];
        }

        function saveFavoriteColors(colors) {
            try { localStorage.setItem(FAVORITE_COLORS_KEY, JSON.stringify(Array.from(new Set(colors)))); } catch (_) { }
        }

        function normalizeHex(color) {
            if (!color) return '';
            let c = color.trim();
            if (c[0] !== '#') c = '#' + c;
            c = c.toUpperCase();
            if (/^#([0-9A-F]{6})$/.test(c)) return c;
            return '';
        }

        function setSelectedColor(color) {
            const norm = normalizeHex(color);
            if (!norm) return;
            const hidden = document.getElementById('selectedColorValue');
            if (hidden) hidden.value = norm;
            const colorInput = document.getElementById('customColorInput');
            const hexInput = document.getElementById('customHexInput');
            if (colorInput) colorInput.value = norm;
            if (hexInput) hexInput.value = norm;
            // Update selection UI on all swatches
            document.querySelectorAll('#fillColorGrid .color-option, #favoriteColors .color-option')
                .forEach(el => el.classList.remove('selected'));
            // Select matching swatches if any
            document.querySelectorAll(`#fillColorGrid .color-option[data-color="${norm}"]`).forEach(el => el.classList.add('selected'));
            document.querySelectorAll(`#favoriteColors .color-option[data-color="${norm}"]`).forEach(el => el.classList.add('selected'));

            // If a node is currently being edited, apply the color immediately and autosave
            if (editingNode && editingNodeElement) {
                editingNode.style = editingNode.style || {};
                editingNode.style.fill = norm;
                try { updateNodeVisual(editingNode, editingNodeElement); } catch (_) { }
                try { updateConnections(); } catch (_) { }
                hasUnsavedChanges = true;
                const sb = document.getElementById('saveButton');
                if (sb) sb.classList.add('show');
                scheduleAutoSave();
                // Silent autosave to persist color change without UI noise
                saveDiagram(true);
            }
        }

        function renderFavoriteColors() {
            const cont = document.getElementById('favoriteColors');
            if (!cont) return;
            const favs = getFavoriteColors();
            cont.replaceChildren();
            favs.forEach(c => {
                const norm = normalizeHex(c);
                if (!norm) return;
                const sw = document.createElement('div');
                sw.className = 'color-option';
                sw.style.background = norm;
                sw.dataset.color = norm;
                sw.addEventListener('click', () => setSelectedColor(norm));
                cont.appendChild(sw);
            });
            // Maintain selection highlight if current selected color is in favorites
            const hidden = document.getElementById('selectedColorValue');
            const sel = hidden ? hidden.value : '';
            if (sel) {
                document.querySelectorAll(`#favoriteColors .color-option[data-color="${sel}"]`).forEach(el => el.classList.add('selected'));
            }
        }

        function addFavoriteColor(color) {
            const norm = normalizeHex(color);
            if (!norm) return;
            const favs = getFavoriteColors();
            if (!favs.includes(norm)) {
                favs.push(norm);
                saveFavoriteColors(favs);
                renderFavoriteColors();
            }
        }

        function removeFavoriteColor(color) {
            const norm = normalizeHex(color);
            const favs = getFavoriteColors().filter(c => normalizeHex(c) !== norm);
            saveFavoriteColors(favs);
            renderFavoriteColors();
        }

        function initColorPickerControls() {
            if (window._colorPickerInited) return;
            window._colorPickerInited = true;
            const colorInput = document.getElementById('customColorInput');
            const hexInput = document.getElementById('customHexInput');
            const favBtn = document.getElementById('addFavoriteColorBtn');
            if (colorInput) {
                colorInput.addEventListener('input', (e) => {
                    const v = e.target.value;
                    if (/^#([0-9A-Fa-f]{6})$/.test(v)) setSelectedColor(v);
                });
            }
            if (hexInput) {
                hexInput.addEventListener('input', (e) => {
                    let v = (e.target.value || '').trim();
                    if (/^#?[0-9A-Fa-f]{6}$/.test(v)) {
                        if (v[0] !== '#') v = '#' + v;
                        setSelectedColor(v);
                    }
                });
            }
            if (favBtn) {
                favBtn.addEventListener('click', () => {
                    const hidden = document.getElementById('selectedColorValue');
                    const v = hidden ? hidden.value : '';
                    const color = normalizeHex(v || (colorInput ? colorInput.value : ''));
                    if (color) addFavoriteColor(color);
                });
            }
        }

        // Inline editor for edge labels: overlays a small input over the label rect
        function openInlineEdgeLabelEditor(edgeId) {
            if (!edgeId || !currentDiagram) return;
            const display = document.getElementById('flowchartDisplay');
            const svg = display.querySelector('svg.connections-layer');
            if (!svg) return;
            const rect = svg.querySelector(`rect.connection-label-bg[data-edge-id="${edgeId}"]`);
            if (!rect) return;
            const existing = display.querySelector('.edge-label-input');
            if (existing) existing.remove();

            // Compute absolute position of rect
            const rectBox = rect.getBoundingClientRect();
            const hostBox = display.getBoundingClientRect();
            // Include scroll so overlay matches content coordinates even when scrolled/zoomed
            const left = (rectBox.left - hostBox.left) + display.scrollLeft;
            const top = (rectBox.top - hostBox.top) + display.scrollTop;
            const width = rectBox.width;
            const height = rectBox.height;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edge-label-input';
            input.value = (currentDiagram.edges.find(e => (e.id || `${e.from}-${e.to}`) === edgeId)?.name) || '';
            Object.assign(input.style, {
                position: 'absolute',
                left: `${left}px`,
                top: `${top}px`,
                width: `${Math.max(60, width)}px`,
                height: `${height}px`,
                padding: '2px 6px',
                border: '1px solid #3498db',
                borderRadius: '3px',
                fontFamily: 'Arial, sans-serif',
                fontSize: '11px',
                zIndex: '2000',
                boxSizing: 'border-box'
            });

            function commit(save) {
                const el = input;
                const val = el.value.trim();
                el.remove();
                if (!save) return;
                const edge = currentDiagram.edges.find(e => (e.id || `${e.from}-${e.to}`) === edgeId);
                if (!edge) return;
                edge.name = val;
                hasUnsavedChanges = true;
                const sb = document.getElementById('saveButton');
                if (sb) sb.classList.add('show');
                scheduleAutoSave();
                // Immediate silent autosave for label text edit
                saveDiagram(true);
                updateConnections();
            }

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') commit(true);
                else if (e.key === 'Escape') commit(false);
            });
            input.addEventListener('blur', () => commit(true));

            display.appendChild(input);
            input.focus();
            input.select();
        }

        function showNodeInfo(node) {
            let info = `Node: ${node.name || 'Unnamed'}\\nType: ${node.type}\\nPosition: (${node.position.x}, ${node.position.y})`;

            if (node.integrations?.jira) {
                info += `\\nJira: ${node.integrations.jira.projectKey}-${node.integrations.jira.issueKey}`;
            }
            if (node.drillDown) {
                info += `\\nDrill-down: ${node.drillDown}`;
            }

            alert(info);
        }

        function renderSVG() {
            if (!currentDiagram) {
                alert('Please load a diagram first');
                return;
            }

            const display = document.getElementById('flowchartDisplay');
            const svg = createSVG(currentDiagram);
            display.innerHTML = '';
            const stage = document.createElement('div');
            stage.id = 'diagramStage';
            stage.style.position = 'absolute';
            stage.style.inset = '0';
            stage.style.transformOrigin = '0 0';
            stage.innerHTML = svg;
            display.appendChild(stage);
            applyZoom();
            isRenderMode = true;
            updateDiagramInfoBox();
        }

        function renderEditable() {
            if (!currentDiagram) {
                alert('Please load a diagram first');
                return;
            }
            // Re-render the interactive editor
            renderFlowchart(currentDiagram);
            updateConnections();
            showMessage('Returned to edit mode', 'info');
            isRenderMode = false;
            updateDiagramInfoBox();
        }


        function createSVG(diagram) {
            // Enhanced SVG generation with proper connections
            const width = 1000;
            const height = 800;
            let svgContent = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
                    </marker>
                </defs>`;

            // Find bounds and normalize positions
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            diagram.nodes.forEach(node => {
                minX = Math.min(minX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxX = Math.max(maxX, node.position.x + (node.dimensions?.width || 100));
                maxY = Math.max(maxY, node.position.y + (node.dimensions?.height || 50));
            });

            const padding = 50;
            const scaleX = (width - 2 * padding) / (maxX - minX);
            const scaleY = (height - 2 * padding) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down

            // Create node position map for edges
            const nodePositions = {};
            diagram.nodes.forEach(node => {
                const x = (node.position.x - minX) * scale + padding;
                const y = (node.position.y - minY) * scale + padding;
                const width = (node.dimensions?.width || 100) * scale;
                const height = (node.dimensions?.height || 50) * scale;
                nodePositions[node.id] = {
                    x, y, width, height,
                    centerX: x + width / 2,
                    centerY: y + height / 2
                };
            });

            // Add edges first (behind nodes)
            if (diagram.edges) {
                diagram.edges.forEach(edge => {
                    const fromNode = nodePositions[edge.from];
                    const toNode = nodePositions[edge.to];

                    if (fromNode && toNode) {
                        const strokeColor = edge.style?.stroke || '#34495e';
                        const strokeWidth = edge.style?.strokeWidth || 2;
                        const strokeDash = edge.style?.strokeDasharray || '';

                        svgContent += `
                            <line x1="${fromNode.centerX}" y1="${fromNode.centerY}" 
                                  x2="${toNode.centerX}" y2="${toNode.centerY}" 
                                  stroke="${strokeColor}" stroke-width="${strokeWidth}" 
                                  ${strokeDash ? `stroke-dasharray="${strokeDash}"` : ''}
                                  marker-end="url(#arrowhead)"/>
                        `;

                        // Add edge label with minimal margin from shapes/line
                        if (edge.name) {
                            const midX = (fromNode.centerX + toNode.centerX) / 2;
                            const midY = (fromNode.centerY + toNode.centerY) / 2;
                            const label = String(edge.name);
                            const approxCharW = 7; // px approximation
                            const fontSize = 11;
                            const padX = 8;
                            const padY = 4;
                            const textW = Math.max(10, label.length * approxCharW);
                            const rectW = Math.min(Math.max(40, textW + padX * 2), width - 10);
                            const rectH = fontSize + padY * 2; // ~19px

                            // Compute edge basis vectors
                            const dx = toNode.centerX - fromNode.centerX;
                            const dy = toNode.centerY - fromNode.centerY;
                            const len = Math.max(1, Math.hypot(dx, dy));
                            const tx = dx / len, ty = dy / len;
                            const nx = -ty, ny = tx;
                            const nx2 = -nx, ny2 = -ny;
                            const baseOffset = 10;
                            function minDistToNodes(cx, cy) {
                                const d1 = Math.hypot(cx - fromNode.centerX, cy - fromNode.centerY);
                                const d2 = Math.hypot(cx - toNode.centerX, cy - toNode.centerY);
                                return Math.min(d1, d2);
                            }
                            let centerX, centerY, dirX, dirY;
                            const stored = edge.metadata && edge.metadata.labelOffset;
                            if (stored && typeof stored.along === 'number' && typeof stored.perp === 'number') {
                                const alongPx = stored.along * len;
                                const perpPx = stored.perp * len;
                                centerX = midX + tx * alongPx + nx * perpPx;
                                centerY = midY + ty * alongPx + ny * perpPx;
                                const s = Math.sign(stored.perp) || 1;
                                dirX = nx * s; dirY = ny * s;
                            } else {
                                const cand1 = { cx: midX + nx * baseOffset, cy: midY + ny * baseOffset };
                                const cand2 = { cx: midX + nx2 * baseOffset, cy: midY + ny2 * baseOffset };
                                const pick1 = minDistToNodes(cand1.cx, cand1.cy);
                                const pick2 = minDistToNodes(cand2.cx, cand2.cy);
                                const useFirst = pick1 >= pick2;
                                centerX = useFirst ? cand1.cx : cand2.cx;
                                centerY = useFirst ? cand1.cy : cand2.cy;
                                dirX = useFirst ? nx : nx2;
                                dirY = useFirst ? ny : ny2;
                            }

                            let rectX = centerX - rectW / 2;
                            let rectY = centerY - rectH / 2;
                            // Clamp to canvas
                            function clamp() {
                                rectX = Math.max(5, Math.min(rectX, width - rectW - 5));
                                rectY = Math.max(5, Math.min(rectY, height - rectH - 5));
                            }
                            clamp();

                            // Avoid overlapping nodes: nudge along normal
                            const pad = 6;
                            function intersectsNode(x, y, w, h) {
                                for (const id in nodePositions) {
                                    const n = nodePositions[id];
                                    const rx = n.x - pad, ry = n.y - pad, rw = n.width + pad * 2, rh = n.height + pad * 2;
                                    if (x < rx + rw && x + w > rx && y < ry + rh && y + h > ry) return true;
                                }
                                return false;
                            }
                            let steps = 0;
                            while (intersectsNode(rectX, rectY, rectW, rectH) && steps < 15) {
                                rectX += dirX * 6;
                                rectY += dirY * 6;
                                clamp();
                                steps++;
                            }

                            const textX = rectX + rectW / 2;
                            const textY = rectY + rectH / 2;

                            svgContent += `
                                <rect x="${rectX}" y="${rectY}" width="${rectW}" height="${rectH}" 
                                      fill="white" fill-opacity="0.95" stroke="#bdc3c7" rx="4"/>
                                <text x="${textX}" y="${textY}" text-anchor="middle" dominant-baseline="middle"
                                      font-family="Arial" font-size="${fontSize}" fill="#2c3e50">${label}</text>
                            `;
                        }
                    }
                });
            }

            // Add nodes (on top of edges)
            diagram.nodes.forEach(node => {
                const pos = nodePositions[node.id];
                if (!pos) return;

                const fill = node.style?.fill || getNodeTypeColor(node.type);
                const textFill = node.style?.textColor || getContrastingTextColor(fill);
                const stroke = node.style?.stroke || '#333';

                // Different shapes for different node types
                if (node.type === 'decision') {
                    // Diamond shape for decisions
                    const cx = pos.centerX;
                    const cy = pos.centerY;
                    const size = Math.min(pos.width, pos.height) / 2;
                    svgContent += `
                        <polygon points="${cx},${cy - size} ${cx + size},${cy} ${cx},${cy + size} ${cx - size},${cy}" 
                                 fill="${fill}" stroke="${stroke}" stroke-width="2"/>
                    `;
                } else if (node.type === 'start' || node.type === 'end') {
                    // Ellipse for start/end
                    svgContent += `
                        <ellipse cx="${pos.centerX}" cy="${pos.centerY}" 
                                 rx="${pos.width / 2}" ry="${pos.height / 2}" 
                                 fill="${fill}" stroke="${stroke}" stroke-width="2"/>
                    `;
                } else {
                    // Rectangle for process nodes
                    svgContent += `
                        <rect x="${pos.x}" y="${pos.y}" width="${pos.width}" height="${pos.height}" 
                              fill="${fill}" stroke="${stroke}" stroke-width="2" rx="8"/>
                    `;
                }

                // Add node text with wrapping support
                const textContent = node.name || 'Node';
                if (textContent.length > 20 && textContent.includes(' ')) {
                    // Multi-line text for long content
                    const words = textContent.split(' ');
                    const maxCharsPerLine = 15;
                    const lines = [];
                    let currentLine = '';
                    for (const word of words) {
                        if ((currentLine + word).length <= maxCharsPerLine || currentLine === '') {
                            currentLine += (currentLine === '' ? '' : ' ') + word;
                        } else {
                            lines.push(currentLine);
                            currentLine = word;
                        }
                    }
                    if (currentLine) lines.push(currentLine);
                    // Render multiple lines
                    const lineHeight = 14;
                    const startY = pos.centerY - ((lines.length - 1) * lineHeight / 2);
                    lines.forEach((line, index) => {
                        svgContent += `
                            <text x="${pos.centerX}" y="${startY + index * lineHeight}" 
                                  text-anchor="middle" font-family="Arial" font-size="12" fill="${textFill}" font-weight="bold">
                                ${line}
                            </text>
                        `;
                    });
                } else {
                    // Single line text
                    svgContent += `
                        <text x="${pos.centerX}" y="${pos.centerY + 5}" 
                              text-anchor="middle" font-family="Arial" font-size="12" fill="${textFill}" font-weight="bold">
                            ${textContent}
                        </text>
                    `;
                }

                // Add integration indicators
                if (node.integrations?.jira) {
                    svgContent += `
                        <circle cx="${pos.x + pos.width - 8}" cy="${pos.y + 8}" r="6" 
                                fill="#0052CC" stroke="white" stroke-width="1"/>
                        <text x="${pos.x + pos.width - 8}" y="${pos.y + 12}" 
                              text-anchor="middle" font-family="Arial" font-size="8" fill="white" font-weight="bold">
                            J
                        </text>
                    `;
                }
                if (node.drillDown) {
                    svgContent += `
                        <circle cx="${pos.x + pos.width - 8}" cy="${pos.y + pos.height - 8}" r="6" 
                                fill="#9b59b6" stroke="white" stroke-width="1"/>
                        <text x="${pos.x + pos.width - 8}" y="${pos.y + pos.height - 4}" 
                              text-anchor="middle" font-family="Arial" font-size="10" fill="white" font-weight="bold">
                            ‚Üì
                        </text>
                    `;
                }
            });

            svgContent += `</svg>`;
            return svgContent;
        }

        // showJSON removed per UX change

        function clearDisplay() {
            const display = document.getElementById('flowchartDisplay');
            // Clearing the canvas means no active diagram; reset last-opened state
            try { localStorage.removeItem(LAST_DIAGRAM_KEY); } catch (_) { }
            const tpl = document.getElementById('emptyStateTemplate');
            if (display && tpl) {
                display.innerHTML = '';
                display.appendChild(tpl.content.cloneNode(true));
            } else if (display) {
                display.innerHTML = '<div class="loading">Open or create a diagram to get started</div>';
            }
        }

        // Auto-load on page load
        window.onload = () => {
            // Clicking on the background clears selection and hides labels
            const container = document.getElementById('flowchartDisplay');
            if (container) {
                container.addEventListener('mousedown', (e) => {
                    if (!e.target.closest('.node')) {
                        setSelectedNode(null);
                        clearEdgeSelection();
                        // Removed: add-step overlay cleanup (deprecated)
                        // Close editor if user clicks on empty canvas area
                        if (editorDocked) closeNodeEditor();
                        // Do not clear info panel body here; keep last info until next hover/selection
                    }
                });
            }
            // Apply any restored zoom to update the UI label immediately
            applyZoom();
            // Ensure grid overlay/snapping are applied
            updateGridSettings();
            // Initialize sections: show diagram by default
            switchMainSection('diagram');
            // Try to auto-load the last opened diagram if present; otherwise show empty state
            const display = document.getElementById('flowchartDisplay');
            const tpl = document.getElementById('emptyStateTemplate');
            const lastId = getLastOpenedDiagramId && getLastOpenedDiagramId();
            if (lastId) {
                if (display) display.innerHTML = '<div class="loading">Loading last diagram‚Ä¶</div>';
                (async () => {
                    try {
                        const res = await fetch(`http://localhost:3001/api/v1/diagrams/${encodeURIComponent(lastId)}`);
                        if (!res.ok) throw new Error(`Failed to load last diagram (${res.status})`);
                        const diag = await res.json();
                        currentDiagram = normalizeDiagramNumbers(diag);
                        renderFlowchart(currentDiagram);
                        updateConnections();
                        updateDiagramInfoBox();
                        showMessage(`Restored diagram: ${diag.name || diag.id}`, 'success');
                    } catch (e) {
                        // If auto-load fails, clear the remembered ID and show empty state
                        try { localStorage.removeItem(LAST_DIAGRAM_KEY); } catch (_) { }
                        if (display && tpl) {
                            display.innerHTML = '';
                            display.appendChild(tpl.content.cloneNode(true));
                        } else if (display) {
                            display.innerHTML = '<div class="loading">Open or create a diagram to get started</div>';
                        }
                        console.warn('Auto-load last diagram failed:', e);
                    }
                })();
            } else {
                if (display && tpl) {
                    display.innerHTML = '';
                    display.appendChild(tpl.content.cloneNode(true));
                }
            }
        };

        // Ensure numeric fields (x, y, width, height, rotation, strokeWidth) are numbers, not strings
        function normalizeDiagramNumbers(diagram) {
            if (!diagram) return diagram;
            const out = JSON.parse(JSON.stringify(diagram));
            try {
                if (Array.isArray(out.nodes)) {
                    out.nodes.forEach(n => {
                        if (!n.position) n.position = { x: 0, y: 0 };
                        n.position.x = Number(n.position.x) || 0;
                        n.position.y = Number(n.position.y) || 0;
                        if (!n.dimensions) n.dimensions = { width: 100, height: 50 };
                        n.dimensions.width = Number(n.dimensions.width) || 0;
                        n.dimensions.height = Number(n.dimensions.height) || 0;
                        if (n.rotation != null) n.rotation = Number(n.rotation) || 0;
                    });
                }
                if (Array.isArray(out.edges)) {
                    out.edges.forEach(e => {
                        if (e?.style?.strokeWidth != null) e.style.strokeWidth = Number(e.style.strokeWidth) || 0;
                    });
                }
            } catch (_) { }
            return out;
        }

        function getDiagramForSave(diagram) {
            const normalized = normalizeDiagramNumbers(diagram);
            return normalized;
        }
    </script>
</body>

</html>